<!DOCTYPE html>
<html lang="zh-cn" dir="ltr">
    <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content=" &mdash;&mdash;by zyh 2025.1.6\n1.词法分析\r功能：将输入字符串识别为有意义的子串，即词法单元(token)\n1.1 词法单元的描述-正则式\r正则表达式(Regular Expression)是一种文本模式，包括普通字符（例如，a 到 z 之间的字母）和特殊字符（称为&quot;元字符&quot;），可以用来描述和匹配字符串的特定模式。\n">
<title>编译原理知识复习</title>

<link rel='canonical' href='http://localhost:1313/p/compiler-review/'>

<link rel="stylesheet" href="/scss/style.min.79778804a771dc130d7089f1049b111129b334d4d5d3505894a60cd3735cf7b6.css"><meta property='og:title' content="编译原理知识复习">
<meta property='og:description' content=" &mdash;&mdash;by zyh 2025.1.6\n1.词法分析\r功能：将输入字符串识别为有意义的子串，即词法单元(token)\n1.1 词法单元的描述-正则式\r正则表达式(Regular Expression)是一种文本模式，包括普通字符（例如，a 到 z 之间的字母）和特殊字符（称为&quot;元字符&quot;），可以用来描述和匹配字符串的特定模式。\n">
<meta property='og:url' content='http://localhost:1313/p/compiler-review/'>
<meta property='og:site_name' content='陌辞咖啡馆'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:published_time' content='2024-12-29T17:13:45&#43;08:00'/><meta property='article:modified_time' content='2024-12-29T17:13:45&#43;08:00'/><meta property='og:image' content='http://localhost:1313/post/001.png' />
<meta name="twitter:title" content="编译原理知识复习">
<meta name="twitter:description" content=" &mdash;&mdash;by zyh 2025.1.6\n1.词法分析\r功能：将输入字符串识别为有意义的子串，即词法单元(token)\n1.1 词法单元的描述-正则式\r正则表达式(Regular Expression)是一种文本模式，包括普通字符（例如，a 到 z 之间的字母）和特殊字符（称为&quot;元字符&quot;），可以用来描述和匹配字符串的特定模式。\n"><meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content='http://localhost:1313/post/001.png' /><link rel="alternate" type="application/json" href="http://localhost:1313/p/compiler-review/index.json">
    </head>
    <body class="
    article-page
    ">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky ">
    <button class="hamburger hamburger--spin" type="button" id="toggle-menu" aria-label="切换菜单">
        <span class="hamburger-box">
            <span class="hamburger-inner"></span>
        </span>
    </button>

    <header>
        
            
            <figure class="site-avatar">
                <a href="/">
                
                    
                    
                    
                        
                        <img src="/img/222_hu15625150182145111778.png" width="300"
                            height="300" class="site-logo" loading="lazy" alt="Avatar">
                    
                
                </a>
                
                    <span class="emoji">🍥</span>
                
            </figure>
            
        
        
        <div class="site-meta">
            <h1 class="site-name"><a href="/">陌辞咖啡馆</a></h1>
            <h2 class="site-description">观我旧往，同我仰春</h2>
        </div>
    </header><ol class="menu-social">
            
                <li>
                    <a 
                        href='https://github.com/Zhuyh1139'
                        target="_blank"
                        title="GitHub"
                        rel="me"
                    >
                        
                        
                            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M9 19c-4.3 1.4 -4.3 -2.5 -6 -3m12 5v-3.5c0 -1 .1 -1.4 -.5 -2c2.8 -.3 5.5 -1.4 5.5 -6a4.6 4.6 0 0 0 -1.3 -3.2a4.2 4.2 0 0 0 -.1 -3.2s-1.1 -.3 -3.5 1.3a12.3 12.3 0 0 0 -6.2 0c-2.4 -1.6 -3.5 -1.3 -3.5 -1.3a4.2 4.2 0 0 0 -.1 3.2a4.6 4.6 0 0 0 -1.3 3.2c0 4.6 2.7 5.7 5.5 6c-.6 .6 -.6 1.2 -.5 2v3.5" />
</svg>



                        
                    </a>
                </li>
            
                <li>
                    <a 
                        href='https://space.bilibili.com/527591205'
                        target="_blank"
                        title="Bilibili"
                        rel="me"
                    >
                        
                        
                            <?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1735383931276" class="icon" viewBox="0 0 1638 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5443" stroke="currentColor" xmlns:xlink="http://www.w3.org/1999/xlink" width="319.921875" height="200"><path d="M1226.1376 379.392c4.1472 0.768 36.7104-6.656 38.0928-4.1472 2.048 3.1232 16.5888 109.1584 12.8 109.824a2040.32 2040.32 0 0 0-30.8224 7.0656c-2.048-14.4384-19.712-103.5776-20.0704-112.6912z m51.9168-10.1376l14.1824 114.0736c7.2704-0.3584 36.7104-2.4576 39.4752-2.816a13869.568 13869.568 0 0 0-11.4176-111.2576 106.9056 106.9056 0 0 0-42.24 0z m-28.0064 158.3104s64-16.4864 87.1936-8.448c11.776 43.2128 33.28 285.3888 35.328 295.2192-14.5408 1.7408-62.3104 5.9392-66.0992 7.0144-3.1232-18.2784-56.4224-282.2144-56.4224-293.7856z m237.1072-145.3056c3.7888 1.024 37.7344-3.5328 38.0928-1.024 0.6656 8.3968 4.096 110.1824 0.3584 110.5408l-30.8224 2.7648c-0.7168-14.0288-8.3456-102.8096-7.6288-112.2816z m52.2752-2.816l2.7648 112.64c7.2704 0 36.352 1.792 39.424 1.4336-0.6656-43.1616 0-111.2576 0-111.2576a188.672 188.672 0 0 0-42.1888-2.816z m-44.6464 151.296s65.4336-8.8064 87.552 1.7408c4.864 50.5344 4.1472 286.0544 4.864 295.8848-14.848 0-62.3104 0.7168-66.0992 1.3824-0.7168-18.2272-27.392-287.4368-26.3168-299.008zM1342.8224 241.152c37.7344 195.1232 66.4576 528.5888 67.4816 549.9904 0 0 29.7472 0.7168 63.3344 2.816-19.712-210.2272-43.9296-546.1504-43.6224-557.056-8.2944-9.4208-87.1936 4.2496-87.1936 4.2496z m-83.0976 461.568c-7.2704-54.784-200.448-116.8896-309.1456-96.8704 0 0-13.5168-120.7808-18.688-237.6192a2458.7264 2458.7264 0 0 1 0.3584-214.1184c-7.2704-5.2736-85.504 32.6144-127.744 48.4352 0 0 50.5344 216.8832 87.2448 666.88 0 0 58.4704 6.2976 158.8736-13.312 100.352-19.6608 219.136-81.1008 209.1008-153.3952z m-236.0832 98.6112l-16.9472-123.904c4.096-2.0992 108.3392 37.2224 119.3984 44.2368-1.7408 7.68-102.4512 79.6672-102.4512 79.6672zM421.632 379.4432c4.1472 0.7168 36.7104-6.656 38.0928-4.1984 2.048 3.1232 16.5888 109.1584 12.8 109.824-3.7888 0.7168-30.8224 7.0656-30.8224 7.0656-2.048-14.4384-19.712-103.5776-20.0704-112.6912z m51.9168-10.1888l14.1824 114.0736c7.2704-0.3584 36.7104-2.4576 39.4752-2.816-4.5056-43.1616-11.4176-111.2576-11.4176-111.2576a106.9568 106.9568 0 0 0-42.24 0z m-28.0064 158.3104s64-16.4864 87.2448-8.448c11.776 43.2128 33.2288 285.3888 35.328 295.2192-14.592 1.7408-62.3616 5.9392-66.1504 7.0144-3.1232-18.2784-56.4224-282.2144-56.4224-293.7856z m237.1072-145.3056c3.7888 1.024 37.7344-3.5328 38.0928-1.024 0.6656 8.3968 4.096 110.1824 0.3584 110.5408l-30.8224 2.7648c-0.7168-14.0288-7.9872-102.8096-7.6288-112.2816z m52.2752-2.816l2.7648 112.64c7.2704 0 36.352 1.792 39.424 1.4336-0.6656-43.1616 0-111.2576 0-111.2576a211.9168 211.9168 0 0 0-42.1888-2.816z m-44.6464 151.296s65.4336-8.8064 87.552 1.7408c4.864 50.5344 4.1984 286.0544 4.864 295.8848-14.848 0-62.3104 0.7168-66.0992 1.3824-0.3584-18.2272-27.392-287.4368-26.3168-299.008zM538.3168 241.152c37.7344 195.1232 66.4576 528.5888 67.4816 549.9904 0 0 29.7984 0.7168 63.3344 2.816-19.712-210.2272-43.9296-546.1504-43.6224-557.3632-8.2944-9.1648-87.1936 4.5568-87.1936 4.5568zM455.168 702.72c-7.2704-54.784-200.448-116.8896-309.1456-96.8704 0 0-13.4656-120.7808-18.688-237.6192a2459.7504 2459.7504 0 0 1 0.3584-214.1184c-7.2704-4.9152-85.504 32.6144-127.744 48.4352 0 0 50.5344 216.8832 87.2448 666.88 0 0 58.4704 6.2976 158.8736-13.312 100.352-19.6608 219.136-81.1008 209.1008-153.3952zM219.136 801.28l-16.9472-123.904c4.096-2.0992 108.3392 37.2224 119.3984 44.2368-1.7408 7.68-102.4512 79.6672-102.4512 79.6672z" fill="currentColor" p-id="5444"></path></svg>
                        
                    </a>
                </li>
            
                <li>
                    <a 
                        href='https://blog.csdn.net/2301_77127818?spm=1010.2135.3001.5421'
                        target="_blank"
                        title="CSDN"
                        rel="me"
                    >
                        
                        
                            <?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1735810899052" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5554" xmlns:xlink="http://www.w3.org/1999/xlink" width="200" height="200"><path d="M672.299893 374.246613c-30.004361-6.185886-61.073984-9.064446-91.749634-9.685593-41.186028-0.835018-41.774429 0.635473-46.343491 40.450271-5.634324 49.097208-10.223852 98.314143-15.640212 151.144372 31.054273 0.64673 60.628846 2.199085 90.162486 1.626034 32.461319-0.629333 63.944358-6.411013 90.443895-27.424606 29.843702-23.666002 39.58967-55.474452 34.120099-91.764983C728.039381 403.724994 705.951317 381.184629 672.299893 374.246613zM657.900951 500.909407c-23.899316 18.074657-51.306526 20.665669-82.688257 16.613376 3.77907-38.039361 7.468089-75.166957 11.500938-115.768677 18.166755 1.276063 34.453696 1.294482 50.341548 3.818979 20.170388 3.204995 36.021401 13.485129 40.776705 34.985816C683.099866 464.37533 678.124552 485.615073 657.900951 500.909407zM503.672334 369.780905c-1.798972 13.027711-3.473101 25.15082-5.205559 37.702694-25.127284-2.170432-49.036833-5.149277-73.019037-5.934153-12.665461-0.414439-25.856901 1.651616-38.011732 5.276167-5.569856 1.660826-9.213849 9.779737-13.731746 14.969946 4.811586 4.14132 8.978489 10.243295 14.548344 12.07092 20.290115 6.65763 41.37534 10.943236 61.541635 17.912975 21.155832 7.312546 42.117237 17.118889 43.12417 43.801599 1.025353 27.151383-17.099447 42.173518-39.515992 51.339272-49.971112 20.434401-101.250008 18.301831-152.551418 5.27412-2.898003-0.735757-6.615675-6.172583-6.522554-9.320273 0.313132-10.570753 2.179642-21.095457 3.244904-29.927613 30.601972 2.39556 60.002582 5.354961 89.476871 6.611581 9.122775 0.388856 19.11229-2.468215 27.425629-6.486738 5.1503-2.489704 10.989285-10.093892 10.780531-15.165398-0.184195-4.474918-7.630794-10.624988-13.091156-12.520151-13.767562-4.780887-28.474518-6.819313-42.334177-11.387351-13.833053-4.558829-27.958772-9.378601-40.431851-16.687054-29.591969-17.339924-31.312146-47.346331-4.841262-69.316715 20.354584-16.893762 44.992727-22.240537 70.433142-25.527396C426.702312 358.37104 479.267505 361.432773 503.672334 369.780905zM959.473381 445.082938c-2.599198 35.797297-7.000438 71.464635-10.664897 107.833961-19.322068 0-37.140898 0-57.091276 0 3.668553-34.127262 6.729262-67.476811 10.968819-100.67491 4.237511-33.18275-7.367805-47.762817-40.654932-48.962132-40.755216-1.468444-40.883129-1.482771-45.26595 38.807864-3.950985 36.326347-7.580652 72.687486-11.507078 110.530372-19.435655 0-37.172621 0-55.32812 0 5.699816-58.20361 11.107989-115.27749 17.277502-172.269505 0.410346-3.78828 6.15007-9.250688 10.17985-10.045797 38.780235-7.6574 77.796854-12.57848 117.373221-6.016017C941.27081 371.999432 962.885084 398.084531 959.473381 445.082938zM251.989151 359.040283c11.636015 0.905626 23.165606 3.169179 35.938514 4.976338-1.662873 15.230889-3.163039 28.963659-4.333702 39.687908-30.569226 0-58.112536-1.639337-85.379553 0.411369-34.80469 2.616594-56.879452 20.388353-63.36926 46.690392-8.036024 32.567743 5.16258 57.6807 38.144762 63.129806 25.119097 4.149507 51.359738 1.601474 77.102029 1.802042 4.854565 0.037862 9.718339-1.010003 13.933337-1.483794 1.093914 1.38044 1.75804 1.827625 1.74883 2.260483-0.845251 41.947368-0.855484 43.796482-42.837644 43.626613-31.178093-0.125867-63.113433-2.62171-93.28971-9.93221-33.339316-8.077979-58.892295-29.67588-64.336284-66.284659-5.77554-38.832424 10.547217-69.608358 41.553395-91.998297C150.319587 360.548636 200.264093 355.014596 251.989151 359.040283z" p-id="5555"></path><path d="M137.883347 595.666538l-1.199315 1.499144c6.715959 8.794293 15.628956 15.409968 26.742061 19.847024-1.239224 1.759063-2.298346 3.357468-3.177366 4.797259-10.553357-5.196349-19.407002-12.172227-26.561959-20.925588-6.116301 7.91425-15.150048 15.150048-27.101241 21.705348-0.799202-1.358951-1.798972-2.858094-2.998287-4.497431 12.351306-6.196119 21.684882-13.670348 28.000728-22.424732L137.883347 595.667561zM106.34505 646.871757l24.762987 0 0-10.432607-19.426445 0 0-4.376681 19.426445 0 0-9.233292-17.207917 0 0-4.376681 39.45357 0 0 4.376681-17.268292 0 0 9.233292 19.48682 0 0 4.376681-19.48682 0 0 10.432607 24.703635 0 0 4.437056-54.44296 0L106.346073 646.871757zM195.804525 642.434701c2.698458-0.279363 5.536087-0.60989 8.513908-0.989537l0-18.138102-7.374968 0 0-4.317329 7.374968 0 0-14.090926-8.154727 0 0-4.317329 20.506033 0 0 4.317329-7.974625 0 0 14.090926 6.955412 0 0 4.317329-6.955412 0 0 17.568121c2.39863-0.339738 4.876054-0.699941 7.435343-1.079588-0.160659 1.599428-0.25992 3.137457-0.299829 4.617158-7.475252 0.959861-13.950733 1.858324-19.426445 2.698458L195.804525 642.434701zM216.430284 638.536928c5.216815-3.177366 10.673084-6.715959 16.368806-10.612709L232.79909 610.476849l-15.349593 0 0-4.317329 15.349593 0 0-10.673084 4.556783 0 0 10.673084 17.028838 0 0 4.317329-17.028838 0 0 5.336542c0.99977 3.27765 2.168386 6.315846 3.507894 9.113565 3.457752-3.357468 6.345522-6.456039 8.664334-9.293667l3.897773 3.298116c-3.298116 3.258207-6.804986 6.5553-10.522658 9.893324 3.477194 6.016017 7.804756 10.673084 12.981662 13.970176-0.239454 0.360204-0.760317 0.979304-1.558495 1.858324-0.880043 0.918929-1.499144 1.639337-1.858324 2.158153-6.5553-4.736884-11.592013-11.552104-15.110139-20.445658l0 19.367093c0 4.756327-2.478448 7.135514-7.435343 7.135514-1.959631 0-4.057409-0.020466-6.29538-0.060375-0.239454-1.518586-0.559748-3.157923-0.959861-4.916986 2.357697 0.279363 4.497431 0.419556 6.41613 0.419556 2.477424 0 3.717671-1.218758 3.717671-3.657296l0-11.422144c-4.137227 2.87856-8.593725 6.085602-13.370519 9.623171L216.430284 638.536928zM217.749326 616.891955l3.657296-2.218528c2.598174 3.397377 5.175883 7.154957 7.735172 11.272741l-3.837398 2.638083C222.545562 623.907743 220.028229 620.009969 217.749326 616.891955zM240.593614 599.024006l2.638083-2.998287c2.837628 1.87879 5.435803 3.816932 7.794523 5.816472l-2.87856 3.298116C245.789962 602.941222 243.271606 600.902796 240.593614 599.024006zM288.621467 646.152373c1.958608-0.199545 3.917216-0.409322 5.875824-0.629333l0-22.814612-6.595208 0 0-3.597945 59.419298 0 0 3.597945-31.298843 0 0 19.996426c1.918699-0.279363 3.837398-0.569982 5.756097-0.86981-0.040932 0.719384-0.020466 1.998517 0.060375 3.837398-1.87879 0.25992-3.817955 0.530073-5.816472 0.809435l0 7.645121-4.076852 0 0-7.045463c-6.875594 0.979304-14.290471 2.088568-22.24463 3.327792L288.621467 646.152373zM296.955272 597.405135l41.491996 0 0 19.247366-4.197602 0 0-1.379417L301.152874 615.273085l0 1.379417-4.197602 0L296.955272 597.405135zM298.574143 627.504664l13.370519 0 0-4.797259L298.574143 622.707404 298.574143 627.504664zM298.574143 635.779118l13.370519 0 0-4.797259L298.574143 630.981858 298.574143 635.779118zM311.945685 643.304512l0-4.047176L298.574143 639.257336l0 5.785773C303.091016 644.502803 307.548538 643.923612 311.945685 643.304512zM334.25069 600.883353 301.152874 600.883353l0 3.837398 33.097816 0L334.25069 600.883353zM301.152874 611.79589l33.097816 0 0-3.837398L301.152874 607.958492 301.152874 611.79589zM319.020824 630.442576l0-3.477194 23.804149 0 0 3.477194c-2.038426 4.89652-4.717442 9.153474-8.035 12.770861 3.417843 2.49789 7.65433 4.397147 12.71151 5.695722-1.039679 1.518586-1.939165 2.918469-2.698458 4.197602-5.15644-1.698688-9.503445-3.997034-13.041014-6.895037-3.437286 3.078105-7.445576 5.596462-12.021801 7.55507-0.679475-1.199315-1.599428-2.457981-2.75781-3.777023 4.53734-1.738597 8.443299-3.957125 11.721973-6.655584-3.338025-3.577478-5.716188-7.874341-7.135514-12.891611L319.020824 630.442576zM338.267167 630.442576l-12.651135 0c1.258667 3.937682 3.28686 7.305383 6.085602 10.103102C334.479911 637.628232 336.667739 634.260531 338.267167 630.442576zM379.939265 649.149637c16.488533-7.335059 25.382087-18.34788 26.681686-33.037441l-25.603121 0 0-4.676509 25.812899 0c0.100284-5.376451 0.149403-10.79281 0.149403-16.249079l5.216815 0c0 5.376451-0.050142 10.79281-0.149403 16.249079l26.591635 0 0 4.676509-26.681686 0c2.837628 15.968693 12.151761 26.501584 27.941376 31.598672-2.038426 1.958608-3.558036 3.577478-4.556783 4.856611-13.011338-5.236258-21.515013-14.560624-25.51307-27.971052-3.118014 12.131295-11.841699 21.85475-26.172079 29.170366C382.857734 652.688229 381.618511 651.149177 379.939265 649.149637zM476.234425 607.77839l23.084765 0 0-13.07069 5.15644 0 0 13.07069 23.324218 0 0 27.341718-4.916986 0 0-3.237741-18.407232 0 0 22.305005-5.15644 0 0-22.305005-18.167778 0 0 3.237741-4.916986 0L476.234425 607.77839zM481.150388 627.445312l18.167778 0 0-15.229866-18.167778 0L481.150388 627.445312zM522.882861 612.215446l-18.407232 0 0 15.229866 18.407232 0L522.882861 612.215446zM565.153594 605.199659l28.780487 0c-2.018983-3.837398-3.597945-6.635117-4.736884-8.394181l4.617158-2.158153c1.119497 1.719154 2.797719 4.516874 5.036713 8.394181l-4.317329 2.158153 28.180829 0 0 4.437056-11.062963 0c-2.13871 11.411911-6.735401 20.585851-13.791098 27.52182 5.316076 3.877307 13.760398 7.355525 25.332968 10.432607-1.838881 2.078335-3.237741 3.816932-4.197602 5.216815-11.272741-3.897773-19.596314-7.974625-24.972764-12.231579-5.395894 4.197602-14.020318 8.43409-25.872251 12.71151-1.039679-1.39886-2.238994-2.958378-3.597945-4.676509 11.432377-3.437286 20.036335-7.265474 25.812899-11.482519-7.29515-7.794523-11.93175-16.95823-13.910824-27.491121l-11.302417 0L565.152571 605.199659zM606.525863 609.636714l-25.272593 0c1.798972 9.832949 6.095835 17.958 12.891611 24.373107C600.639806 627.974361 604.7668 619.850333 606.525863 609.636714zM671.851685 604.50995l-4.466732 0 0 36.305881 4.466732 0 0 5.066389-14.930037 0 0-5.066389 4.466732 0 0-36.305881-4.466732 0 0-5.066389 14.930037 0L671.851685 604.50995zM738.196719 604.780103l-13.401218 0 0 41.102117-6.02625 0 0-41.102117-13.340843 0 0-5.336542 32.767288 0L738.195695 604.780103zM771.71409 611.496062l0-4.317329 19.48682 0 0 4.437056c-1.939165 3.877307-4.237511 7.544837-6.895037 11.002588l0 30.908964-4.676509 0 0-25.482371c-2.198062 2.318812-4.577249 4.516874-7.135514 6.595208-0.360204-1.438769-0.918929-3.097548-1.679245-4.976338 6.15621-4.956895 11.252275-11.012821 15.289218-18.167778L771.71409 611.496062zM777.649266 597.105307l4.197602-2.098801c1.478677 2.358721 3.038196 5.096065 4.676509 8.214079l-4.437056 2.278903C780.527826 602.261747 779.049149 599.464027 777.649266 597.105307zM785.024234 625.946168l3.118014-2.578732c2.438539 2.717901 4.657067 5.296633 6.655584 7.735172l-3.717671 2.937912C789.161461 631.28271 787.143501 628.584252 785.024234 625.946168zM791.20091 646.991484l16.848737 0 0-29.380144-14.270005 0 0-4.676509 14.270005 0 0-17.568121 4.797259 0 0 17.568121 15.229866 0 0 4.676509-15.229866 0 0 29.380144 17.028838 0 0 4.676509-38.673811 0L791.201933 646.991484zM867.8885 599.143733l51.565423 0 0 4.676509-46.468334 0 0 41.851177 47.428196 0 0 4.556783-52.524261 0L867.889523 599.143733zM877.601722 610.416474l3.357468-3.177366c4.996804 4.116761 10.222829 8.634658 15.679098 13.550621 4.177136-4.516874 8.184403-9.43386 12.021801-14.749936l4.376681 2.937912c-4.197602 5.436826-8.454556 10.472516-12.770861 15.110139 4.976338 4.53734 10.132778 9.393951 15.46932 14.569834l-4.137227 4.197602c-4.837168-5.056156-9.813506-10.05296-14.930037-14.989389-5.776563 5.856381-11.652388 11.012821-17.628496 15.46932-0.959861-1.239224-2.238994-2.537799-3.837398-3.897773 6.275937-4.27742 12.241812-9.263991 17.897625-14.959713C888.084471 619.739816 882.918821 615.053074 877.601722 610.416474z" fill="currentColor" p-id="5556"></path></svg>
                        
                    </a>
                </li>
            
        </ol><ol class="menu" id="main-menu">
        
        
        
        <li >
            <a href='/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="5 12 3 12 12 3 21 12 19 12" />
  <path d="M5 12v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-7" />
  <path d="M9 21v-6a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v6" />
</svg>



                
                <span>首页</span>
            </a>
        </li>
        
        
        <li >
            <a href='/archives/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <rect x="3" y="4" width="18" height="4" rx="2" />
  <path d="M5 8v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-10" />
  <line x1="10" y1="12" x2="14" y2="12" />
</svg>



                
                <span>归档</span>
            </a>
        </li>
        
        
        <li >
            <a href='/about/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="7" r="4" />
  <path d="M6 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2" />
</svg>



                
                <span>关于</span>
            </a>
        </li>
        
        
        <li >
            <a href='/search/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="10" cy="10" r="7" />
  <line x1="21" y1="21" x2="15" y2="15" />
</svg>



                
                <span>搜索</span>
            </a>
        </li>
        
        <li class="menu-bottom-section">
            <ol class="menu">

                
                    <li id="dark-mode-toggle">
                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="8" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="16" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <span>暗色模式</span>
                    </li>
                
            </ol>
        </li>
    </ol>
</aside>

    <aside class="sidebar right-sidebar sticky">
        
            
                
    <section class="widget archives">
        <div class="widget-icon">
            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <line x1="5" y1="9" x2="19" y2="9" />
  <line x1="5" y1="15" x2="19" y2="15" />
  <line x1="11" y1="4" x2="7" y2="20" />
  <line x1="17" y1="4" x2="13" y2="20" />
</svg>



        </div>
        <h2 class="widget-title section-title">目录</h2>
        
        <div class="widget--toc">
            <nav id="TableOfContents">
  <ol>
    <li><a href="#11-词法单元的描述-正则式">1.1 词法单元的描述-正则式</a></li>
    <li><a href="#12-词法单元的识别-转换图">1.2 词法单元的识别-转换图</a></li>
    <li><a href="#13-有限自动机">1.3 有限自动机</a></li>
  </ol>

  <ol>
    <li><a href="#21-上下文无关文法">2.1 上下文无关文法</a></li>
    <li><a href="#22-自顶向下分析方法">2.2 自顶向下分析方法</a>
      <ol>
        <li><a href="#221-递归下降语法分析">2.2.1 递归下降语法分析</a></li>
        <li><a href="#222-消除左递归提取左公因子">2.2.2 消除左递归，提取左公因子</a></li>
      </ol>
    </li>
    <li><a href="#23-ll1文法">2.3 ll(1)文法</a></li>
    <li><a href="#24-自底向上分析方法">2.4 自底向上分析方法</a>
      <ol>
        <li><a href="#241-归约">2.4.1 归约</a></li>
        <li><a href="#242-句柄">2.4.2 句柄</a></li>
        <li><a href="#243-移进-归约分析方法">2.4.3 移进-归约分析方法</a></li>
      </ol>
    </li>
    <li><a href="#25-lr文法">2.5 LR文法</a>
      <ol>
        <li><a href="#251-slr分析">2.5.1 SLR分析</a></li>
        <li><a href="#252-lr分析">2.5.2 LR分析</a></li>
      </ol>
    </li>
  </ol>

  <ol>
    <li><a href="#31-中间代码分析">3.1 中间代码分析</a></li>
    <li><a href="#32-语法制导翻译">3.2 语法制导翻译</a>
      <ol>
        <li><a href="#321-s属性定义">3.2.1 S属性定义</a></li>
        <li><a href="#322-l属性定义">3.2.2 L属性定义</a></li>
        <li><a href="#323-抽象语法树的构造">3.2.3 抽象语法树的构造</a>
          <ol>
            <li><a href="#3231-s属性ast">3.2.3.1 S属性AST</a></li>
            <li><a href="#3232-l属性ast">3.2.3.2 L属性AST</a></li>
          </ol>
        </li>
        <li><a href="#324-语法制导翻译方案">3.2.4 语法制导翻译方案</a>
          <ol>
            <li><a href="#3241-s属性定义的sdt两种实现方式">3.2.4.1 S属性定义的SDT两种实现方式</a></li>
            <li><a href="#3242-l属性定义的sdt两种实现方式">3.2.4.2 L属性定义的SDT两种实现方式</a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#33-中间代码生成">3.3 中间代码生成</a>
      <ol>
        <li><a href="#331-布尔表达式的控制流翻译">3.3.1 布尔表达式的控制流翻译</a></li>
        <li><a href="#332-基于符号回填的布尔表达式翻译">3.3.2 基于符号回填的布尔表达式翻译</a></li>
        <li><a href="#333-基于符号回填的其它语句翻译">3.3.3 基于符号回填的其它语句翻译</a></li>
      </ol>
    </li>
    <li><a href="#34-类型表达式">3.4 类型表达式</a></li>
    <li><a href="#35-符号表与声明语句翻译">3.5 符号表与声明语句翻译</a></li>
    <li><a href="#36-数组寻址翻译">3.6 数组寻址翻译</a></li>
  </ol>

  <ol>
    <li><a href="#41-存储组织">4.1 存储组织</a></li>
    <li><a href="#42-空间的栈式分配">4.2 空间的栈式分配</a></li>
    <li><a href="#43-非局部名字的访问">4.3 非局部名字的访问</a></li>
  </ol>

  <ol>
    <li><a href="#61-常见的优化方式">6.1 常见的优化方式</a></li>
    <li><a href="#62-到达定值分析">6.2 到达定值分析</a></li>
    <li><a href="#63-可用表达式分析">6.3 可用表达式分析</a></li>
    <li><a href="#64-活跃变量分析">6.4 活跃变量分析</a></li>
    <li><a href="#65-基本块内优化">6.5 基本块内优化</a></li>
    <li><a href="#66-流图中的循环">6.6 流图中的循环</a></li>
    <li><a href="#67-寄存器分配">6.7 寄存器分配</a></li>
  </ol>
</nav>
        </div>
    </section>

            
        
    </aside>


            <main class="main full-width">
    <article class="has-image main-article">
    <header class="article-header">
        <div class="article-image">
            <a href="/p/compiler-review/">
                
                    <img src="/post/001.png" loading="lazy" alt="Featured image of post 编译原理知识复习" />
                
            </a>
        </div>
    

    <div class="article-details">
    
    <header class="article-category">
        
            <a href="/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" >
                编译原理
            </a>
        
    </header>
    

    <div class="article-title-wrapper">
        <h2 class="article-title">
            <a href="/p/compiler-review/">编译原理知识复习</a>
        </h2>
    
        
    </div>

    
    
    
    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">Dec 29, 2024</time>
            </div>
        

        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



                <time class="article-time--reading">
                    阅读时长: 42 分钟
                </time>
            </div>
        
    </footer>
    

    
</div>

</header>

    <section class="article-content">
    
    
    <blockquote>
<p>&mdash;&mdash;by zyh 2025.1.6</p>
</blockquote>
<hr>
<h1 id="1词法分析">1.词法分析
</h1><blockquote>
<p>功能：将输入字符串识别为有意义的子串，即词法单元(token)</p>
</blockquote>
<h2 id="11-词法单元的描述-正则式">1.1 词法单元的描述-正则式
</h2><blockquote>
<p>正则表达式(Regular Expression)是一种文本模式，包括普通字符（例如，a 到 z 之间的字母）和特殊字符（称为&quot;元字符&quot;），可以用来描述和匹配字符串的特定模式。</p>
</blockquote>
<p>一个简单的例子：正整数识别</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">digit-&gt;0|1|2|3|4|5|6|7|8|9
</span></span><span class="line"><span class="cl">digits-&gt;digit digit*
</span></span></code></pre></td></tr></table>
</div>
</div><p>其中，*表示闭包，即出现零次或多次。</p>
<p>下面是常用的一些正则表达式语法：</p>
<p>常用语法：</p>
<ul>
<li>[abc]  匹配方括号中所有单字符，不一定按顺序；</li>
<li>[^abc] 匹配除了方括号中字符外所有字符；</li>
<li>[a-z]   匹配区间所有字符，注意大小写；</li>
<li>[\s\S]  匹配所有。\s 是匹配所有空白符，包括换行，\S 非空白符，不包括换行；</li>
<li>\w       匹配字母、数字、下划线。等价于 [A-Za-z0-9_]；</li>
<li>\d        匹配任意一个阿拉伯数字（0 到 9）。等价于 [0-9]。</li>
</ul>
<p>特殊字符：</p>
<ul>
<li>*  表示匹配前面的子表达式零次或多次；</li>
<li>+  表示匹配前面的子表达式一次或多次；</li>
<li>.   表示匹配除换行以外的任意字符；</li>
<li>?   表示匹配前面的子表达式零次或一次；</li>
<li>|   表示两项之间选择。</li>
</ul>
<p>如果要匹配特殊字符，需要在前面加上\进行转义，\本身也是特殊字符。</p>
<p>eg：匹配由偶数个0和奇数个1构成的01串：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">1(00|11)*((01|10)(00|11)*(01|10)(00|11)*)*|0(00|11)*(01|10)
</span></span><span class="line"><span class="cl">(00|11)*((01|10)(00|11)*(01|10)(00|11)*)*
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="12-词法单元的识别-转换图">1.2 词法单元的识别-转换图
</h2><p>如下图的例子：</p>
<p><img src="/imgs/001-001.png"
	
	
	
	loading="lazy"
	
	
></p>
<h2 id="13-有限自动机">1.3 有限自动机
</h2><p><strong>NFA</strong>：不确定的有限自动机</p>
<p>如下图的例子(a|b)*ab（2是接受状态，两个圈画不出来）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl"> graph LR
</span></span><span class="line"><span class="cl">	begin--&gt;a((0))
</span></span><span class="line"><span class="cl">	a((0))--a--&gt;a((0))
</span></span><span class="line"><span class="cl">	a((0))--b--&gt;a((0))
</span></span><span class="line"><span class="cl">	a((0))--a--&gt;b((1))
</span></span><span class="line"><span class="cl">	b((1))--b--&gt;c((2))
</span></span></code></pre></td></tr></table>
</div>
</div><p>NFA对于一个token，有可能要尝试很多不同的路径，大部分都是白费功夫，效率很低。</p>
<p><strong>DFA</strong>：确定的有限自动机</p>
<p>和上面一样的正则式，有如下图（2是接受状态）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">graph LR
</span></span><span class="line"><span class="cl">	begin--&gt;a((0))
</span></span><span class="line"><span class="cl">	a((0))--b--&gt;a((0))
</span></span><span class="line"><span class="cl">	a((0))--a--&gt;b((1))
</span></span><span class="line"><span class="cl">	b((1))--a--&gt;b((1))
</span></span><span class="line"><span class="cl">	b((1))--b--&gt;c((2))
</span></span><span class="line"><span class="cl">	c((2))--a--&gt;b((1))
</span></span><span class="line"><span class="cl">	c((2))--b--&gt;a((0))
</span></span></code></pre></td></tr></table>
</div>
</div><p>语法制导的构造算法：NFA的构造(f表示接受状态)</p>
<ol>
<li>
<p>单字符（包括空ε）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">graph LR
</span></span><span class="line"><span class="cl">	begin--&gt;a((i))
</span></span><span class="line"><span class="cl">	a((i))--ε/a--&gt;b((f))
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>选择式s|t：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">graph LR
</span></span><span class="line"><span class="cl">	begin--&gt;a((i))
</span></span><span class="line"><span class="cl">	a((i))--ε--&gt;b(s)
</span></span><span class="line"><span class="cl">	a((i))--ε--&gt;c(t)
</span></span><span class="line"><span class="cl">	b(s)--ε--&gt;d((f))
</span></span><span class="line"><span class="cl">	c(t)--ε--&gt;d((f))
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>st:<img src="/imgs/001-002.png"
	
	
	
	loading="lazy"
	
	
></p>
</li>
<li>
<p>s*:<img src="/imgs/001-003.png"
	
	
	
	loading="lazy"
	
	
></p>
</li>
</ol>
<p>由上述算法即可得到NFA，具有下列性质：</p>
<ul>
<li>N(r)的状态数最多是r中符号和算符总数的两倍</li>
<li>N(r)只有一个接受状态，接受状态没有向外的转换</li>
</ul>
<p>由NFA即可构造出DFA:从每个NFA构造时的i构成的集合出发，通过不同的输入符号构造出状态转移表，每个状态包含多个NFA中的状态。</p>
<p>DFA的化简：先从终态集合和非终态集合出发，如果从非终态集合输入字符得到的输出集合不属于任何一个分割后的集合的子集，则可以继续分割，否则分割停止，最后可以得到化简后的DFA。</p>
<h1 id="2语法分析">2.语法分析
</h1><h2 id="21-上下文无关文法">2.1 上下文无关文法
</h2><blockquote class="alert alert-note">
    <p>语法分析的目的是教会计算机判断输入合法性。</p></blockquote>
<p>上下文无关文法(CFG)就是说这个文法中所有的产生式左边只有一个非终结符，也就是说，只要找到符合产生式右边的串，就可以把它归约为对应的非终结符。</p>
<hr>
$$
(V_T,V_N,S,P)
$$<ul>
<li>VT是终结符集合，终结符是文法所定义的语言的基本符号，即token</li>
<li>VN是非终结符集合，非终结符表示语法成分的符号，存放中间结果，也称为语法变量。</li>
<li>S是开始符号，属于非终结符，是该文法中最大的语法成分，分析开始的地方。</li>
<li>P是产生式集合，产生式描述了将终结符和非终结符组合成串的方法。</li>
</ul>
<blockquote class="alert alert-caution">
    <p>终结符集合与非终结符集合的交集为空。</p></blockquote>
<p>推导：是从文法推出文法所描述的语言中所包含的合法串集合的动作。</p>
<p>也就是把符号串中的非终结符用其产生式右部的串来代替，有最左推导与最右推导等多种方式。</p>
<blockquote class="alert alert-note">
    <p><strong>CFG与正则表达式的联系和区别：</strong></p>
<p>正则表达式可以定义一些简单的语言，能表示给定结构的固定次数的重复或者没有指定次数的重复，但不能用于描述配对或嵌套的结构，因为有限自动机无法记录访问同一状态的次数；</p>
<p>它们两个都能表示语言，能用正则表达式表示的语言都能用CFG表示。</p></blockquote>
<p>文法的二义性：文法的某些句子存在不止一种最左(最右)推导， 或者不止一棵分析树，则该文法是二义的。</p>
<p>产生原因：有些操作都是左（右）结合的，但不同的优先级在文法中没有表达出来。</p>
<p>消除办法：定义运算优先级和结合律。</p>
<h2 id="22-自顶向下分析方法">2.2 自顶向下分析方法
</h2><blockquote>
<p>自顶向下：针对输入串，从文法的开始符号出发，尝试根据产生式规则推导（derive）出该输入串。</p>
</blockquote>
<blockquote>
<p>自底向上：针对输入串，尝试根据产生式规则归约（reduce）到文法的开始符号。</p>
</blockquote>
<h3 id="221-递归下降语法分析">2.2.1 递归下降语法分析
</h3><p>数据结构：一个输入缓冲区和向前看指针<em>lookahead</em></p>
<p>分析过程：自左向右扫描输入串，设计一个辅助过程<em>match()</em>，将<em>lookahead</em>指向的位置与产生式迭代生成的终结符进行匹配，如匹配，将<em>lookahead</em>挪到下一个位置，为每一个非终结符写一个分析过程。</p>
<h3 id="222-消除左递归提取左公因子">2.2.2 消除左递归，提取左公因子
</h3><p><code>S-&gt;Sa|b</code>这样的文法是左递归的，而自顶向下分析方法无法处理左递归，因为在输入缓冲区的lookahead指针纹丝未动。</p>
<p>消除实例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">直接左递归：
</span></span><span class="line"><span class="cl">A-&gt;Aa|b
</span></span><span class="line"><span class="cl">消除直接左递归：
</span></span><span class="line"><span class="cl">A-&gt;bA&#39;
</span></span><span class="line"><span class="cl">A&#39;-&gt;aA&#39;|ε
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">非直接左递归：
</span></span><span class="line"><span class="cl">S-&gt;Aa|b
</span></span><span class="line"><span class="cl">A-&gt;Sd|ε
</span></span><span class="line"><span class="cl">先变换成直接左递归：
</span></span><span class="line"><span class="cl">S-&gt;Aa|b
</span></span><span class="line"><span class="cl">A-&gt;Aad|bd|ε
</span></span><span class="line"><span class="cl">再消除左递归：
</span></span><span class="line"><span class="cl">S-&gt;Aa|b
</span></span><span class="line"><span class="cl">A-&gt;bdA&#39;|A&#39;
</span></span><span class="line"><span class="cl">A&#39;-&gt;adA&#39;|ε
</span></span></code></pre></td></tr></table>
</div>
</div><p>提取左公因子其实也就是消除回溯：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">A-&gt;aB1|aB2|aB3|B4
</span></span><span class="line"><span class="cl">改为：
</span></span><span class="line"><span class="cl">A-&gt;aA&#39;|B4
</span></span><span class="line"><span class="cl">A&#39;-&gt;B1|B2|B3
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="23-ll1文法">2.3 ll(1)文法
</h2><p>两个和文法有关的函数：</p>
<ul>
<li>
$$
  FIRST(α)=\{a|a=>*a...,a∈V_T\}
  $$<p>表示可从a推导得到的串的首符号的集合，具体计算时从左向右看，找产生式第一个终结符，若为非终结符则在其产生式中找。</p>
</li>
<li>
$$
  FOLLOW(A)=\{a|S=>*...Aa...,a∈V_T\}
  $$<p>表示可能在推导过程中紧跟在A右边的终结符号的集合，计算方法：</p>
<p>文法开始符添加$，有下面两种情况：</p>
<ol>
<li>A-&gt;aB  即B后为空，直接将FOLLOW(A)加入到FOLLOW(B)中；</li>
<li>A-&gt;aBb  即B后非空，若b为终结符，直接添加；若b为非终结符，则将FIRST(b)中的除ε添加到FOLLOW(B)中,若FIRST(b)中含有ε，则也把FOLLOW(A)加到FOLLOW(B)中</li>
</ol>
</li>
</ul>
<blockquote class="alert alert-note">
    <p>注意FIRST集合和FOLLOW集合都是针对非终结符的，且FIRST集合中只会出现终结符和ε</p></blockquote>
<p>an example:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">E-&gt;TE&#39;
</span></span><span class="line"><span class="cl">E&#39;-&gt;+TE&#39;|ε
</span></span><span class="line"><span class="cl">T-&gt;FT&#39;
</span></span><span class="line"><span class="cl">T&#39;-&gt;*FT&#39;|ε
</span></span><span class="line"><span class="cl">F-&gt;(E)|id
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">FIRST(E)=FIRST(T)=FIRST(F)={(,id}
</span></span><span class="line"><span class="cl">FIRST(E&#39;)={+,ε}
</span></span><span class="line"><span class="cl">FIRST(T&#39;)={*,ε}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">FOLLOW(E)={),$}
</span></span><span class="line"><span class="cl">FOLLOW(E&#39;)=FOLLOW(E)
</span></span><span class="line"><span class="cl">FOLLOW(T)=FIRST(E&#39;)-{ε}+FOLLOW(E&#39;)={+,),$}
</span></span><span class="line"><span class="cl">FOLLOW(T&#39;)=FOLLOW(T)
</span></span><span class="line"><span class="cl">FOLLOW(F)=FIRST(T&#39;)-{ε}+FOLLOW(T&#39;)={*,+,),$}
</span></span></code></pre></td></tr></table>
</div>
</div><p>ll(1)文法的性质：没有公共左因子，不是二义的，不含左递归</p>
<p>由FIRST集与FOLLOW集可以得出LL(1)预测分析表：</p>
<p>行为非终结符，列为终结符加上$，每个单元都是产生式，仍以上面例子为例：</p>
<div class="table-wrapper"><table>
  <thead>
      <tr>
          <th></th>
          <th>id</th>
          <th>+</th>
          <th>*</th>
          <th>(</th>
          <th>)</th>
          <th>$</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>E</td>
          <td>E-&gt;TE'</td>
          <td></td>
          <td></td>
          <td>E-&gt;TE'</td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td>E'</td>
          <td></td>
          <td>E&rsquo;-&gt;+TE'</td>
          <td></td>
          <td></td>
          <td>E&rsquo;-&gt;ε</td>
          <td>E&rsquo;-&gt;ε</td>
      </tr>
      <tr>
          <td>T</td>
          <td>T-&gt;FT'</td>
          <td></td>
          <td></td>
          <td>T-&gt;FT'</td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td>T'</td>
          <td></td>
          <td>T&rsquo;-&gt;ε</td>
          <td>T&rsquo;-&gt;*FT'</td>
          <td></td>
          <td>T&rsquo;-&gt;ε</td>
          <td>T&rsquo;-&gt;ε</td>
      </tr>
      <tr>
          <td>F</td>
          <td>F-&gt;id</td>
          <td></td>
          <td></td>
          <td>F-&gt;(E)</td>
          <td></td>
          <td></td>
      </tr>
  </tbody>
</table></div>
<p>构造规则：对文法的每个产生式A-&gt;α，有如下操作：</p>
<ul>
<li>对FIRST(α)的每个终结符a，把A-&gt;α加入M[A,a]</li>
<li>如果ε在FIRST(α)中，对FOLLOW(A)的每个终结符b（包括$），把A-&gt;α加入M[A,b]</li>
</ul>
<h2 id="24-自底向上分析方法">2.4 自底向上分析方法
</h2><h3 id="241-归约">2.4.1 归约
</h3><p>每一步，特定子串被替换为相匹配的某个产生式左部的非终结符，最终，把输入串归约成文法的开始符号。</p>
<blockquote class="alert alert-note">
    <p>归约是最右推导的逆过程。</p></blockquote>
<h3 id="242-句柄">2.4.2 句柄
</h3><p>句柄(Handles)是指可规约串，和某个产生式右部匹配。</p>
<p>句柄的右边仅含终结符，如果文法二义，那么句柄可能不唯一。</p>
<h3 id="243-移进-归约分析方法">2.4.3 移进-归约分析方法
</h3><p>栈保存已扫描过的文法符号，缓冲区存放还未分析的其余符号；</p>
<p>移进(shift)：将下一个输入符号放到栈顶，以形成句柄；</p>
<p>归约(reduce)：将句柄替换为对应的产生式的左部非终结符；</p>
<p>接受(accept)：分析成功；</p>
<p>报错(error)：发现语法错误。</p>
$$
E->E+E|E*E|(E)|id
$$<div class="table-wrapper"><table>
  <thead>
      <tr>
          <th>stack</th>
          <th>input</th>
          <th>action</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>$</td>
          <td>id*id+id$</td>
          <td>移进</td>
      </tr>
      <tr>
          <td>$id</td>
          <td>*id+id$</td>
          <td>按E-&gt;id规约</td>
      </tr>
      <tr>
          <td>$E</td>
          <td>*id+id$</td>
          <td>移进</td>
      </tr>
      <tr>
          <td>$E*</td>
          <td>id+id$</td>
          <td>移进</td>
      </tr>
      <tr>
          <td>$E*id</td>
          <td>+id$</td>
          <td>按E-&gt;id规约</td>
      </tr>
      <tr>
          <td>$E*E</td>
          <td>+id$</td>
          <td>移进</td>
      </tr>
      <tr>
          <td>$E*E+</td>
          <td>id$</td>
          <td>移进</td>
      </tr>
      <tr>
          <td>$E*E+id</td>
          <td>$</td>
          <td>按E-&gt;id规约</td>
      </tr>
      <tr>
          <td>$E*E+E</td>
          <td>$</td>
          <td>按E-&gt;E+E规约</td>
      </tr>
      <tr>
          <td>$E*E</td>
          <td>$</td>
          <td>按E-&gt;E*E规约</td>
      </tr>
      <tr>
          <td>$E</td>
          <td>$</td>
          <td>接受</td>
      </tr>
  </tbody>
</table></div>
<p>两类冲突：</p>
<ol>
<li>移进-归约冲突：解析器无法确定当前的输入是否应该作为一个终结符进行移进，还是应该作为一个非终结符进行归约。比如E-&gt;A|Aa，如果此时stack为A，input为a&hellip;$，此时无法判断进行移进还是规约。</li>
<li>归约-归约冲突：在解析过程中，解析器面对多个不同的产生式规则可以应用，但这些产生式规则的目标符号是相同的，无法确定应该应用哪个产生式。比如E-&gt;a(B)|a,C-&gt;a，如果此时stack为&hellip;a(a，input为,a)&hellip;$，此时无法判断规约到哪一个。</li>
</ol>
<h2 id="25-lr文法">2.5 LR文法
</h2><h3 id="251-slr分析">2.5.1 SLR分析
</h3><p>活前缀（可行前缀）是指在解析过程中，解析器当前处理的输入串的一部分，并且该部分在当前状态下的所有可能后续扩展中都不包含任何产生式规则的左部（即产生式的左符号）。</p>
<p>活前缀用于解决移进-归约冲突。</p>
<p>LR分析方法的特点：栈中的文法符号总是形成一个活前缀；分析表的转移函数本质上是识别活前缀的DFA</p>
<p>LR(0)项目：在右部的某个地方加点的产生式，加点的目的是用来表示分析过程中的状态。</p>
<p>增广文法（拓广文法）：开始符E加上E&rsquo;-&gt;E。、</p>
$$
E->E+T|T\\
T->T*F|F\\
F->(E)|id
$$<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">首先拓广文法：
</span></span><span class="line"><span class="cl">E&#39;-&gt;E
</span></span><span class="line"><span class="cl">E-&gt;E+T|T
</span></span><span class="line"><span class="cl">T-&gt;T*F|F
</span></span><span class="line"><span class="cl">F-&gt;(E)|id
</span></span><span class="line"><span class="cl">构造LR(0)项目集规范族：
</span></span><span class="line"><span class="cl">I0:
</span></span><span class="line"><span class="cl">E&#39;-&gt;·E----------------这个拓广得来的是初始项目，下面都是求闭包得来的
</span></span><span class="line"><span class="cl">E-&gt;·E+T
</span></span><span class="line"><span class="cl">E-&gt;·T
</span></span><span class="line"><span class="cl">T-&gt;·T*F
</span></span><span class="line"><span class="cl">T-&gt;·F
</span></span><span class="line"><span class="cl">F-&gt;·(E)
</span></span><span class="line"><span class="cl">F-&gt;·id
</span></span></code></pre></td></tr></table>
</div>
</div><blockquote class="alert alert-important">
    <p>这里的每个I构造规则：如果点后是产生式A-&gt;a，且A-&gt;·a不在闭包中，加入。</p>
<p>人话：点后面如果是产生式就把产生式从头加个点添加到项目集中，单个项目集中重复的不算。</p></blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">我们可以得到其余的项目集（通过移进点后面的终结符或非终结符）：
</span></span><span class="line"><span class="cl">I0--E--&gt;I1:
</span></span><span class="line"><span class="cl">E&#39;-&gt;E·
</span></span><span class="line"><span class="cl">E-&gt;E·+T
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">I0--T--&gt;I2:
</span></span><span class="line"><span class="cl">E-&gt;T·
</span></span><span class="line"><span class="cl">T-&gt;T·*F
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">I0--F--&gt;I3:
</span></span><span class="line"><span class="cl">T-&gt;F·
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">I0--(--&gt;I4:
</span></span><span class="line"><span class="cl">F-&gt;(·E)
</span></span><span class="line"><span class="cl">E-&gt;·E+T
</span></span><span class="line"><span class="cl">E-&gt;·T
</span></span><span class="line"><span class="cl">T-&gt;·T*F
</span></span><span class="line"><span class="cl">T-&gt;·F
</span></span><span class="line"><span class="cl">F-&gt;·(E)
</span></span><span class="line"><span class="cl">F-&gt;·id
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">I0--id--I5：
</span></span><span class="line"><span class="cl">F-&gt;id· 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">I1--+--&gt;I6:
</span></span><span class="line"><span class="cl">E-&gt;E+·T
</span></span><span class="line"><span class="cl">T-&gt;·T*F
</span></span><span class="line"><span class="cl">T-&gt;·F
</span></span><span class="line"><span class="cl">F-&gt;·(E)
</span></span><span class="line"><span class="cl">F-&gt;·id
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">I2--*--&gt;I7:
</span></span><span class="line"><span class="cl">T-&gt;T*·F
</span></span><span class="line"><span class="cl">F-&gt;·(E)
</span></span><span class="line"><span class="cl">F-&gt;·id
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">I4--E--&gt;I8:
</span></span><span class="line"><span class="cl">F-&gt;(E·)
</span></span><span class="line"><span class="cl">E-&gt;E·+T
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">I6--T--&gt;I9:
</span></span><span class="line"><span class="cl">E-&gt;E+T·
</span></span><span class="line"><span class="cl">T-&gt;T·*F
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">I7--F--&gt;I10:
</span></span><span class="line"><span class="cl">T-&gt;T*F·
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">I8--)--&gt;I11:
</span></span><span class="line"><span class="cl">F-&gt;(E)·
</span></span></code></pre></td></tr></table>
</div>
</div><p>这11个项目集组成了DFA的状态，可构造出如下的DFA：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">graph LR
</span></span><span class="line"><span class="cl">	a((I_0))--E--&gt;b((I_1))
</span></span><span class="line"><span class="cl">	b((I_1))--+--&gt;c((I_6))
</span></span><span class="line"><span class="cl">	c((I_6))--T--&gt;d((I_9))
</span></span><span class="line"><span class="cl">	a((I_0))--T--&gt;e((I_2))
</span></span><span class="line"><span class="cl">	a((I_0))--F--&gt;F((I_3))
</span></span><span class="line"><span class="cl">	a((I_0))--(--&gt;G((I_4))
</span></span><span class="line"><span class="cl">	a((I_0))--id--&gt;H((I_5))
</span></span><span class="line"><span class="cl">	e((I_2))--*--&gt;I((I_7))
</span></span><span class="line"><span class="cl">	I((I_7))--F--&gt;J((I_10))
</span></span><span class="line"><span class="cl">	G((I_4))--E--&gt;K((I_8))
</span></span><span class="line"><span class="cl">	K((I_8))--)--&gt;L((I_11))
</span></span><span class="line"><span class="cl">	c((I_6))--F--&gt;F((I_3))
</span></span><span class="line"><span class="cl">	c((I_6))--(--&gt;G((I_4))
</span></span><span class="line"><span class="cl">	c((I_6))--id--&gt;H((I_5))
</span></span><span class="line"><span class="cl">	I((I_7))--(--&gt;G((I_4))
</span></span><span class="line"><span class="cl">	I((I_7))--id--&gt;H((I_5))
</span></span><span class="line"><span class="cl">	K((I_8))--+--&gt;c((I_6))
</span></span><span class="line"><span class="cl">	G((I_4))--(--&gt;G((I_4))
</span></span><span class="line"><span class="cl">	G((I_4))--T--&gt;e((I_2))
</span></span><span class="line"><span class="cl">	G((I_4))--F--&gt;F((I_3))
</span></span><span class="line"><span class="cl">	G((I_4))--id--&gt;H((I_5))
</span></span><span class="line"><span class="cl">	d((I_9))--*--&gt;I((I_7))
</span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p>mermaid画的，有点抽象哈QAQ</p>
</blockquote>
<p>由上面的DFA可构造出SLR分析表，规则如下：</p>
<ul>
<li>如果A-&gt;α·aβ在Ii中，并且goto(Ii,a)=Ij，将action[i,a]置为sj</li>
<li>如果A-&gt;α·在Ii中，对FOLLOW(A)中所有a，置action[i,a]为rj，j是产生式A-&gt;α的初始编号</li>
<li>如果S&rsquo;-&gt;S·在Ii中，置action[i,$]为acc</li>
</ul>
<blockquote class="alert alert-important">
    <p>在这个规则中s表示移进，r表示规约，可以看出，如果一个Ii中同时存在·在末尾与在中间的情况时，会出现action[i,a]同时置为rj与sj的情况，也就是移进-归约冲突，此时比较两个左式的FOLLOW集，如果下一个输入符号属于归约的那个左式的FOLLOW集，那么使用归约，反之使用移进。比如该题的I2和I9就存在移进归约冲突，但计算FOLLOW(E)={),+,$},I2和I9的下一个符号为*，不在FOLLOW(E)中，所以均采用移进。</p></blockquote>
<p>该例的SLR分析表如下所示：</p>
<p>(1)E-&gt;E+T</p>
<p>(2)E-&gt;T</p>
<p>(3)T-&gt;T*F</p>
<p>(4)T-&gt;F</p>
<p>(5)F-&gt;(E)</p>
<p>(6)F-&gt;id</p>
<div class="table-wrapper"><table>
  <thead>
      <tr>
          <th></th>
          <th>id</th>
          <th>+</th>
          <th>*</th>
          <th>(</th>
          <th>)</th>
          <th>$</th>
          <th>E</th>
          <th>T</th>
          <th>F</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>0</td>
          <td>s5</td>
          <td></td>
          <td></td>
          <td>s4</td>
          <td></td>
          <td></td>
          <td>1</td>
          <td>2</td>
          <td>3</td>
      </tr>
      <tr>
          <td>1</td>
          <td></td>
          <td>s6</td>
          <td></td>
          <td></td>
          <td></td>
          <td>acc</td>
          <td></td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td>2</td>
          <td></td>
          <td>r2</td>
          <td>s7</td>
          <td></td>
          <td>r2</td>
          <td>r2</td>
          <td></td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td>3</td>
          <td></td>
          <td>r4</td>
          <td>r4</td>
          <td></td>
          <td>r4</td>
          <td>r4</td>
          <td></td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td>4</td>
          <td>s5</td>
          <td></td>
          <td></td>
          <td>s4</td>
          <td></td>
          <td></td>
          <td>8</td>
          <td>2</td>
          <td>3</td>
      </tr>
      <tr>
          <td>5</td>
          <td></td>
          <td>r6</td>
          <td>r6</td>
          <td></td>
          <td>r6</td>
          <td>r6</td>
          <td></td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td>6</td>
          <td>s5</td>
          <td></td>
          <td></td>
          <td>s4</td>
          <td></td>
          <td></td>
          <td></td>
          <td>9</td>
          <td>3</td>
      </tr>
      <tr>
          <td>7</td>
          <td>s5</td>
          <td></td>
          <td></td>
          <td>s4</td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td>10</td>
      </tr>
      <tr>
          <td>8</td>
          <td></td>
          <td>s6</td>
          <td></td>
          <td></td>
          <td>s11</td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td>9</td>
          <td></td>
          <td>r1</td>
          <td>s7</td>
          <td></td>
          <td>r1</td>
          <td>r1</td>
          <td></td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td>10</td>
          <td></td>
          <td>r3</td>
          <td>r3</td>
          <td></td>
          <td>r3</td>
          <td>r3</td>
          <td></td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td>11</td>
          <td></td>
          <td>r5</td>
          <td>r5</td>
          <td></td>
          <td>r5</td>
          <td>r5</td>
          <td></td>
          <td></td>
          <td></td>
      </tr>
  </tbody>
</table></div>
<h3 id="252-lr分析">2.5.2 LR分析
</h3><p>SLR文法产生移进归约冲突，但该文法不是二义的。</p>
<p>在识别活前缀DFA的状态中，增加信息，排除一些不正确的归约操作。</p>
<blockquote class="alert alert-note">
    <p>SLR只是简单地考察下一个输入符号b是否属于与归约项目A→α相关联的FOLLOW(A)，但b∈FOLLOW(A)只是归约α的一个必要条件，而非充分条件。归约条件被放宽松了。</p></blockquote>
<p>项目集：LR(0)=&gt;LR(1)</p>
<p>LR(1)项目由两个分量组成，第一分量为SLR中的项，第二分量为搜索符（向前看符号），1代表了搜索符a的长度。</p>
<p>对于[A-&gt;α·β,a]当β不为空时，a不起作用，当β为空时，如果下一个输入符号是a，将按照A-&gt;α进行归约，a的集合是FOLLOW(A)的子集。</p>
<blockquote class="alert alert-note">
    <p>LR(1)闭包计算方法与LR(0)有所不同，若有项目[A-&gt;α·Bβ,a]在闭包中，而B-&gt;γ是文法中的产生式，b是FIRST(βa)中的元素，则[B-&gt;γ，b]也属于闭包。</p></blockquote>
$$
0)S'->S\\
1)S->L=R\\
2)S->R\\
3)L->*R\\
4)L->id\\
5)R->L
$$<p>
则可以得到如下所示的LR(1)项目集规范族：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">I0:
</span></span><span class="line"><span class="cl">S&#39;-&gt;·S,$-----S&#39;的搜索符一定是$,因为S&#39;表示规约到了最后,FIRST($)=$
</span></span><span class="line"><span class="cl">S-&gt;·L=R,$---------FIRST(=R$)=&#34;=&#34;[对于L]
</span></span><span class="line"><span class="cl">S-&gt;·R,$-----------FIRST($)=$[对于R]
</span></span><span class="line"><span class="cl">L-&gt;·*R,=
</span></span><span class="line"><span class="cl">L-&gt;·id,=
</span></span><span class="line"><span class="cl">R-&gt;·L,$-----------FIRST($)=$[对于L]
</span></span><span class="line"><span class="cl">L-&gt;·*R,$
</span></span><span class="line"><span class="cl">L-&gt;·id,$
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">I0--S--&gt;I1:
</span></span><span class="line"><span class="cl">S&#39;-&gt;S·,$
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">I0--L--&gt;I2:
</span></span><span class="line"><span class="cl">S-&gt;L·=R,$
</span></span><span class="line"><span class="cl">R-&gt;L·,$
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">I0--R--&gt;I3:
</span></span><span class="line"><span class="cl">S-&gt;R·,$
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">I0--*--&gt;I4:
</span></span><span class="line"><span class="cl">L-&gt;*·R,=-----------FIRST(=)=&#34;=&#34;[对于R]
</span></span><span class="line"><span class="cl">L-&gt;*·R,$-----------FIRST($)=$[对于R]
</span></span><span class="line"><span class="cl">R-&gt;·L,=------------FIRST(=)=&#34;=&#34;[对于L]
</span></span><span class="line"><span class="cl">R-&gt;·L,$------------FIRST($)=$[对于L]
</span></span><span class="line"><span class="cl">L-&gt;·*R,=
</span></span><span class="line"><span class="cl">L-&gt;·*R,$
</span></span><span class="line"><span class="cl">L-&gt;·id,=
</span></span><span class="line"><span class="cl">L-&gt;·id,$
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">I4--id--&gt;I5:
</span></span><span class="line"><span class="cl">L-&gt;id·,=
</span></span><span class="line"><span class="cl">L-&gt;id·,$
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">I2--=--&gt;I6:
</span></span><span class="line"><span class="cl">S-&gt;L=·R,$----------FIRST($)=$[对于R]
</span></span><span class="line"><span class="cl">R-&gt;·L,$------------FIRST($)=$[对于L]
</span></span><span class="line"><span class="cl">L-&gt;·*R,$
</span></span><span class="line"><span class="cl">L-&gt;·id,$
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">I4--R--&gt;I7:
</span></span><span class="line"><span class="cl">L-&gt;*R·,=
</span></span><span class="line"><span class="cl">L-&gt;*R·,$
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">I4--L--&gt;I8:
</span></span><span class="line"><span class="cl">R-&gt;L·,=
</span></span><span class="line"><span class="cl">R-&gt;L·,$
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">I6--R--&gt;I9:
</span></span><span class="line"><span class="cl">S-&gt;L=R·,$
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">I6--L--&gt;I10:
</span></span><span class="line"><span class="cl">R-&gt;L·,$
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">I6--*--&gt;I11:
</span></span><span class="line"><span class="cl">L-&gt;*·R,$------------FIRST($)=$[对于R]
</span></span><span class="line"><span class="cl">R-&gt;·L,$-------------FIRST($)=$[对于L]
</span></span><span class="line"><span class="cl">L-&gt;·*R,$
</span></span><span class="line"><span class="cl">L-&gt;·id,$
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">I6--id--&gt;I12:
</span></span><span class="line"><span class="cl">L-&gt;id·,$
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">I11--R--&gt;I13:
</span></span><span class="line"><span class="cl">L-&gt;*R·,$
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果一个项目中两个或多个式子只是搜索符不同，可以写在一起；如果两个项目除搜索符外相同，则这两个项目集是同心的。</p>
<p>DFA如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">graph LR
</span></span><span class="line"><span class="cl">	A((I_0))--S--&gt;B((I_1))
</span></span><span class="line"><span class="cl">	A((I_0))--L--&gt;C((I_2))
</span></span><span class="line"><span class="cl">	A((I_0))--R--&gt;D((I_3))
</span></span><span class="line"><span class="cl">	A((I_0))--*--&gt;E((I_4))
</span></span><span class="line"><span class="cl">	A((I_0))--id--&gt;F((I_5))
</span></span><span class="line"><span class="cl">	C((I_2))--=--&gt;G((I_6))
</span></span><span class="line"><span class="cl">	G((I_6))--R--&gt;H((I_9))
</span></span><span class="line"><span class="cl">	G((I_6))--L--&gt;I((I_10))
</span></span><span class="line"><span class="cl">	G((I_6))--*--&gt;J((I_11))
</span></span><span class="line"><span class="cl">	G((I_6))--id--&gt;K((I_12))
</span></span><span class="line"><span class="cl">	E((I_4))--R--&gt;L((I_7))
</span></span><span class="line"><span class="cl">	E((I_4))--L--&gt;M((I_8))
</span></span><span class="line"><span class="cl">	E((I_4))--id--&gt;F((I_5))
</span></span><span class="line"><span class="cl">	E((I_4))--*--&gt;E((I_4))
</span></span><span class="line"><span class="cl">	J((I_11))--R--&gt;O((I_13))
</span></span><span class="line"><span class="cl">	J((I_11))--id--&gt;K((I_12))
</span></span><span class="line"><span class="cl">	J((I_11))--L--&gt;I((I_10))
</span></span><span class="line"><span class="cl">	J((I_11))--*--&gt;J((I_11))
</span></span></code></pre></td></tr></table>
</div>
</div><p>则我们可以得到如下所示的LR(1)分析表：</p>
<div class="table-wrapper"><table>
  <thead>
      <tr>
          <th></th>
          <th>*</th>
          <th>id</th>
          <th>=</th>
          <th>$</th>
          <th>S</th>
          <th>L</th>
          <th>R</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>0</td>
          <td>s4</td>
          <td>s5</td>
          <td></td>
          <td></td>
          <td>1</td>
          <td>2</td>
          <td>3</td>
      </tr>
      <tr>
          <td>1</td>
          <td></td>
          <td></td>
          <td></td>
          <td>acc</td>
          <td></td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td>2</td>
          <td></td>
          <td></td>
          <td>s6</td>
          <td>r5</td>
          <td></td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td>3</td>
          <td></td>
          <td></td>
          <td></td>
          <td>r2</td>
          <td></td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td>4</td>
          <td>s4</td>
          <td>s5</td>
          <td></td>
          <td></td>
          <td></td>
          <td>8</td>
          <td>7</td>
      </tr>
      <tr>
          <td>5</td>
          <td></td>
          <td></td>
          <td>r4</td>
          <td>r4</td>
          <td></td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td>6</td>
          <td>s11</td>
          <td>s12</td>
          <td></td>
          <td></td>
          <td></td>
          <td>10</td>
          <td>9</td>
      </tr>
      <tr>
          <td>7</td>
          <td></td>
          <td></td>
          <td>r3</td>
          <td>r3</td>
          <td></td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td>8</td>
          <td></td>
          <td></td>
          <td>r5</td>
          <td>r5</td>
          <td></td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td>9</td>
          <td></td>
          <td></td>
          <td></td>
          <td>r1</td>
          <td></td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td>10</td>
          <td></td>
          <td></td>
          <td></td>
          <td>r5</td>
          <td></td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td>11</td>
          <td>s11</td>
          <td>s12</td>
          <td></td>
          <td></td>
          <td></td>
          <td>10</td>
          <td>13</td>
      </tr>
      <tr>
          <td>12</td>
          <td></td>
          <td></td>
          <td></td>
          <td>r4</td>
          <td></td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td>13</td>
          <td></td>
          <td></td>
          <td></td>
          <td>r3</td>
          <td></td>
          <td></td>
          <td></td>
      </tr>
  </tbody>
</table></div>
<blockquote>
<p>每一个SLR(1)文法都是LR(1)的。</p>
</blockquote>
<h1 id="3中间代码">3.中间代码
</h1><h2 id="31-中间代码分析">3.1 中间代码分析
</h2><p>编译器前端与后端分离，这样为新机器构建编译器只用设计从中间代码到目标机器代码的编译器即可，并且中间代码优化与源语言和目标机器均无关。</p>
<p>常见的中间代码类型：</p>
<ul>
<li>后缀表示</li>
<li>语法树或DAG图</li>
<li>三地址码（TAC)</li>
<li>静态单赋值形式（SSA）</li>
</ul>
<p>后缀表示不需要括号，便于计算机处理表达式。</p>
<p>语法树是一种图形化的中间表示，DAG是有向无环图：</p>
<p><img src="/imgs/001-004.png"
	
	
	
	loading="lazy"
	
	
></p>
<p>三地址代码：x= y op z【最多一个算符，最多三个计算分量，每一个分量代表一个地址】</p>
<p>三地址代码是语法树或DAG的一种线性表示。</p>
<p>常用的三地址语句：</p>
<ul>
<li>运算、赋值：x=y op z,	x = op y,	x = y</li>
<li>无条件转移：goto L</li>
<li>条件转移：if x goto L,if False x goto L,if x relop y goto L</li>
<li>过程调用：param x1,param x2,call p ,n(前面设置参数,p为子过程，n为参数)</li>
<li>过程返回：return y</li>
<li>索引赋值：x=y[i],x[i]=y</li>
<li>地址和指针：x=&amp;y,x=*y,*x=y</li>
</ul>
<p>静态单赋值形式：和三地址代码差不多，但所有赋值指令都是对不同名字的变量的赋值，同一个变量在不同控制流路径上都被定值。</p>
<p>基本块：首指令：指令序列的第一条三地址指令；任意转移指令的目标指令；紧跟一个转移指令的指令。由首指令(leader)可以划分出基本块(basicblock)。</p>
<p>流图的节点是一些基本块，从基本块B到基本块C之间有一条边，当且仅当C的第一个指令可能紧跟在B的最后一条指令之后执行，称B是C的前驱(predecessor)，C是B的后继(successor)。</p>
<p>流图中的一个结点集合L是一个循环，需满足：该集合有唯一的入口结点；集合结点都有一个到达入口结点的非空路径，且该路径全部在L中。</p>
<h2 id="32-语法制导翻译">3.2 语法制导翻译
</h2><p>编译程序的目标：将源程序翻译成为语义等价的目标程序，源程序与目标程序具有不同的语法结构，表达的结果却是相同的。</p>
<p>语法制导翻译：使用上下文无关文法(CFG)来引导对语言的翻译，是一种面向文法的翻译技术。通过给语法树上各个符号赋予一定的含义，并且将各个符号进行有结构的连接，可以形成语言的具体语句的含义。这给予我们以启示：可以通过扩充文法， 在文法符号上附着某些语义信息，并在这些语义信息间建立相互计算关系，从而在语法分析的同时进行语义分析。 由于这种分析是在语法分析的控制下进行的，故称为语法制导翻译。</p>
<p>语法制导定义（SSD）：</p>
<p>基础的上下文无关文法，每个文法符号有一组属性，每个文法产生式A-&gt;α有一组形式为b=f(c1,c2,&hellip;,ck)的语义规则，其中f是函数，b和c1,c2,&hellip;,ck是该产生式文法符号的属性。</p>
<p>两种属性：</p>
<ul>
<li>综合属性：用于自下而上传递信息；在语法树中，一个结点的综合属性由其子 结点的属性值确定，因此，通常使用自底向上的方法在每一个结点处使用语义规则计算综合属性的值。仅仅使用综合属性的属性文法称S-属性文法。</li>
<li>继承属性：用于自上而下传递信息；在语法树中，一个结点的继承属性由此结 点的父结点和/或兄弟结点的某些属性确定。</li>
</ul>
<h3 id="321-s属性定义">3.2.1 S属性定义
</h3><p>仅仅使用综合属性的语法制导定义称为S属性的SDD,或S-属性定义，S-SDD</p>
<blockquote>
<p>如果一个SDD是S属性的，可以按照语法分析树节点的任何自底向上顺序来计算它的各个属性值;S-属性定义可在自底向上的语法分析过程中实现，如LR分析器。</p>
</blockquote>
$$
S->DSD|2\\
D->0|1
$$<p>
solution:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">S&#39;-&gt;S				print(S.val)
</span></span><span class="line"><span class="cl">S-&gt;D_1S_1D_2		S.val = (D_1.val == D_2.val) and S_1.val
</span></span><span class="line"><span class="cl">S-&gt;2				S.val = true
</span></span><span class="line"><span class="cl">D-&gt;0				D.val = 0
</span></span><span class="line"><span class="cl">D-&gt;1				D.val = 1
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="322-l属性定义">3.2.2 L属性定义
</h3><p>在一个产生式所关联的各属性之间，依赖图的边可以从左到右，但不能从右到左，可以在LR分析器或LL分析器中实现，更加一般化。</p>
<blockquote class="alert alert-note">
    <p>依赖图(dependency graph)是一个描述了分析树中结点属性间依赖关系的有向图，其中属性值为点，属性的依赖关系为边（如果X.a的值依赖于Y.b的值，则依赖图中有从Y.b的结点指向X.a的结点的有向边。</p></blockquote>
<p>对于任意一个产生式A-&gt;X1X2&hellip;Xn，其右部符号Xi的继承属性仅依赖于下列属性：</p>
<ul>
<li>A的继承属性</li>
<li>产生式Xi左边符号X1X2&hellip;Xi-1的属性</li>
<li>Xi本身的属性，但Xi全部属性不能在依赖图中形成环路</li>
</ul>
<blockquote class="alert alert-note">
    <p>不能依赖A的综合属性的原因：由于A的综合属性可能依赖Xi的属性，包括Xi的综合属性和继承属性，因此可能形成环路。</p></blockquote>
<p>一个例子：</p>
<div class="table-wrapper"><table>
  <thead>
      <tr>
          <th>产生式</th>
          <th>语义规则</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>D-&gt;TL</td>
          <td>L.in = T.type</td>
      </tr>
      <tr>
          <td>T-&gt;int</td>
          <td>T.type = integer</td>
      </tr>
      <tr>
          <td>T-&gt;real</td>
          <td>T.type = real</td>
      </tr>
      <tr>
          <td>L-&gt;L1,id</td>
          <td>L1.in = L.in;addType(id.entry,L.in)</td>
      </tr>
      <tr>
          <td>L-&gt;id</td>
          <td>addType(id.entry,L.in)</td>
      </tr>
  </tbody>
</table></div>
<p>在上面的表中，L.in是L的继承属性，type是T的综合属性，addType是把类型加到符号表中的标识符条目里（副作用）</p>
<p>一个没有副作用的SDD称为属性文法，属性文法增加了语义规则描述的复杂度。</p>
<p>受控的副作用：不会对属性求值产生约束，即可以按照任何拓扑顺序求值，不会影响最终结果。</p>
<h3 id="323-抽象语法树的构造">3.2.3 抽象语法树的构造
</h3><p>抽象语法树(AST)，简称语法树，是分析树的浓缩表示：算符和关键字作为内部节点；语法制导翻译可基于分析树，也可基于语法树。</p>
<p><img src="/imgs/001-005.png"
	
	
	
	loading="lazy"
	
	
></p>
<p>数据结构：</p>
<ul>
<li>对基本运算对象结点：
<ul>
<li>一个域存放运算对象类别</li>
<li>另一个域存放其值（也可用其他域保存或其它属性或指向该属性值的指针）</li>
</ul>
</li>
<li>对算符结点：
<ul>
<li>一个域存放算符并作为该结点的标记</li>
<li>其余两个域存放指向运算对象的指针</li>
</ul>
</li>
</ul>
<p>函数：</p>
<ul>
<li>mknode(op,left,right)：建立运算符号结点。</li>
<li>mkleaf(id,entry)：建立标识符结点。</li>
<li>mkleaf(num,val)：建立数结点。</li>
</ul>
<h4 id="3231-s属性ast">3.2.3.1 S属性AST
</h4><p>以算数表达式为例，其中nptr综合属性表示文法符号对应的抽象语法树结点。</p>
<div class="table-wrapper"><table>
  <thead>
      <tr>
          <th>产生式</th>
          <th>语义规则</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>E-&gt;E1+T</td>
          <td>E.nptr = mkNode(&rsquo;+&rsquo;,E1.nptr,T.nptr)</td>
      </tr>
      <tr>
          <td>E-&gt;T</td>
          <td>E.nptr = T.npt</td>
      </tr>
      <tr>
          <td>T-&gt;T1*F</td>
          <td>E.nptr = mkNode(&rsquo;*&rsquo;,T1.nptr,F.nptr)</td>
      </tr>
      <tr>
          <td>T-&gt;F</td>
          <td>T.nptr = F.nptr</td>
      </tr>
      <tr>
          <td>F-&gt;(E)</td>
          <td>F.nptr = E.nptr</td>
      </tr>
      <tr>
          <td>F-&gt;id</td>
          <td>F.nptr = mkLeaf(id,id.entry)</td>
      </tr>
      <tr>
          <td>F-&gt;num</td>
          <td>F.nptr = mkLeaf(num,num.val)</td>
      </tr>
  </tbody>
</table></div>
<h4 id="3232-l属性ast">3.2.3.2 L属性AST
</h4><p>首先消除左递归，将原产生式改为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">E-&gt;ER
</span></span><span class="line"><span class="cl">R-&gt;+TR1
</span></span><span class="line"><span class="cl">R-&gt;ε
</span></span><span class="line"><span class="cl">T-&gt;FW
</span></span><span class="line"><span class="cl">W-&gt;*FW1
</span></span><span class="line"><span class="cl">W-&gt;ε
</span></span><span class="line"><span class="cl">F-&gt;(E)
</span></span><span class="line"><span class="cl">F-&gt;id
</span></span><span class="line"><span class="cl">F-&gt;num
</span></span></code></pre></td></tr></table>
</div>
</div><p>部分如下：</p>
<div class="table-wrapper"><table>
  <thead>
      <tr>
          <th>产生式</th>
          <th>语义规则</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>T-&gt;FW</td>
          <td>W.i = F.nptr;T.nptr = W.s</td>
      </tr>
      <tr>
          <td>W-&gt;*FW1</td>
          <td>W1.i=mkNode(&rsquo;*&rsquo;,W.i,F.nptr);W.s=W1.s</td>
      </tr>
      <tr>
          <td>W-&gt;ε</td>
          <td>W.s = W.i</td>
      </tr>
      <tr>
          <td>F-&gt;id</td>
          <td>F.nptr = mkLeaf(id,id.entry)</td>
      </tr>
      <tr>
          <td>F-&gt;num</td>
          <td>F.nptr = mkLeaf(num,num.val)</td>
      </tr>
  </tbody>
</table></div>
<hr>
<p>S-SDD与L-SDD的AST都是一样的，但分析树却是不同的，S-SDD的分析树与AST比较接近，L-SDD的分析树与AST结构不同。</p>
<h3 id="324-语法制导翻译方案">3.2.4 语法制导翻译方案
</h3><p>语法制导翻译方案(SDT)是在产生式右部中嵌入了程序片段(称为语义动作)的CFG</p>
<p>SDT可以看作是SDD的具体实施方案。</p>
<p>将每个语义动作都放在产生式的最后并用大括号括起来就将S-SDD转换为了SDT</p>
<h4 id="3241-s属性定义的sdt两种实现方式">3.2.4.1 S属性定义的SDT两种实现方式
</h4><h5 id="32411-先建树后计算">3.2.4.1.1 先建树，后计算
</h5><p>建立语法分析树，将语义动作看作是虚拟结点，从左到右，深度优先遍历分析树，在访问虚拟结点时执行相应动作。如下图所示：</p>
<p><img src="/imgs/001-006.png"
	
	
	
	loading="lazy"
	
	
></p>
<h5 id="32412-边分析边计算">3.2.4.1.2 边分析，边计算
</h5><p>综合属性通过自底向上的LR来计算，当归约发生时执行相应语义动作。</p>
<p>可以通过扩展的LR语法分析栈来实现，每一个栈元素包含状态，文法符号和综合属性这三个域。</p>
<p><img src="/imgs/001-007.png"
	
	
	
	loading="lazy"
	
	
></p>
<p>在上图中，L-&gt;En的代码段：栈中先存入E，后存入n，栈顶指针top指向n，故top-1指向E，打印其在栈的对应值的域即可；E-&gt;E1+T的代码段：栈中先后存入E1,+,T，栈顶指针top指向T，故top-2指向E1，直接弹出三个元素，下一个要存的E可以放在top-2的位置上；其余的类似，不作过多解释。</p>
<h4 id="3242-l属性定义的sdt两种实现方式">3.2.4.2 L属性定义的SDT两种实现方式
</h4><blockquote class="alert alert-important">
    <p>S属性定义属于L属性定义。</p></blockquote>
<p>消除左递归的算术表达式语法制导定义是L-SDD，后缀SDT在这里并不适用。</p>
<p>将L-SDD转换为SDT的规则：</p>
<ul>
<li>将计算一个产生式左部符号的<u>综合属性</u>的动作放置在这个产生式右部的<u>最右端</u></li>
<li>将计算某个非终结符号A的继承属性的动作插入到产生式右部中紧靠在A的本次出现之前的位置上
<ul>
<li>多个继承属性要考虑次序，防止形成环</li>
</ul>
</li>
</ul>
<p>以3.2.2中给出的L-SDD的例子来构造L-SDT：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">D-&gt;T {L.in = T.type} L
</span></span><span class="line"><span class="cl">T-&gt;int {T.type = integer}
</span></span><span class="line"><span class="cl">T-&gt;real {T.type = real}
</span></span><span class="line"><span class="cl">L-&gt;{L1.in = L.in} L1,id {addType(id.entry,L.in)}
</span></span><span class="line"><span class="cl">L-&gt;id {addType(id.entry,L.in)}
</span></span></code></pre></td></tr></table>
</div>
</div><p>以前两个为例，D-&gt;TL，由于语义规则<code>L.in = T.type</code>是计算非终结符号L的继承属性，所以放在L之前紧靠着L；T-&gt;int，由于语义规则<code>T.type = integer</code>是计算左部符号T的综合属性type的，所以放在最右端。</p>
<h5 id="32421-与递归下降分析结合">3.2.4.2.1 与递归下降分析结合
</h5><p>递归下降翻译器的设计：</p>
<ul>
<li>为每个非终结符A构造一个函数
<ul>
<li>A的每个继承属性对应该函数的一个形参</li>
<li>函数的返回值是A的综合属性值</li>
</ul>
</li>
<li>在函数体中：
<ul>
<li>首先选择适当的A的产生式</li>
<li>用局部变量保存产生式中文法符号的属性</li>
<li>对产生式体中的终结符号，读入符号并获取其综合属性（由词法分析得到）</li>
<li>对产生式体中的非终结符，调用相应函数，记录返回值</li>
</ul>
</li>
</ul>
<p>产生式R-&gt;+TR|ε的递归下降分析过程：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">void R(){
</span></span><span class="line"><span class="cl">	if (lookahead == &#39;+&#39;) {
</span></span><span class="line"><span class="cl">		match(&#39;+&#39;);
</span></span><span class="line"><span class="cl">		T();
</span></span><span class="line"><span class="cl">		R();
</span></span><span class="line"><span class="cl">	} else {}
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><h5 id="32422-与lr分析结合">3.2.4.2.2 与LR分析结合
</h5><p>将产生式中嵌入的动作删除，挪到产生式最右端，具体来说，对于产生式A-&gt;α{a}β，a是语义动作，引入新的非终结符M，代替{a}，形成A-&gt;αMβ，同时引入新的产生式M-&gt;ε，修改a得到a&rsquo;，将a需要的A或者α中的属性作为M的继承属性进行复制，按照a中的方法计算各属性，将这些属性作为M的综合属性保存起来，最后将{a&rsquo;}与M-&gt;ε关联起来。</p>
<p>eg:原：A-&gt;{B.i=f(A.i)}BC，修改后为：A-&gt;MBC,M-&gt;ε{M.i=A.i;M.s=f(M.i)}</p>
<h2 id="33-中间代码生成">3.3 中间代码生成
</h2><h3 id="331-布尔表达式的控制流翻译">3.3.1 布尔表达式的控制流翻译
</h3><p>布尔表达式有两个基本目的：计算逻辑值，在控制流语句中用作条件表达式。</p>
<p>布尔运算符：or,and,not</p>
<p>关系运算符relop:&lt;,&lt;=,=,≠,&gt;,&gt;=</p>
<p>布尔常量：true,false</p>
<p>用控制流来实现计算：布尔运算符and,or,not不出现在翻译后的代码中，用程序中的位置来表示值。</p>
<p>eg:翻译：<code>if (x&lt;3 or x&gt;5 and x!=y) x=10;</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">		if x&lt;3 goto L2
</span></span><span class="line"><span class="cl">		goto L3
</span></span><span class="line"><span class="cl">L3:		if x&gt;5 goto L4
</span></span><span class="line"><span class="cl">		goto L1
</span></span><span class="line"><span class="cl">L4:		if x!=y goto L2
</span></span><span class="line"><span class="cl">		goto L1
</span></span><span class="line"><span class="cl">L2:		x = 10
</span></span><span class="line"><span class="cl">L1:
</span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p>注意布尔运算符的优先级，not具有最高优先级，and次之，or最低</p>
</blockquote>
<p>布尔表达式控制流翻译SDD：</p>
<ul>
<li>
<p>B-&gt;B1 or B2</p>
<p><img src="/imgs/001-008.png"
	
	
	
	loading="lazy"
	
	
></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">语义规则：
</span></span><span class="line"><span class="cl">B1.true = B.true;
</span></span><span class="line"><span class="cl">B1.false = newLabel();
</span></span><span class="line"><span class="cl">B2.true = B.true;
</span></span><span class="line"><span class="cl">B2.false = B.false;
</span></span><span class="line"><span class="cl">B.code = B1.code || gen(B1.false,&#39;:&#39;) || B2.code
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>B-&gt;B1 and B2</p>
<p><img src="/imgs/001-009.png"
	
	
	
	loading="lazy"
	
	
></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">语义规则：
</span></span><span class="line"><span class="cl">B1.true = newLabel();
</span></span><span class="line"><span class="cl">B1.false = B.false;
</span></span><span class="line"><span class="cl">B2.true = B.true;
</span></span><span class="line"><span class="cl">B2.false = B.false;
</span></span><span class="line"><span class="cl">B.code = B1.code || gen(B1.true,&#39;:&#39;) || B2.code
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>B -&gt;E1 relop E2</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">语义规则：
</span></span><span class="line"><span class="cl">B.code = E1.code || E2.code || gen(&#39;if&#39;,E1.place,relop.op,E2.place,&#39;goto&#39;,B.true) || gen(&#39;goto&#39;,B.false)
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>B-&gt;(B1)</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">语义规则：
</span></span><span class="line"><span class="cl">B1.true = B.true;
</span></span><span class="line"><span class="cl">B1.false = B.false;
</span></span><span class="line"><span class="cl">B.code = B1.code
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>B-&gt;not B1</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">语义规则：
</span></span><span class="line"><span class="cl">B1.true = B.false;
</span></span><span class="line"><span class="cl">B1.false = B.true;
</span></span><span class="line"><span class="cl">B.code = B1.code
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>B-&gt;true/false</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">语义规则：
</span></span><span class="line"><span class="cl">B.code = gen(&#39;goto&#39;,B.true/false)
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<p>B.true和B.false都是继承属性，需要两趟分析来计算，第一趟生成语法树，第二趟dfs计算属性值。</p>
<h3 id="332-基于符号回填的布尔表达式翻译">3.3.2 基于符号回填的布尔表达式翻译
</h3><blockquote>
<p>布尔表达式短路计算翻译中，产生了转移目标不明确的条件或无条件代码。</p>
<p>解决方案：当生成跳转指令时，暂时不指定目标地址，当有关目标地址确定后，再填回到翻译代码中。</p>
<p>具体实现：将有相同转移目标的转移代码的编号串起来形成链，可以方便回填目标地址。该list变成了综合属性，可以与LR结合。</p>
</blockquote>
<p>此时我们有两个综合属性：</p>
<ul>
<li>B.truelist：代码中所有转向真出口的代码指令链；</li>
<li>B.falselist：所有转向假出口的代码指令链。</li>
</ul>
<p>在生成B的代码时，跳转指令goto是不完整的，目标标号尚未填写，用truelist和falselist来管理。</p>
<p>相关函数：</p>
<ul>
<li>makelist(i)，创建含标号为i的指令的链表</li>
<li>backpatch(instruction-list,target-label)，将目标地址填回list中每条指令</li>
<li>merge(instruction-list1,instruction-list2)，合并两个链，当两个链中每条指令都会跳转到同一条指令时执行此操作</li>
</ul>
<p>基于回填的布尔表达式翻译SDD(下面用的是LR分析)：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">B</span><span class="o">-&gt;</span><span class="n">not</span> <span class="n">B1</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">B</span><span class="p">.</span><span class="n">truelist</span> <span class="o">=</span> <span class="n">B1</span><span class="p">.</span><span class="n">falselist</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">B</span><span class="p">.</span><span class="n">falselist</span> <span class="o">=</span> <span class="n">B1</span><span class="p">.</span><span class="n">truelist</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">			
</span></span><span class="line"><span class="cl"><span class="n">B</span><span class="o">-&gt;</span><span class="p">(</span><span class="n">B1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">B</span><span class="p">.</span><span class="n">truelist</span> <span class="o">=</span> <span class="n">B1</span><span class="p">.</span><span class="n">truelist</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">B</span><span class="p">.</span><span class="n">falselist</span> <span class="o">=</span> <span class="n">B1</span><span class="p">.</span><span class="n">falselist</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">		 
</span></span><span class="line"><span class="cl"><span class="n">B</span><span class="o">-&gt;</span><span class="nb">true</span><span class="o">/</span><span class="nb">false</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">B</span><span class="p">.</span><span class="n">truelist</span><span class="o">/</span><span class="n">falselist</span> <span class="o">=</span> <span class="nf">makelist</span><span class="p">(</span><span class="n">nextinstr</span><span class="p">);</span> <span class="c1">//这里因为要回填的是下面gen的goto语句，所以是nextinstr
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">gen</span><span class="p">(</span><span class="err">&#39;</span><span class="k">goto</span><span class="err">&#39;</span><span class="p">,</span><span class="o">-</span><span class="p">);</span> <span class="c1">//-表示需要回填
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">B</span><span class="o">-&gt;</span><span class="n">E1</span> <span class="n">relop</span> <span class="n">E2</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">B</span><span class="p">.</span><span class="n">truelist</span> <span class="o">=</span> <span class="nf">makelist</span><span class="p">(</span><span class="n">nextinstr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">B</span><span class="p">.</span><span class="n">falselist</span> <span class="o">=</span> <span class="nf">makelist</span><span class="p">(</span><span class="n">nextinstr</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">gen</span><span class="p">(</span><span class="err">&#39;</span><span class="k">if</span><span class="err">&#39;</span><span class="p">,</span><span class="n">E1</span><span class="p">.</span><span class="n">place</span><span class="p">,</span><span class="n">relop</span><span class="p">.</span><span class="n">op</span><span class="p">,</span><span class="n">E2</span><span class="p">.</span><span class="n">place</span><span class="p">,</span><span class="err">&#39;</span><span class="k">goto</span><span class="sc">&#39;,&#39;</span><span class="o">-</span><span class="err">&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">gen</span><span class="p">(</span><span class="err">&#39;</span><span class="k">goto</span><span class="err">&#39;</span><span class="p">,</span><span class="o">-</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">B</span><span class="o">-&gt;</span><span class="n">B1</span> <span class="n">or</span> <span class="n">M</span> <span class="n">B2</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">backpatch</span><span class="p">(</span><span class="n">B1</span><span class="p">.</span><span class="n">falselist</span><span class="p">,</span><span class="n">M</span><span class="p">.</span><span class="n">instr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">B</span><span class="p">.</span><span class="n">truelist</span> <span class="o">=</span> <span class="nf">merge</span><span class="p">(</span><span class="n">B1</span><span class="p">.</span><span class="n">truelist</span><span class="p">,</span><span class="n">B2</span><span class="p">.</span><span class="n">truelist</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">B</span><span class="p">.</span><span class="n">falselist</span> <span class="o">=</span> <span class="n">B2</span><span class="p">.</span><span class="n">falselist</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//这里的M是为了保存B2开始的第一条指令：M-&gt;ε {M.instr = nextinstr}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">B</span><span class="o">-&gt;</span><span class="n">B1</span> <span class="n">and</span> <span class="n">M</span> <span class="n">B2</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">backpatch</span><span class="p">(</span><span class="n">B1</span><span class="p">.</span><span class="n">truelist</span><span class="p">,</span><span class="n">M</span><span class="p">.</span><span class="n">instr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">B</span><span class="p">.</span><span class="n">falselist</span> <span class="o">=</span> <span class="nf">merge</span><span class="p">(</span><span class="n">B1</span><span class="p">.</span><span class="n">falselist</span><span class="p">,</span><span class="n">B2</span><span class="p">.</span><span class="n">falselist</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">B</span><span class="p">.</span><span class="n">truelist</span> <span class="o">=</span> <span class="n">B2</span><span class="p">.</span><span class="n">truelist</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="333-基于符号回填的其它语句翻译">3.3.3 基于符号回填的其它语句翻译
</h3><p>对一般语句而言，有一个综合属性：S.nextlist，表示代码中所有跳转到紧跟S的代码之后的指令。</p>
<p>用S表示一条语句，用L表示语句列表，则有如下的文法和LR分析翻译方案：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">S</span><span class="o">-&gt;</span><span class="k">if</span> <span class="n">B</span> <span class="n">then</span> <span class="n">M</span> <span class="n">S1</span> <span class="p">{</span> <span class="c1">//这里的B是上面的布尔表达式
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">backpatch</span><span class="p">(</span><span class="n">B</span><span class="p">.</span><span class="n">truelist</span><span class="p">,</span><span class="n">M</span><span class="p">.</span><span class="n">instr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">S</span><span class="p">.</span><span class="n">nextlist</span> <span class="o">=</span> <span class="nf">merge</span><span class="p">(</span><span class="n">B</span><span class="p">.</span><span class="n">falselist</span><span class="p">,</span><span class="n">S1</span><span class="p">.</span><span class="n">nextlist</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="n">M</span><span class="o">-&gt;</span><span class="err">ε</span> <span class="p">{</span><span class="n">M</span><span class="p">.</span><span class="n">instr</span> <span class="o">=</span> <span class="n">nextinstr</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">S</span><span class="o">-&gt;</span><span class="k">if</span> <span class="n">B</span> <span class="n">then</span> <span class="n">M1</span> <span class="n">S1</span> <span class="n">N</span> <span class="k">else</span> <span class="n">M2</span> <span class="n">S2</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">backpatch</span><span class="p">(</span><span class="n">B</span><span class="p">.</span><span class="n">truelist</span><span class="p">,</span><span class="n">M1</span><span class="p">.</span><span class="n">instr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">backpatch</span><span class="p">(</span><span class="n">B</span><span class="p">.</span><span class="n">falselist</span><span class="p">,</span><span class="n">M2</span><span class="p">.</span><span class="n">instr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">temp</span> <span class="o">=</span> <span class="nf">merge</span><span class="p">(</span><span class="n">S1</span><span class="p">.</span><span class="n">nextlist</span><span class="p">,</span><span class="n">N</span><span class="p">.</span><span class="n">nextlist</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">S</span><span class="p">.</span><span class="n">nextlist</span> <span class="o">=</span> <span class="nf">merge</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span><span class="n">S2</span><span class="p">.</span><span class="n">nextlist</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="n">N</span><span class="o">-&gt;</span><span class="err">ε</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">N</span><span class="p">.</span><span class="n">nextlist</span> <span class="o">=</span> <span class="nf">makelist</span><span class="p">(</span><span class="n">nextinstr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">gen</span><span class="p">(</span><span class="err">&#39;</span><span class="k">goto</span><span class="err">&#39;</span><span class="p">,</span><span class="o">-</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">S</span><span class="o">-&gt;</span><span class="k">while</span> <span class="n">M1</span> <span class="n">B</span> <span class="k">do</span> <span class="n">M2</span> <span class="n">S1</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">backpatch</span><span class="p">(</span><span class="n">B</span><span class="p">.</span><span class="n">truelist</span><span class="p">,</span><span class="n">M2</span><span class="p">.</span><span class="n">instr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">backpatch</span><span class="p">(</span><span class="n">S1</span><span class="p">.</span><span class="n">nextlist</span><span class="p">,</span><span class="n">M1</span><span class="p">.</span><span class="n">instr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">S</span><span class="p">.</span><span class="n">nextlist</span> <span class="o">=</span> <span class="n">B</span><span class="p">.</span><span class="n">falselist</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">gen</span><span class="p">(</span><span class="err">&#39;</span><span class="k">goto</span><span class="err">&#39;</span><span class="p">,</span><span class="n">M1</span><span class="p">.</span><span class="n">instr</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">S</span><span class="o">-&gt;</span><span class="n">A</span> <span class="p">{</span><span class="n">S</span><span class="p">.</span><span class="n">nextlist</span> <span class="o">=</span> <span class="p">{};}</span> <span class="c1">//赋值语句
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="n">S</span><span class="o">-&gt;</span><span class="p">{</span><span class="n">L</span><span class="p">}</span> <span class="p">{</span><span class="n">S</span><span class="p">.</span><span class="n">nextlist</span> <span class="o">=</span> <span class="n">L</span><span class="p">.</span><span class="n">nextlist</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">L</span><span class="o">-&gt;</span><span class="n">S</span> <span class="p">{</span><span class="n">L</span><span class="p">.</span><span class="n">nextlist</span> <span class="o">=</span> <span class="n">S</span><span class="p">.</span><span class="n">nextlist</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">L</span><span class="o">-&gt;</span><span class="n">L1</span><span class="p">;</span><span class="n">M</span> <span class="n">S</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">backpatch</span><span class="p">(</span><span class="n">L1</span><span class="p">.</span><span class="n">nextlist</span><span class="p">,</span><span class="n">M</span><span class="p">.</span><span class="n">instr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">L</span><span class="p">.</span><span class="n">nextlist</span> <span class="o">=</span> <span class="n">S</span><span class="p">.</span><span class="n">nextlist</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="34-类型表达式">3.4 类型表达式
</h2><p>类型表达式(type expression):基本类型是类型表达式，可为类型表达式命名，类名也是类型表达式，将类型构造算子作用于类型表达式可以构造新的类型表达式。</p>
<blockquote class="alert alert-note">
    <p>比如数组类型构造算子array和类型表达式integer，int[3]的类型表达式为array(3,integer)，在此基础上再作用一遍为array(2,array(3,integer))，表示int[2][3]仍为类型表达式。</p></blockquote>
<p>常见构造算子：</p>
<ul>
<li>数组类型构造算子array</li>
<li>指针类型构造算子pointer</li>
<li>笛卡尔乘积类型算子×</li>
<li>函数类型构造算子-&gt;</li>
<li>记录类型构造算子record</li>
</ul>
<p>an example:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">address</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="n">lexeme</span><span class="p">[</span><span class="mi">15</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span><span class="n">row</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">row</span> <span class="n">table</span><span class="p">[</span><span class="mi">101</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="n">row</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">则</span><span class="n">row的类型表达式</span><span class="err">：</span>
</span></span><span class="line"><span class="cl">    <span class="nf">record</span><span class="p">((</span><span class="n">address</span><span class="err">×</span><span class="n">integer</span><span class="p">)</span><span class="err">×</span><span class="p">(</span><span class="n">lexeme</span><span class="err">×</span><span class="p">(</span><span class="nf">array</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span><span class="kt">char</span><span class="p">))))</span>
</span></span><span class="line"><span class="cl"><span class="n">table的类型表达式</span><span class="err">：</span>
</span></span><span class="line"><span class="cl">    <span class="nf">array</span><span class="p">(</span><span class="mi">101</span><span class="p">,</span><span class="n">row</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">p的类型表达式</span><span class="err">：</span>
</span></span><span class="line"><span class="cl">    <span class="nf">pointer</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><hr>
<p>由上述定义我们可以构造类型表达式的SDD与SDT：</p>
<p>首先为每个文法符号设置综合属性t与继承属性b：</p>
<p>t是指该符号对应的类型表达式，b表示将类型信息从左到右传递。</p>
<p>比如下面的文法的SDD：</p>
<div class="table-wrapper"><table>
  <thead>
      <tr>
          <th>产生式</th>
          <th>语义规则</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>T-&gt;BC</td>
          <td>T.t = C.t;   C.b = B.t</td>
      </tr>
      <tr>
          <td>B-&gt;int</td>
          <td>B.t = integer</td>
      </tr>
      <tr>
          <td>B-&gt;float</td>
          <td>B.t = float</td>
      </tr>
      <tr>
          <td>C-&gt;[num]C1</td>
          <td>C.t = array(num.val,C1.t);  C1.b = C.b</td>
      </tr>
      <tr>
          <td>C-&gt;ε</td>
          <td>C.t = C.b</td>
      </tr>
  </tbody>
</table></div>
<p>由上面的SDD可直接改造为SDT：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">T-&gt;B {C.b = B.t} C {T.t = C.t;}
</span></span><span class="line"><span class="cl">B-&gt;int {B.t = integer}
</span></span><span class="line"><span class="cl">B-&gt;float {B.t = float}
</span></span><span class="line"><span class="cl">C-&gt;[num] {C1.b = C.b} C1 {C.t = array(num.val,C1.t);}
</span></span><span class="line"><span class="cl">C-&gt;ε {C.t = C.b}
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果要使用LR，同样需要改造文法，参考3.2.4.2.2的改造方法，如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">T-&gt;B M C {T.t = C.t;}
</span></span><span class="line"><span class="cl">M-&gt;ε {M.t = B.t}
</span></span><span class="line"><span class="cl">B-&gt;int {B.t = integer}
</span></span><span class="line"><span class="cl">B-&gt;float {B.t = float}
</span></span><span class="line"><span class="cl">C-&gt;[num] N C1 {C.t = array(num.val,C1.t);}
</span></span><span class="line"><span class="cl">N-&gt;ε {N.t = C.b}
</span></span><span class="line"><span class="cl">C-&gt;ε {C.t = C.b}
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="35-符号表与声明语句翻译">3.5 符号表与声明语句翻译
</h2><p>符号表(symbol table)用于编译过程的分析与合成，如使用前声明检查，确定作用域，内存空间分配，类型表达式构造等等，其使用和修改伴随着编译的全过程。</p>
<p>声明语句翻译的要点：</p>
<ul>
<li>分配存储单元
<ul>
<li>名字、类型、字宽、偏移</li>
</ul>
</li>
<li>作用域的管理
<ul>
<li>过程调用</li>
</ul>
</li>
<li>记录类型的管理</li>
<li>不产生中间代码指令，但要更新符号表</li>
</ul>
<p>符号表的组织与管理：</p>
<ul>
<li>各过程有各自的符号表：哈希表</li>
<li>符号表之间有双向链
<ul>
<li>父-&gt;子：过程中包含哪些子过程定义</li>
<li>子-&gt;父：分析完子过程后继续分析父过程</li>
</ul>
</li>
<li>维护符号表栈和地址偏移量栈（保存尚未完成的过程的符号表指针和相对地址）</li>
</ul>
<h2 id="36-数组寻址翻译">3.6 数组寻址翻译
</h2>$$
i×w+(base-low×w)
$$<p>
其中，base是整个数组的基地址，也是分配给该数组的内存块的相对地址；low是下标的下界；w是每个数组元素的宽度。这样写因为low×w是常量，在编译时计算，减少了运行时计算。</p>
$$
base+((i-low_1)×n_2+(j-low_2))×w
$$$$
((i_1×n_2)+i_2)×w+(base-((low_1×n_2)+low_2)×w)
$$$$
((...((i_1×n_2+i_2)×n_3+i_3)...)×n_k+i_k)×w+base-((...((low_1×n_2+low_2)×n_3+low_3)...)×n_k+low_k)×w
$$<h1 id="4运行时管理">4.运行时管理
</h1><h2 id="41-存储组织">4.1 存储组织
</h2><p>编译器必须为源程序中出现的一些数据对象分配运行时的存储空间，包括静态存储分配与动态存储分配，对于那些在编译时刻就可以确定大小的数据对象，可以在编译时刻就为它们分配存储空间，这样的策略成为静态存储分配，如果不能在编译时刻完全确定数据对象的大小，就要采用动态存储分配的策略。即，在编译时刻仅产生各种必要的信息，而在运行时刻，再动态地分配存储空间。包括栈式存储分配与堆式存储分配，静态和动态这两个概念分别对应编译时刻和运行时刻。</p>
<p>名字的作用域：一个声明起作用的程序部分称为该声明的作用域，即使一个名字在程序中只声明一次，该名字在程序运行时也可能表示不同的数据对象。</p>
<p>环境和状态：</p>
<ul>
<li>环境把名字映射到左值，而状态把左值映射到右值（即名字到值有两步映射）</li>
<li>赋值改变状态，但不改变环境</li>
<li>过程调用改变环境</li>
<li>如果环境将名字x映射到存储单元s，则说x被绑定到s</li>
</ul>
<p>局部数据的分布：</p>
<ul>
<li>字节是可编址内存的最小单位</li>
<li>变量所需的存储空间可以根据其类型而静态确定</li>
<li>一个过程所声明的局部变量，按这些变量声明时出现的次序，在局部数据域中依次分配空间</li>
<li>局部数据的地址可以用相对于活动记录中某个位置的地址来表示</li>
<li>数据对象的存储布局还有一个<strong>对齐问题</strong></li>
</ul>
<h2 id="42-空间的栈式分配">4.2 空间的栈式分配
</h2><p>对于支持过程、函数和方法的语言，其编译器通常会用栈的形式来管理其运行时刻存储当一个过程被调用时，该过程的活动记录被压入栈中；当过程结束时，记录被弹出这种安排不仅允许活跃时段不交叠的多个过程调用共享空间；而且可以使得过程的非局部变量的相对地址总是固定的，和调用序列无关。</p>
<blockquote>
<p>活动树：用来描述程序运行期间控制进入和离开各个活动的情况的树，树中的每个结点对应于一个活动。根结点是启动程序执行的main过程的活动。</p>
</blockquote>
<blockquote>
<p>运行栈：把控制栈中的信息拓广到包括过程活动所需的所有局部信息。</p>
</blockquote>
<ul>
<li>代码序列
<ul>
<li>过程调用和过程返回都需要执行一些代码来管理活动记录栈，保存或恢复机器状态等</li>
</ul>
</li>
<li>过程调用序列
<ul>
<li>过程调用时执行的分配活动记录，把信息填入它的域中，使被调用过程可以开始执行的代码</li>
</ul>
</li>
<li>过程返回序列
<ul>
<li>被调用过程返回时执行的恢复机器状态，释放被调用过程活动记录，使调用过程能够继续执行的代码</li>
</ul>
</li>
<li>调用序列和返回序列常常都分成两部分，分处于调用过程和被调用过程的活动记录中。</li>
</ul>
<p>C语言活动记录结构：</p>
<div class="table-wrapper"><table>
  <thead>
      <tr>
          <th>临时数据</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>局部数据</td>
      </tr>
      <tr>
          <td>机器状态</td>
      </tr>
      <tr>
          <td>控制链</td>
      </tr>
      <tr>
          <td>返回值</td>
      </tr>
      <tr>
          <td>参数</td>
      </tr>
  </tbody>
</table></div>
<p>Pascal语言活动记录结构：</p>
<div class="table-wrapper"><table>
  <thead>
      <tr>
          <th>临时数据</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>局部数据</td>
      </tr>
      <tr>
          <td>机器状态</td>
      </tr>
      <tr>
          <td>访问链</td>
      </tr>
      <tr>
          <td>控制链</td>
      </tr>
      <tr>
          <td>返回值</td>
      </tr>
      <tr>
          <td>参数</td>
      </tr>
  </tbody>
</table></div>
<h2 id="43-非局部名字的访问">4.3 非局部名字的访问
</h2><ol>
<li>
<p>无过程嵌套的数据访问</p>
<ul>
<li>过程体中的非局部引用可以直接使用静态确定的地址 (非局部数据此时是全局数据)</li>
<li>局部变量在栈顶的活动记录中，可以通过 <code>base_sp</code> 指针访问</li>
<li>无须深入栈中取数据，无须访问链</li>
</ul>
</li>
<li>
<p>有过程嵌套的静态作用域</p>
<ul>
<li>一个过程的声明包含另一个过程的声明，嵌套的子过程可以使用父过程的局部变量</li>
<li>子过程代码被激活执行，要找到父过程的活动记录，需要建立访问链</li>
</ul>
</li>
<li>
<p>嵌套深度</p>
<ul>
<li>过程嵌套深度：主程序为 1，进入一个被包围的过程加 1</li>
<li>变量的嵌套深度：声明所在过程的嵌套深度为该名字的嵌套深度</li>
</ul>
</li>
<li>
<p>过程嵌套的静态作用域在活动记录中增加访问指针形成访问链</p>
<ul>
<li>用来寻找非局部名字的存储单元</li>
<li>假设p直接嵌套在q中，则p活动记录的访问链指针指向最靠近的q的活动记录</li>
</ul>
</li>
<li>
<p>两个关键问题需要解决</p>
<ul>
<li>通过访问链访问非局部引用</li>
<li>访问链的建立</li>
</ul>
</li>
<li>
<p>过程p的嵌套深度n_p，引用嵌套深度为n_a的变量 a</p>
<ul>
<li>追踪访问链n_p-n_a次</li>
<li>到达a所在的活动记录</li>
<li>访问链的追踪可以间接操作完成</li>
</ul>
</li>
<li>
<p>过程p的嵌套深度n_p，调用嵌套深度为n_x的过程 x</p>
<ul>
<li>n_p&lt;n_x，x 在 p 中，被调用过程的访问链必须hi想调用过程的活动记录的访问链</li>
<li>n_p&gt;= n_x，找到公共祖先，也就是过程x的最近的n_x-1深度的过程，沿着访问呢连追踪n_p-n_x+1次</li>
</ul>
</li>
<li>
<p>参数传递</p>
<ul>
<li>形参，存储单元 (左值)，引用调用</li>
<li>实参，存储内容 (右值)，传值调用</li>
</ul>
</li>
<li>
<p>堆管理</p>
<ul>
<li>堆用于存放生命周期不确定、或生存到明确删除为止的数据对象</li>
<li><code>new</code> 生成的对象可以生存到被 <code>delete</code> 为止</li>
<li><code>malloc</code> 申请的空间生存到被 <code>free</code> 为止</li>
</ul>
</li>
<li>
<p>分配/回收堆空间的子系统</p>
<ul>
<li>分配：为内存请求分配一段连续、适当大小的堆空间
<ul>
<li>首先从空闲的堆空间选择</li>
<li>若内存紧张，可以回收一部分内存 (C/C++ 需要手动回收，Java 可以自动回收空间)</li>
</ul>
</li>
<li>评价指标：空间效率、程序效率、管理效率</li>
</ul>
</li>
</ol>
<h1 id="5代码生成">5.代码生成
</h1><p>同一中间表示代码可以由多组指令序列来实现，但不同实现之间的效率差别是很大的，因此，生成高质量代码需要知道指令代价。</p>
<p>除了考虑指令的代价和序列长度外，我们还需要考虑运算对象和结果如何存储的问题。</p>
<p>三地址机器模型：</p>
<ul>
<li>目标机器指令集(也可以称为目标语言)包含LD、ST、运算、跳转等指令</li>
<li>内存按照字节寻址</li>
<li>假设有n个通用寄存器R0, R1, …, Rn-1</li>
<li>假设所有运算分量都是整数</li>
<li>指令之前可能有一个标号</li>
</ul>
<p>目标机器指令集：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">加载指令：LD dst,addr
</span></span><span class="line"><span class="cl">保存指令：ST x,R
</span></span><span class="line"><span class="cl">运算指令：OP dst,src1,src2
</span></span><span class="line"><span class="cl">跳转指令：BR L
</span></span><span class="line"><span class="cl">		Bcond r,L
</span></span><span class="line"><span class="cl">		
</span></span><span class="line"><span class="cl">寻址：
</span></span><span class="line"><span class="cl">变量名a
</span></span><span class="line"><span class="cl">a(r)：数组访问，a是变量，r是寄存器
</span></span><span class="line"><span class="cl">c(r)：沿指针取值，c是整数，r是寄存器
</span></span><span class="line"><span class="cl">*r：在寄存器r的内容表示的位置上存放的内存位置
</span></span><span class="line"><span class="cl">*c(r)：在寄存器r中内容加上c后表示的位置上存放的内存位置
</span></span><span class="line"><span class="cl">#c：常数
</span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p>在上述简单的目标机器上，指令代价简化为1+指令的源和目的的寻址模式的附加代价；其中，寄存器寻址模式附加代价为0，涉及内存位置或者常数的寻址方式代价为1.</p>
</blockquote>
<p>寄存器描述符：记录每个寄存器当前存放的是哪些变量的值</p>
<p>地址描述符：记录运行时每个名字的当前值存放在哪个或者哪些位置，该位置可能是寄存器、栈单元、内存地址或者是它们的某个集合，这些信息可以存放在该变量名对应的符号表条目中。</p>
<ul>
<li>对每个形如x=y op z的三地址指令I：调用寄存器选择函数getReg(I)来为x、y、z选择寄存器Rx, Ry, Rz；如果Ry中存放的不是y，则生成指令“LD Ry, y’” , y’是存放y的内存位置之一，对于Rz和z的处理与上一步骤类似，最后，生成目标指令“OP Rx, Ry, Rz ”。</li>
<li>对于一个在基本块出口处可能活跃的变量x，如果它的地址描述符表明它的值没有存放在x的内存位置上，则生成指令“ST x, R”：R是在基本块结尾处存放x值的寄存器。</li>
<li>当生成加载、保存和其他指令时，必须同时更新寄存器和地址描述符：
<ul>
<li>对于LD R, x指令：修改R的寄存器描述符，使之只包含x，修改x的地址描述符，把R作为新增位置加入到x的位置集合中，从任何不同于x的地址描述符中删除R。</li>
<li>对于OP Rx, Ry, Rz指令：修改Rx的寄存器描述符，使之只包含x，从任何不同于Rx的寄存器描述符中删除x，修改x的地址描述符，使之只包含位置Rx，从任何不同于x的地址描述符中删除Rx。</li>
<li>对于ST x, R指令：修改x的地址描述符，使之包含自己的内存位置。</li>
<li>对于x = y指令，假设总是为x和y分配同一个寄存器，如果需要生成“LD Ry, y’” ，则：修改Ry的寄存器描述符，使之只包含y，修改y的地址描述符，把Ry作为新增位置加入y的位置集合中，从任何不同于y的地址描述符中删除Ry，修改Ry的寄存器描述符，使之也包含x，修改x的地址描述符，使之只包含Ry。</li>
</ul>
</li>
</ul>
<hr>
<p>上面的规则非常长和复杂，下面给出一个例子帮助理解：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">基本块三地址代码：
</span></span><span class="line"><span class="cl">t=a-b
</span></span><span class="line"><span class="cl">u=a-c
</span></span><span class="line"><span class="cl">v=t+u
</span></span><span class="line"><span class="cl">a=d
</span></span><span class="line"><span class="cl">d=v+u
</span></span><span class="line"><span class="cl">exit
</span></span><span class="line"><span class="cl">其中，t,u,v为临时变量，a,b,c,d在出口处活跃
</span></span></code></pre></td></tr></table>
</div>
</div><p>初始寄存器描述符为空，地址描述符只有abcd的内存地址，处理第一句：<code>t=a-b</code></p>
<p>由第一条规则，为a选择寄存器R1，为b选择寄存器R2，t选择寄存器R2，可生成如下的指令：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">LD R1,a
</span></span><span class="line"><span class="cl">LD R2,b
</span></span><span class="line"><span class="cl">SUB R2,R1,R2
</span></span></code></pre></td></tr></table>
</div>
</div><p>然后考虑前两句，修改R1和R2的寄存器描述符，使其包含a和b，修改a和b的地址描述符，把R1和R2加到对应位置集合中：</p>
<div class="table-wrapper"><table>
  <thead>
      <tr>
          <th>R1</th>
          <th>R2</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>a</td>
          <td>b</td>
      </tr>
  </tbody>
</table></div>
<div class="table-wrapper"><table>
  <thead>
      <tr>
          <th>a</th>
          <th>b</th>
          <th>c</th>
          <th>d</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>a,R1</td>
          <td>b,R2</td>
          <td>c</td>
          <td>d</td>
      </tr>
  </tbody>
</table></div>
<p>对于第三句，修改R2的寄存器描述符，使其只含t，如果别的寄存器含有t就删除，这个例子中没有，不需要管，修改t的地址描述符，使其只包含R2，如果别的地址有R2就删掉，这里把b中的R2删掉：</p>
<div class="table-wrapper"><table>
  <thead>
      <tr>
          <th>R1</th>
          <th>R2</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>a</td>
          <td>t</td>
      </tr>
  </tbody>
</table></div>
<div class="table-wrapper"><table>
  <thead>
      <tr>
          <th>a</th>
          <th>b</th>
          <th>c</th>
          <th>d</th>
          <th>t</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>a,R1</td>
          <td>b</td>
          <td>c</td>
          <td>d</td>
          <td>R2</td>
      </tr>
  </tbody>
</table></div>
<p>第二句和第三句类似，这里不做分析，给出第四句之前的寄存器描述符和地址描述符：</p>
<div class="table-wrapper"><table>
  <thead>
      <tr>
          <th>R1</th>
          <th>R2</th>
          <th>R3</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>u</td>
          <td>t</td>
          <td>v</td>
      </tr>
  </tbody>
</table></div>
<div class="table-wrapper"><table>
  <thead>
      <tr>
          <th>a</th>
          <th>b</th>
          <th>c</th>
          <th>d</th>
          <th>t</th>
          <th>u</th>
          <th>v</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>a</td>
          <td>b</td>
          <td>c</td>
          <td>d</td>
          <td>R2</td>
          <td>R1</td>
          <td>R3</td>
      </tr>
  </tbody>
</table></div>
<p>此时考虑第四句<code>a=d</code>，需要为a和d分配同一个寄存器，由于它们都没寄存器，故生成LD R2,d这样的语句，需要进行如下操作：修改R2的寄存器描述符，使其只包含d，修改d的地址描述符，把R2添加进去，把其他位置的R2删去，修改a的地址描述符，使其只含R2，修改R2的寄存器描述符，添加a：</p>
<div class="table-wrapper"><table>
  <thead>
      <tr>
          <th>R1</th>
          <th>R2</th>
          <th>R3</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>u</td>
          <td>a,d</td>
          <td>v</td>
      </tr>
  </tbody>
</table></div>
<div class="table-wrapper"><table>
  <thead>
      <tr>
          <th>a</th>
          <th>b</th>
          <th>c</th>
          <th>d</th>
          <th>t</th>
          <th>u</th>
          <th>v</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>R2</td>
          <td>b</td>
          <td>c</td>
          <td>d,R2</td>
          <td></td>
          <td>R1</td>
          <td>R3</td>
      </tr>
  </tbody>
</table></div>
<p>这个例子在最后退出时，a和d的地址描述符不含内存位置，需要生成ST指令，把a和d添加到对应位置的地址描述符上。</p>
<h1 id="6机器无关代码优化">6.机器无关代码优化
</h1><p>代码优化：在不改变程序运行效果的前提下，对程序代码进行等价变换，使之能生成更加高效目标代码。</p>
<p>优化目标：运行时间更短，占用空间更小。</p>
<h2 id="61-常见的优化方式">6.1 常见的优化方式
</h2><ul>
<li>公共子表达式：若x op y已被计算过，且x和y的值没有改变，那么下一次出现就是公共子表达式。下一次计算可以删除，其值用上一次计算结果代替。删除分析：可用表达式数据流分析。</li>
<li>死代码删除：死代码是指计算的结果永远不被引用的语句，一些优化变换可能会引起死代码，如复制传播，常量合并。</li>
<li>复制传播：在复制语句x=y之后尽可能用y代替x，常用的公共子表达式删除和其他一些优化会引入一些复制语句，复制传播本身没有优化的意义，但可以给死代码删除创造机会。</li>
<li>常量合并：如果编译时刻推导出一个表达式的值是常量，就可以用该常量来代替这个表达式。常量合并也是本身没有优化的意义，可以给死代码删除创造机会。</li>
<li>循环优化：强度削弱：将程序中执行时间较长的运算替换为执行时间较短的运算，比如用增量运算替代；归纳变量删除：【归纳变量：如果存在一个常量c，使x每一次赋值总是增加c，则称x为归纳变量】一个循环中，如一组归纳变量的值的变化保持步调一致，则可只保留一个；代码移动：循环不变计算是指不管循环执行多少次都得到相同结果的表达式，代码码移动是循环优化的一种，在进入循环前就对循环不变计算进行求值。对于多重嵌套循环， loop-invariant computation是相对于某一个循环的，可能对于更加外层的循环，它就不成立了。因此，处理循环时，按照由里到外的方式，即dfs。</li>
</ul>
<h2 id="62-到达定值分析">6.2 到达定值分析
</h2><p>数据流分析：一组用来获取程序执行路径上的数据流信息的技术。</p>
<p>应用有到达定值分析，活跃变量分析，可用表达式分析，在每一种应用中，都会把每个程序点和一个数据流值关联起来。</p>
<p>流图上的点：基本块中，两个相邻的语句之间为程序的一个点，基本块有开始点和结束点。</p>
<p>数据流值代表在任一程序点能观测到的所有可能程序状态集合的一个抽象，对于一个语句s，s之前的程序点对应的数据流值用IN[s]表示，之后的用OUT[s]表示。</p>
<p>传递函数f，表示语句前后两点的数据流值受该语句的语义约束，若沿执行路径正向传播，则OUT[s]=fs(IN[s])，逆向则相反，若基本块由s1,s2,s3&hellip;组成，有：IN[si+1]=OUT[si]。</p>
<p>基本块上的数据流：IN[B]表示紧靠基本块B之前的数据流值，即IN[B]=IN[s1];OUT[B]表示紧靠基本块B之后的数据流值，即OUT[B]=OUT[sn]。</p>
<hr>
<p>到达定值分析：到达一个程序点的所有定值(gen)，定值的注销(kill)</p>
<p>定值与引用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">d:	x:=y+z //语句d是变量x的一个定值点
</span></span><span class="line"><span class="cl">u:	w:=x+v //语句u是变量x的一个引用点
</span></span></code></pre></td></tr></table>
</div>
</div><p>称变量x在d点的定值到达u点</p>
<p>用途：</p>
<ul>
<li>循环不变量检测：如果循环中有x=y+z，而y和z的所有可能定值都在循环外，则y+z就是循环不变计算。</li>
<li>常量合并：如果对变量x的某次使用只有一个定值到达，且该定值把一个常量赋给x，则可以用该常量替换x。</li>
<li>错误检测：判定变量x在p点上是否未经定值就被引用。</li>
</ul>
<p>gen和kill分别表示一个基本块生成和注销的定值。</p>
<p>genB表示B中能到达B的结束点的定值语句，killB表示整个程序中绝不会到达B结束点的定值，IN[B]表示能到达B的开始点的定值集合，OUT[B]表示能到达B的结束点的定值集合。</p>
$$
IN[B]=\cup OUT[P]\{P是B的前驱\}\\
OUT[B]=gen_B \cup (IN[B]-kill_B)\\
OUT[ENTRY]=\emptyset
$$<p>
如下面的例子：</p>
<p><img src="/imgs/001-010.png"
	
	
	
	loading="lazy"
	
	
></p>
<p>可得到如下的gen和kill集合：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">gen[B1]={d1,d2,d3}
</span></span><span class="line"><span class="cl">kill[B1]={d4,d5,d6,d7} //因为把d4,d5,d6,d7左边的定值全部改了，不会到达末尾
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">gen[B2]={d4,d5}
</span></span><span class="line"><span class="cl">kill[B2]={d1,d2,d7}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">gen[B3]={d6}
</span></span><span class="line"><span class="cl">kill[B3]={d3}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">gen[B4]={d7}
</span></span><span class="line"><span class="cl">kill[B4]={d1,d4}
</span></span></code></pre></td></tr></table>
</div>
</div><p>下面迭代计算IN和OUT：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">IN[B1]={} //前驱ENTRY的OUT为空
</span></span><span class="line"><span class="cl">OUT[B1]={d1,d2,d3}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">IN[B2]=OUT[B1]∪OUT[B4]={d1,d2,d3} //这里初始化OUT都为空，后续会迭代更新
</span></span><span class="line"><span class="cl">OUT[B2]={d3,d4,d5}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">IN[B3]={d3,d4,d5}
</span></span><span class="line"><span class="cl">OUT[B3]={d4,d5,d6}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">IN[B4]={d3,d4,d5,d6}
</span></span><span class="line"><span class="cl">OUT[B4]={d3,d5,d6,d7}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">IN[B2]={d1,d2,d3,d5,d6,d7}
</span></span><span class="line"><span class="cl">OUT[B2]={d3,d4,d5,d6}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">IN[B3]={d3,d4,d5,d6}
</span></span><span class="line"><span class="cl">OUT[B3]={d4,d5,d6}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">IN[B4]={d3,d4,d5,d6}
</span></span><span class="line"><span class="cl">OUT[B4]={d3,d5,d6,d7}
</span></span><span class="line"><span class="cl">此后不再发生变化，迭代结束，共迭代3轮（加上最后一次没有OUT出现变化的一轮）
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="63-可用表达式分析">6.3 可用表达式分析
</h2><p>若到点p的每条执行路径都计算x op y，并且计算后没有对x或y赋值，那么称x op y在点p可用。</p>
<p>e_genB:块B产生的可用表达式集合</p>
<p>e_killB:块B注销的可用表达式集合</p>
<p>IN[B]：块B入口的可用表达式集合</p>
<p>OUT[B]：块B出口的可用表达式集合</p>
$$
IN[B]=\cap OUT[P]\{P是B的前驱\}\\
OUT[B]=e\_gen_B \cup (IN[B]-e\_kill_B)\\
OUT[ENTRY]=\emptyset
$$<p>
注意这里用的是交集，求的是最大解。</p>
<p>eg:</p>
<p><img src="/imgs/001-011.png"
	
	
	
	loading="lazy"
	
	
></p>
<p>可得到如下的e_gen和e_kill集合：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">忽略了entry和exit，因为都是空集
</span></span><span class="line"><span class="cl">e_gen[B1]={3,1} //常量一定是可用表达式
</span></span><span class="line"><span class="cl">e_kill[B1]={D+D,D*D,A+G} //这里改变了D和G的值，所以右边表达式含D和G的要被kill
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">e_gen[B2]={D+D,D*D,B+C} //如果表达式左值在基本块中被修改，则不是可以表达式
</span></span><span class="line"><span class="cl">e_kill[B2]={A+G,A*A} //这里没有kill掉B+C,即使B和C的值被修改了，因为最后一个语句重新计算了B+C，这样B+C又成为了可用表达式
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">e_gen[B3]={A+G} //这里的B+c不是可用表达式因为B是左值
</span></span><span class="line"><span class="cl">e_kill[B3]={B+C} //改变了B，kill掉B+C
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">e_gen[B4]={A*A}
</span></span><span class="line"><span class="cl">e_kill[B4]={B+C}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">e_gen[B5]={B+C}
</span></span><span class="line"><span class="cl">e_kill[B5]={D*D,A+G,D+D}
</span></span></code></pre></td></tr></table>
</div>
</div><p>初始化OUT[ENTRY]为空集，其余的基本块OUT集合均为U（所有e_gen集合的并集），下面进行迭代：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">IN[B1]=OUT[ENTRY]={} 
</span></span><span class="line"><span class="cl">OUT[B1]={3,1}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">IN[B2]=OUT[B1]∩OUT[B5]={3,1}
</span></span><span class="line"><span class="cl">OUT[B2]={3,1,D+D,D*D,B+C}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">IN[B3]={3,1,D+D,D*D,B+C}
</span></span><span class="line"><span class="cl">OUT[B3]={A+G,3,1,D+D,D*D}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">IN[B4]={3,1,D+D,D*D,B+C}
</span></span><span class="line"><span class="cl">OUT[B4]={A*A,3,1,D+D,D*D}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">IN[B5]={3,1,D+D,D*D}
</span></span><span class="line"><span class="cl">OUT[B5]={3,1,B+C}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">IN[EXIT]={3,1,B+C}
</span></span><span class="line"><span class="cl">OUT[EXIT]={3,1,B+C}
</span></span><span class="line"><span class="cl">第一次迭代结束，第二次迭代结果不变这里不做展示，然后就退出了，迭代结束。
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="64-活跃变量分析">6.4 活跃变量分析
</h2><p>对于变量x和程序点p，如果x的值在p点开始的某条执行路径上被引用，则说x在p点活跃，否则称x在p点已经死亡。</p>
<p>如果所有寄存器都被占用，且还需要申请一个寄存器，则应该考虑使用已经存放死亡值的寄存器，如果一个值在基本块结尾处是死的，就不必在结尾处保存这个值了。</p>
<p>IN[B]：块B开始点的活跃变量集合</p>
<p>OUT[B]：块B结束点的活跃变量集合</p>
<p>useB：块B中有引用，且在引用前在B中没有被定值的变量集</p>
<p>defB：块B中有定值，且该定值前在B中没有被引用的变量集</p>
$$
IN[EXIT]=\emptyset\\
OUT[B]=\cup IN[S]\{S是B的后继\}\\
IN[B]=use_B \cup (OUT[B]-def_B)
$$<p>
eg:</p>
<p><img src="/imgs/001-012.png"
	
	
	
	loading="lazy"
	
	
></p>
<p>可得到如下的use和def集合：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">use[B1]={m,n,u1}
</span></span><span class="line"><span class="cl">def[B1]={i,j,a}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">use[B2]={i,j}//这里虽然i和j都被定值了，但引用在定值之前，所以仍然是use集
</span></span><span class="line"><span class="cl">def[B2]={}//定值的i和j都被引用了
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">use[B3]={u2}
</span></span><span class="line"><span class="cl">def[B3]={a}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">use[B4]={u3}
</span></span><span class="line"><span class="cl">def[B4]={i}
</span></span></code></pre></td></tr></table>
</div>
</div><p>初始化每个IN[B]都为空集参与运算，进行迭代，由于用的是后继，所以我们从最深处开始遍历：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">OUT[B4]=IN[EXIT]∪IN[B2]={}
</span></span><span class="line"><span class="cl">IN[B4]={u3}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">OUT[B3]={u3}
</span></span><span class="line"><span class="cl">IN[B3]={u2,u3}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">OUT[B2]=IN[B3]∪IN[B4]={u2,u3}
</span></span><span class="line"><span class="cl">IN[B2]={i,j,u2,u3}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">OUT[B1]={i,j,u2,u3}
</span></span><span class="line"><span class="cl">IN[B1]={m,n,u1,u2,u3}
</span></span><span class="line"><span class="cl">第一轮迭代结束，进行第二轮：
</span></span><span class="line"><span class="cl">OUT[B4]=IN[EXIT]∪IN[B2]={i,j,u2,u3}
</span></span><span class="line"><span class="cl">IN[B4]={j,u2,u3}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">OUT[B3]={j,u2,u3}
</span></span><span class="line"><span class="cl">IN[B3]={j,u2,u3}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">OUT[B2]=IN[B3]∪IN[B4]={j,u2,u3}
</span></span><span class="line"><span class="cl">IN[B2]={i,j,u2,u3}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">OUT[B1]={i,j,u2,u3}
</span></span><span class="line"><span class="cl">IN[B1]={m,n,u1,u2,u3}
</span></span><span class="line"><span class="cl">第二轮迭代结束，第三轮和第二轮结果一样，迭代结束。
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="65-基本块内优化">6.5 基本块内优化
</h2><p>基本块可以用DAG表示，构造方式：</p>
<ul>
<li>每个变量有一个对应的DAG结点表示其初值</li>
<li>每条语句s都对应一个内部结点N
<ul>
<li>结点N的标号是s中的运算符</li>
<li>有一组变量被关联到N，表示s是在此基本块中最晚对这些变量定值的语句</li>
<li>N的子结点是基本块中在s之前，最后一个对s所使用的某个运算分量进行定值的语句对应的结点。如果某个运算分量在基本块中在s之前没有被定值，则这个分量对应的子结点就是其初始值对应的结点，用下标0区分</li>
<li>在为x=y+z构造节点N的时候，如果x已被关联到某节点M上，那么需要从M的关联变量中删除x</li>
<li>如果两个语句表达式相同，可以直接在已存在的结点的关联变量中添加，而不用加入新的节点</li>
</ul>
</li>
<li>某些结点是输出结点，在出口处活跃</li>
</ul>
<p>一个例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">基本块：
</span></span><span class="line"><span class="cl">a = b + c
</span></span><span class="line"><span class="cl">b = a - d
</span></span><span class="line"><span class="cl">c = b + c
</span></span><span class="line"><span class="cl">d = a - d
</span></span></code></pre></td></tr></table>
</div>
</div><p><img src="/imgs/001-013.png"
	
	
	
	loading="lazy"
	
	
></p>
<p>当完成基本块优化后，就可以根据优化得到的DAG生成新的等价的三地址代码，如果结点有多个关联的活跃变量，就必须引入复制语句，为每个变量赋予正确的值。</p>
<p>活跃变量是指其值可能会在以后被使用的变量，在DAG上删除死代码：删除所有没有关联活跃变量的根结点。（重复执行）</p>
<p>代数恒等式使用：如x+0,x/1之类的计算可以消除，局部强度消减：x^2=x*x,2*x=x+x,x/2=x*0.5。常量合并：计算常量表达式的值【常量来源：程序员编写，宏定义展开，其他优化技术带来】交换律，结合律。</p>
<p>数组引用：在构建DAG时为了避免将a[i]误判为公共子表达式，需要为x=a[i]创建一个运算符为=[]的结点，该结点的子结点为a和i，该结点的关联变量是x，为a[j]=y创建一个运算符为[]=的结点，子结点为a，j和y，没有关联变量，该结点将杀死所有已经建立的，其值依赖于a的结点，被杀死的结点不能再关联定值变量，也就不能成为公共子表达式。</p>
<p>由上面的优化方法，我们得到优化后的DAG，然后重组生成等价的三地址代码，对每个具有若干关联定值变量的结点，构造一个三地址指令来计算其中某个变量的值。</p>
<p>例如一个基本块：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">b=3
</span></span><span class="line"><span class="cl">d=a+c
</span></span><span class="line"><span class="cl">e=a*c
</span></span><span class="line"><span class="cl">f=e+d
</span></span><span class="line"><span class="cl">g=b*f
</span></span><span class="line"><span class="cl">h=a+c
</span></span><span class="line"><span class="cl">i=a*c
</span></span><span class="line"><span class="cl">j=h+i
</span></span><span class="line"><span class="cl">k=b*5
</span></span><span class="line"><span class="cl">l=k+j
</span></span><span class="line"><span class="cl">m=l
</span></span></code></pre></td></tr></table>
</div>
</div><p>有如下的DAG：</p>
<p><img src="/imgs/001-014.png"
	
	
	
	loading="lazy"
	
	
></p>
<p>假设基本块结束时仅有l是活跃的，则m,g,j,i,h均可以删除，k可以进行常量合并，得到如下的三地址代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">d=a+c
</span></span><span class="line"><span class="cl">e=a*c
</span></span><span class="line"><span class="cl">f=d+e
</span></span><span class="line"><span class="cl">l=15+f
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="66-流图中的循环">6.6 流图中的循环
</h2><p>程序执行的大部分时间消耗在循环上，循环会影响程序分析的运行时间，改进循环性能的优化会对程序执行产生显著影响。</p>
<p>循环展开：通过将循环体内的代码复制多次，增加loop每一次迭代的步长，减少循环分支指令执行的次数，增大处理器指令调度的空间，增加寄存器重用。</p>
<p>循环中的一些概念：</p>
<ol>
<li>
<p>支配结点：</p>
<p>若从初始结点起，每条到达n的路径都要经过d，写成d dom n；每个结点是它本身的支配结点，循环的入口是循环中所有结点的支配结点。</p>
<p>直接支配结点：从入口结点到达n的所有路径上，结点n的最后一个支配结点。</p>
<p>求解支配结点也可以用数据流分析，约束方程：OUT[B]=IN[B]∪{B}，IN[B]=∩OUT[P]{P是B的前驱}，初始化OUT[B]=N，OUT[ENTRY]={Entry}</p>
</li>
<li>
<p>深度优先排序：</p>
<p>深度优先排序与后序遍历相反。前进边：深度优先生成树的边；后撤边：指向祖先结点；交叉边：在树中互不为祖先</p>
</li>
<li>
<p>回边：</p>
<p>如果a dom b，那么边b-&gt;a叫做回边，如果流图可归约，则后撤边就是回边（可归约：流图中所有回边删除掉之后，剩余的图无环）</p>
</li>
</ol>
<p>自然循环：是一种适合于优化的循环，具有如下性质：有唯一的入口结点，叫做首结点，首结点支配该循环中所有结点；至少存在一条回边进入该循环首结点。</p>
<p>给定一条回边n-&gt;d，它所对应自然循环包含d加上不经过d能到达n的所有结点，且结点d是该循环的首结点。</p>
<blockquote class="alert alert-note">
    <p>其实就是找从某个结点p开始的不走过n这条路的路径到达n，把路径起点加到自然循环中。</p></blockquote>
<p>eg:</p>
<p><img src="/imgs/001-015.png"
	
	
	
	loading="lazy"
	
	
></p>
<div class="table-wrapper"><table>
  <thead>
      <tr>
          <th>回边</th>
          <th>自然循环</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>4-&gt;3</td>
          <td>{3,4,5,6,7,8,10}</td>
      </tr>
      <tr>
          <td>7-&gt;4</td>
          <td>{4,5,6,7,8,10}</td>
      </tr>
      <tr>
          <td>8-&gt;3</td>
          <td>{3,4,5,6,7,8,10}</td>
      </tr>
      <tr>
          <td>9-&gt;1</td>
          <td>{1-10}</td>
      </tr>
      <tr>
          <td>10-&gt;7</td>
          <td>{7,8,9}</td>
      </tr>
  </tbody>
</table></div>
<p>以第一个为例：首先d(3)要在自然循环里，然后考虑其他结点，比如4可以不经过3到达4，5可以走5-&gt;7-&gt;4这条路到达4，所以4和5都加到自然循环里，其余类似，而像1，只有1-&gt;2-&gt;3-&gt;4或1-&gt;3-&gt;4到达4必须经过3，所以不在自然循环中。</p>
<p>内循环：若一个循环的结点集合是另一个循环的结点集合的子集。</p>
<h2 id="67-寄存器分配">6.7 寄存器分配
</h2><p>寄存器是宝贵的计算机资源，需要合理利用和分配。</p>
<p>寄存器分配主要有线性扫描和图着色两类算法，前者比后者性能更好，应用更加广泛，但需要借助于变量存活区间的分析。</p>

</section>


    <footer class="article-footer">
    

    
    <section class="article-copyright">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M14.5 9a3.5 4 0 1 0 0 6" />
</svg>



        <span>Licensed under CC BY-NC-SA 4.0</span>
    </section>
    </footer>


    
        <link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css"integrity="sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI&#43;WdtXRGWt2kTvGFasHpSy3SV"crossorigin="anonymous"
            ><script 
                src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"integrity="sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG&#43;vnGctmUb0ZY0l8"crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"integrity="sha384-&#43;VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4&#43;/RRE05"crossorigin="anonymous"
                defer
                >
            </script><script>
    window.addEventListener("DOMContentLoaded", () => {
	const mainArticleElement = document.querySelector(".main-article");
        renderMathInElement(mainArticleElement, {
            delimiters: [
                { left: "$$", right: "$$", display: true },
                { left: "$", right: "$", display: false },
                { left: "\\(", right: "\\)", display: false },
                { left: "\\[", right: "\\]", display: true }
            ],
            ignoredClasses: ["gist"]
        });})
</script>

    
</article>

    

    

<aside class="related-content--wrapper">
    <h2 class="section-title">相关文章</h2>
    <div class="related-content">
        <div class="flex article-list--tile">
            
                
<article class="has-image">
    <a href="/p/compiler/">
        
        
            <div class="article-image">
                
                    <img src="/post/005.png" loading="lazy" data-key="compiler" data-hash="/post/005.png"/>
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">手动搭建编译器  基于龙芯汇编与LIGHTIR中间代码</h2>
        </div>
    </a>
</article>

            
        </div>
    </div>
</aside>

     
    
        
    <link
rel="stylesheet"
href="https://unpkg.com/@waline/client@v3/dist/waline.css"
/>

<div id="waline" class="waline-container"></div>

<style>
    .waline-container {
        background-color: var(--card-background);
        border-radius: var(--card-border-radius);
        box-shadow: var(--shadow-l1);
        padding: var(--card-padding);
        --waline-font-size: var(--article-font-size);
    }
    .waline-container .wl-count {
       color: var(--card-text-color-main);
    }
</style><script type="module">
    import { init } from 'https://unpkg.com/@waline/client@v3/dist/waline.js';

    init({"dark":"html[data-scheme=\"dark\"]","el":"#waline","emoji":["https://npm.elemecdn.com/@waline/emojis@1.1.0/bilibili","https://npm.elemecdn.com/@waline/emojis@1.1.0/bmoji","https://npm.elemecdn.com/@waline/emojis@1.1.0/weibo"],"lang":"zh-CN","locale":{"admin":"站长","placeholder":"还没有人评论哦！快来抢沙发吧~"},"placeholder":"欢迎留下宝贵的评论！","requiredMeta":["name","email","url"],"serverURL":"https://wilinetest-qw2k7t4q4-zhuyh1139s-projects.vercel.app/","visitor":true});
  </script>

    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
            2024 - 
        
        2025 Example Person
    </section>
    
    <section class="powerby">
        使用 <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> 构建 <br />
        主题 <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="3.29.0">Stack</a></b> 由 <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a> 设计
    </section>
</footer>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css"crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css"crossorigin="anonymous"
            >

            </main>
        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js"integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z&#43;KMkF24hUW8WePSA9HM="crossorigin="anonymous"
                
                >
            </script><script type="text/javascript" src="/ts/main.05855e03984e0c21563e042e67eb3d1dbf10a0e7f128d98ef596b3fcb29bf3fa.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>
<script>
  const cdnPath = 'https://cdn.jsdelivr.net/gh/letere-gzj/live2d-widget-v3@main';
  const config = {
    
    path: {
      modelPath: cdnPath + "/Resources/",
      cssPath: cdnPath + "/waifu.css",
      tipsJsonPath: cdnPath + "/waifu-tips.json",
      tipsJsPath: cdnPath + "/waifu-tips.js",
      live2dCorePath: cdnPath + "/Core/live2dcubismcore.js",
      live2dSdkPath: cdnPath + "/live2d-sdk.js"
    },
    
    tools: ["hitokoto", "asteroids", "express", "switch-model", "switch-texture", "info", "quit"],
    
    drag: {
      enable: true,
      direction: ["x", "y"]
    },
    
    switchType: "order"
  }

  
  if (screen.width >= 768) {
    Promise.all([
      loadExternalResource(config.path.cssPath, "css"),
      loadExternalResource(config.path.live2dCorePath, "js"),
      loadExternalResource(config.path.live2dSdkPath, "js"),
      loadExternalResource(config.path.tipsJsPath, "js")
    ]).then(() => {
      initWidget({
        waifuPath: config.path.tipsJsonPath,
        cdnPath: config.path.modelPath,
        tools: config.tools,
        dragEnable: config.drag.enable,
        dragDirection: config.drag.direction,
        switchType: config.switchType
      });
    });
  }

  
  function loadExternalResource(url, type) {
    return new Promise((resolve, reject) => {
      let tag;
      if (type === "css") {
        tag = document.createElement("link");
        tag.rel = "stylesheet";
        tag.href = url;
      }
      else if (type === "js") {
        tag = document.createElement("script");
        tag.src = url;
      }
      if (tag) {
        tag.onload = () => resolve(url);
        tag.onerror = () => reject(url);
        document.head.appendChild(tag);
      }
    });
  }
</script>
<script src=http://localhost:1313/background/sakura.js></script>



<style>
  #TableOfContents > ul, ol {
      ul, ol {
          display: none;
      }
      .open {
          display: block;
      }
  }
</style>

<script>
  function initTocHide() {
      
      let toc = document.querySelector(".widget--toc");
      if (!toc) {
          return;
      }
      
      window.addEventListener('scroll', function() {
          
          let openUl = document.querySelectorAll(".open");
          if (openUl.length > 0) {
            openUl.forEach((ul) => {
              ul.classList.remove("open")
            })
          }
          
          let currentLi = document.querySelector(".active-class");
          if (!currentLi) {
              return
          }
          
          if (currentLi.children.length > 1) {
              currentLi.children[1].classList.add("open")
          }
          
          let ul = currentLi.parentElement;
          do {
              ul.classList.add("open");
              ul = ul.parentElement.parentElement
          } while (ul !== undefined && (ul.localName === 'ul' || ul.localName === 'ol'))
      });
  }
  initTocHide()
</script>


<style>
  #backTopBtn {
      display: none;
      position: fixed;
      bottom: 30px;
      z-index: 99;
      cursor: pointer;
      width: 30px;
      height: 30px;
      background-image: url(http://localhost:1313/icons/backTop.svg);
  }
</style>

<script>
  

  function initScrollTop() {
      let rightSideBar = document.querySelector(".right-sidebar");
      if (!rightSideBar) {
          return;
      }
      
      let btn = document.createElement("div");
      btn.id = "backTopBtn";
      btn.onclick = backToTop
      rightSideBar.appendChild(btn)
      
      window.onscroll = function() {
          
          if (document.body.scrollTop > 20 || document.documentElement.scrollTop > 20) {
              btn.style.display = "block";
          } else {
              btn.style.display = "none";
          }
      };
  }

  

  function backToTop(){
      window.scrollTo({ top: 0, behavior: "smooth" })
  }

  initScrollTop();
</script>

<style>
  .highlight {
       
      max-height: 400px;
      overflow: hidden;
  }

  .code-show {
      max-height: none !important;
  }

  .code-more-box {
      width: 100%;
      padding-top: 78px;
      background-image: -webkit-gradient(linear, left top, left bottom, from(rgba(255, 255, 255, 0)), to(#fff));
      position: absolute;
      left: 0;
      right: 0;
      bottom: 0;
      z-index: 1;
  }

  .code-more-btn {
      display: block;
      margin: auto;
      width: 44px;
      height: 22px;
      background: #f0f0f5;
      border-top-left-radius: 8px;
      border-top-right-radius: 8px;
      padding-top: 6px;
      cursor: pointer;
  }

  .code-more-img {
      cursor: pointer !important;
      display: block;
      margin: auto;
      width: 22px;
      height: 16px;
  }
</style>

<script>
function initCodeMoreBox() {
  let codeBlocks = document.querySelectorAll(".highlight");
  if (!codeBlocks) {
    return;
  }
  codeBlocks.forEach(codeBlock => {
    
    if (codeBlock.scrollHeight <= codeBlock.clientHeight) {
      return;
    }
    
    
    let codeMoreBox = document.createElement('div');
    codeMoreBox.classList.add('code-more-box');
    
    let codeMoreBtn = document.createElement('span');
    codeMoreBtn.classList.add('code-more-btn');
    codeMoreBtn.addEventListener('click', () => {
      codeBlock.classList.add('code-show');
      codeMoreBox.style.display = 'none';
    })
    
    let img = document.createElement('img');
    img.classList.add('code-more-img');
    img.src = "http://localhost:1313/icons/codeMore.png"
    
    codeMoreBtn.appendChild(img);
    codeMoreBox.appendChild(codeMoreBtn);
    codeBlock.appendChild(codeMoreBox)
  })
}

initCodeMoreBox();
</script>

    </body>
</html>
