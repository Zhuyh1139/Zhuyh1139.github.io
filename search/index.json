[{"content":" 这篇带领大家通过修改配置文件来做基本的美化操作。\n左侧状态栏\r顾名思义，就是左边的头像，签名等还有相关链接，像我是这样设置的：\nhugo.yaml文件：\n1 2 3 4 5 6 7 8 languages: zh-cn: languageName: 中文 title: 陌辞咖啡馆 weight: 1 params: sidebar: subtitle: 观我旧往，同我仰春 关于旁边的表情符号，在这里：\n1 2 3 4 5 6 7 sidebar: emoji: 🍥 subtitle: Lorem ipsum dolor sit amet, consectetur adipiscing elit. avatar: enabled: true local: true src: img/222.png 其中，src表示头像的存放路径，在themes/hugo-theme-stack/assets/img中存放。\n再下面的是个人相关链接，我这里有b站，CSDN和Github，如下所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 social: - identifier: github name: GitHub url: https://github.com/Zhuyh1139 weight: 1 params: icon: brand-github - identifier: bilibili name: Bilibili url: https://space.bilibili.com/527591205 weight: 2 params: icon: bilibili - identifier: CSDN name: CSDN url: https://blog.csdn.net/2301_77127818?spm=1010.2135.3001.5421 weight: 3 params: icon: csdn 其中，url填你的对应网址，icon填图标文件名，这里的图标文件都是svg文件，位于hemes/hugo-theme-stack/assets/icons下，里面主题默认有一批，若你像我一样需要别的可以在这个网站找：\niconfont-阿里巴巴矢量图标库\n这是可以查看下载下来的svg文件源码，如果有color或者fill之类的属性，需要把值修改位currentColor，像下面这样，不然会出现深色模式没有切换的情况：\n左边下面的菜单栏也可以这样设置：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 menu: main: - identifier: home name: 首页 url: / weight: 1 params: icon: home newTab: true - identifier: archives name: 归档 url: /archives/ weight: 2 params: icon: archives newTab: true - identifier: about name: 关于 url: /about/ weight: 3 params: icon: user newTab: true - identifier: search name: 搜索 url: /search/ weight: 4 params: icon: search newTab: true 这里的icon和上面一样的道理，然后不同url对应网址这里还没有做，所以现在打开应该是404not found，不用担心，后面补上就行了。\n这样我们左侧的状态栏就差不多搞定了！\n背景图片\r如果要插入静态背景图片，需要先准备一张背景图（废话）放在根目录的assets/background下，如果不存在就自行创建文件夹，我随便选了一张：\n在主题目录的页脚文件中修改，具体目录为layouts/partials/footer/custom.html，不存在就自己创建，添加下面的代码：\n1 2 3 4 5 6 7 \u0026lt;style\u0026gt; body { background: url({{ (resources.Get \u0026#34;background/背景图片名\u0026#34;).Permalink }}) no-repeat center top; background-size: cover; background-attachment: fixed; } \u0026lt;/style\u0026gt; 然后就像这样了：\n但是这种虽然好看，不过太花了挺影响观感的，于是我选择了樱花飞舞这个动态背景：letere-gzj.github.io/hugo-stack/p/hugo/custom-background/sakura.js，点开后ctrl+s保存，同理也放在上面那个background文件夹下，并在上面的custom.html文件中添加：\n1 \u0026lt;script src={{ (resources.Get \u0026#34;background/sakura.js\u0026#34;).Permalink }}\u0026gt;\u0026lt;/script\u0026gt; 然后你就可以得到和我这样一样的效果了。\nlive2d小人\r不知道你注意到没，我的博客左下角有一个小人，视线会追随着你的鼠标，这个和桌面上的live2d十分相似，下面教给大家：\n我用的是live2d-widget的自带模型，没有经过任何修改，如果你想用别的开源模型或者自定义其它功能，可以对其进行修改，还是上面那个custom.html文件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 \u0026lt;script\u0026gt; const cdnPath = \u0026#39;https://cdn.jsdelivr.net/gh/letere-gzj/live2d-widget-v3@main\u0026#39;; const config = { // 资源路径 path: { modelPath: cdnPath + \u0026#34;/Resources/\u0026#34;, cssPath: cdnPath + \u0026#34;/waifu.css\u0026#34;, tipsJsonPath: cdnPath + \u0026#34;/waifu-tips.json\u0026#34;, tipsJsPath: cdnPath + \u0026#34;/waifu-tips.js\u0026#34;, live2dCorePath: cdnPath + \u0026#34;/Core/live2dcubismcore.js\u0026#34;, live2dSdkPath: cdnPath + \u0026#34;/live2d-sdk.js\u0026#34; }, // 工具栏 tools: [\u0026#34;hitokoto\u0026#34;, \u0026#34;asteroids\u0026#34;, \u0026#34;express\u0026#34;, \u0026#34;switch-model\u0026#34;, \u0026#34;switch-texture\u0026#34;, \u0026#34;info\u0026#34;, \u0026#34;quit\u0026#34;], // 模型拖拽 drag: { enable: true, direction: [\u0026#34;x\u0026#34;, \u0026#34;y\u0026#34;] }, // 模型切换(order: 顺序切换，random: 随机切换) switchType: \u0026#34;order\u0026#34; } // 加载资源并初始化 if (screen.width \u0026gt;= 768) { Promise.all([ loadExternalResource(config.path.cssPath, \u0026#34;css\u0026#34;), loadExternalResource(config.path.live2dCorePath, \u0026#34;js\u0026#34;), loadExternalResource(config.path.live2dSdkPath, \u0026#34;js\u0026#34;), loadExternalResource(config.path.tipsJsPath, \u0026#34;js\u0026#34;) ]).then(() =\u0026gt; { initWidget({ waifuPath: config.path.tipsJsonPath, cdnPath: config.path.modelPath, tools: config.tools, dragEnable: config.drag.enable, dragDirection: config.drag.direction, switchType: config.switchType }); }); } // 异步加载资源 function loadExternalResource(url, type) { return new Promise((resolve, reject) =\u0026gt; { let tag; if (type === \u0026#34;css\u0026#34;) { tag = document.createElement(\u0026#34;link\u0026#34;); tag.rel = \u0026#34;stylesheet\u0026#34;; tag.href = url; } else if (type === \u0026#34;js\u0026#34;) { tag = document.createElement(\u0026#34;script\u0026#34;); tag.src = url; } if (tag) { tag.onload = () =\u0026gt; resolve(url); tag.onerror = () =\u0026gt; reject(url); document.head.appendChild(tag); } }); } \u0026lt;/script\u0026gt; 这样你就能看到live2d小人出现在你的网站中了！\n字体与鼠标样式\r这两个我都没弄，但想要更华丽的网站的朋友们可以参考一下，首先是字体，先下载一个自己喜欢的字体，网站：100font.com - 免费商用字体大全 - 免费字体下载网站\n下载解压到根目录下assets/font目录下，不存在自己创建。还是在上面（梅开三度）custom.html文件中添加：\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;style\u0026gt; @font-face { font-family: \u0026#39;字体名\u0026#39;; src: url({{ (resources.Get \u0026#34;font/字体文件名\u0026#34;).Permalink }}) format(\u0026#39;truetype\u0026#39;); } :root { --base-font-family: \u0026#39;字体名\u0026#39;; --code-font-family: \u0026#39;字体名\u0026#39;; } \u0026lt;/style\u0026gt; 然后就有了如下的效果（这里我用的是鼎列珠海字体）：\n下面是鼠标指针，首先需要准备你需要的不同状态的鼠标指针图片（默认，文本，指针，加载等），然后将这些图片放在根目录的static/mouse文件夹下，自己创建。\n接下来修改主题目录下的assets/scss/custom.scss（不存在自己创建），可以使用下面这个代码，适用于stack主题：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // 【Stack主题鼠标样式写法】 // default光标图片 body, html, .article-content img { cursor: url(../mouse/默认光标图片名), auto !important; } // pointer光标图片 a:hover, button:hover, .copyCodeButton:hover, #dark-mode-toggle { cursor: url(../mouse/指针光标图片名), auto; } // text光标图片 input:hover, .site-description, .article-subtitle, .article-content span, .article-content li, .article-content p { cursor: url(../mouse/文本光标图片名), auto; } 这样就能实现更改鼠标指针样式了，经测试，png,cur文件都是可以的。\n其它小细节\r文章目录折叠\r有时候，文章目录非常庞大，比如我那篇编译原理复习，这时就可以采用目录折叠，只有在到指定位置时才展开目录，只需在custom.html（梅开四度）中添加：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 \u0026lt;style\u0026gt; #TableOfContents \u0026gt; ul, ol { ul, ol { display: none; } .open { display: block; } } \u0026lt;/style\u0026gt; \u0026lt;script\u0026gt; function initTocHide() { // 判断是否存在文章目录 let toc = document.querySelector(\u0026#34;.widget--toc\u0026#34;); if (!toc) { return; } // 监听滚动 window.addEventListener(\u0026#39;scroll\u0026#39;, function() { //清除class值 let openUl = document.querySelectorAll(\u0026#34;.open\u0026#34;); if (openUl.length \u0026gt; 0) { openUl.forEach((ul) =\u0026gt; { ul.classList.remove(\u0026#34;open\u0026#34;) }) } // 获取active-class let currentLi = document.querySelector(\u0026#34;.active-class\u0026#34;); if (!currentLi) { return } // 展示子ul if (currentLi.children.length \u0026gt; 1) { currentLi.children[1].classList.add(\u0026#34;open\u0026#34;) } // 展示父ul let ul = currentLi.parentElement; do { ul.classList.add(\u0026#34;open\u0026#34;); ul = ul.parentElement.parentElement } while (ul !== undefined \u0026amp;\u0026amp; (ul.localName === \u0026#39;ul\u0026#39; || ul.localName === \u0026#39;ol\u0026#39;)) }); } initTocHide() \u0026lt;/script\u0026gt; 返回顶部按钮\r在上面的图标下载网站中选择一张你喜欢的返回顶部按钮，放在assets/icons中（自行创建），在custom.html中添加：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 \u0026lt;style\u0026gt; #backTopBtn { display: none; position: fixed; bottom: 30px; z-index: 99; cursor: pointer; width: 30px; height: 30px; background-image: url({{ (resources.Get \u0026#34;icons/图标名字.svg\u0026#34;).Permalink }}); } \u0026lt;/style\u0026gt; \u0026lt;script\u0026gt; /** * 滚动回顶部初始化 */ function initScrollTop() { let rightSideBar = document.querySelector(\u0026#34;.right-sidebar\u0026#34;); if (!rightSideBar) { return; } // 添加返回顶部按钮到右侧边栏 let btn = document.createElement(\u0026#34;div\u0026#34;); btn.id = \u0026#34;backTopBtn\u0026#34;; btn.onclick = backToTop rightSideBar.appendChild(btn) // 滚动监听 window.onscroll = function() { // 当网页向下滑动 20px 出现\u0026#34;返回顶部\u0026#34; 按钮 if (document.body.scrollTop \u0026gt; 20 || document.documentElement.scrollTop \u0026gt; 20) { btn.style.display = \u0026#34;block\u0026#34;; } else { btn.style.display = \u0026#34;none\u0026#34;; } }; } /** * 返回顶部 */ function backToTop(){ window.scrollTo({ top: 0, behavior: \u0026#34;smooth\u0026#34; }) } initScrollTop(); \u0026lt;/script\u0026gt; 引用块模版\r我自己平时写md文件用的typora，里面有不同的警示框，用不同颜色表示，但在网页上没有，于是自己手动添加：\n创建文件layouts/_default/_markup/render-blockquote-alert.html，并将以下代码复制进去：\n1 2 3 \u0026lt;blockquote class=\u0026#34;alert alert-{{ .AlertType }}\u0026#34;\u0026gt; {{ .Text | safeHTML -}} \u0026lt;/blockquote\u0026gt; 将以下代码复制进assets/scss/custom.scss文件中：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 [data-scheme=\u0026#34;light\u0026#34;] { .alert-note { --card-separator-color: #65bbee; --blockquote-background-color: #e7f2fa; } .alert-tip { --card-separator-color: #55aa55; --blockquote-background-color: #eeffee; } .alert-important { --card-separator-color: #db75f2; --blockquote-background-color: #feeeff; } .alert-warning { --card-separator-color: #ffbb78; --blockquote-background-color: #ffeecc; } .alert-caution { --card-separator-color: #cc3334; --blockquote-background-color: #ffeeef; } } [data-scheme=\u0026#34;dark\u0026#34;] { .alert-note { --card-separator-color: #006699; --blockquote-background-color: #002234; } .alert-tip { --card-separator-color: #336733; --blockquote-background-color: #112310; } .alert-important { --card-separator-color: #7e1f91; --blockquote-background-color: #331111; } .alert-warning { --card-separator-color: #aa5501; --blockquote-background-color: #452300; } .alert-caution { --card-separator-color: #880000; --blockquote-background-color: #450000; } } 然后试一下：\n这是NOTE\n这是TIP\n这是WARNING\n这是IMPORTANT\n这是CAUTION\n如果你还想添加别的，同理的操作方法在custom.scss文件中添加即可。\n代码折叠\u0026amp;展开\r和上面返回顶部一样的操作，准备一张展开的图片，放在icons文件夹下，在custom.html文件中添加：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 \u0026lt;style\u0026gt; .highlight { /* 你可以根据需要调整这个高度 */ max-height: 400px; overflow: hidden; } .code-show { max-height: none !important; } .code-more-box { width: 100%; padding-top: 78px; background-image: -webkit-gradient(linear, left top, left bottom, from(rgba(255, 255, 255, 0)), to(#fff)); position: absolute; left: 0; right: 0; bottom: 0; z-index: 1; } .code-more-btn { display: block; margin: auto; width: 44px; height: 22px; background: #f0f0f5; border-top-left-radius: 8px; border-top-right-radius: 8px; padding-top: 6px; cursor: pointer; } .code-more-img { cursor: pointer !important; display: block; margin: auto; width: 22px; height: 16px; } \u0026lt;/style\u0026gt; \u0026lt;script\u0026gt; function initCodeMoreBox() { let codeBlocks = document.querySelectorAll(\u0026#34;.highlight\u0026#34;); if (!codeBlocks) { return; } codeBlocks.forEach(codeBlock =\u0026gt; { // 校验是否overflow if (codeBlock.scrollHeight \u0026lt;= codeBlock.clientHeight) { return; } // 元素初始化 // codeMoreBox let codeMoreBox = document.createElement(\u0026#39;div\u0026#39;); codeMoreBox.classList.add(\u0026#39;code-more-box\u0026#39;); // codeMoreBtn let codeMoreBtn = document.createElement(\u0026#39;span\u0026#39;); codeMoreBtn.classList.add(\u0026#39;code-more-btn\u0026#39;); codeMoreBtn.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { codeBlock.classList.add(\u0026#39;code-show\u0026#39;); codeMoreBox.style.display = \u0026#39;none\u0026#39;; }) // img let img = document.createElement(\u0026#39;img\u0026#39;); img.classList.add(\u0026#39;code-more-img\u0026#39;); img.src = {{ (resources.Get \u0026#34;icons/codeMore.png\u0026#34;).Permalink }} // 元素添加 codeMoreBtn.appendChild(img); codeMoreBox.appendChild(codeMoreBtn); codeBlock.appendChild(codeMoreBox) }) } initCodeMoreBox(); \u0026lt;/script\u0026gt; 感谢莱特雷大佬的分享：【Hugo】Stack主题自定义修改\n","date":"2025-01-25T14:00:52+08:00","image":"http://localhost:1313/post/003.png","permalink":"http://localhost:1313/p/hugo-stack-build-02/","title":"建站经验[二]stack主题基本美化操作"},{"content":" 写在前面：在一次稀松平常的复习当中，我在查找相关资料时发现了一篇博客，不同于之前常见的CSDN，知乎与博客网等，那篇博客界面简洁清晰，还十分美观，后面我又发现了博主是自己搭建的属于自己的博客，相当于个人主页加微型社区了，我当时就对其十分感兴趣，于是在期末考试周硬生生完成了建站的基础工作并发布了第一篇博客，后续也是不断对其进行美化与建设。大多数个人博客建设者发布的第一篇博客都是记录建站经历的，那么秉承着“前人栽树，后人乘凉”的原则，这里我也将我在网上学习到的经验整合分享给大家，来尽可能少走弯路。\nGithub相关\r由于github可以免费托管网页并申请域名，因此，我们选择github存储博客源代码（也是大部分选择的），这里我认为你已经有了github账号，不然也很难看到这篇博客，如果实在没有，点击左侧栏目里的那个像猫一样的图标，花几分钟注册一个吧。\n创建新仓库用来存储博客源码，仓库名为{github用户名}.github.io，这样可以避免许多问题，比如我的github用户名为Zhuyh1139，那么就像下面这样：\n这里注意仓库要设为公开(public)，分支使用main。\n建完之后就可以先不用管了，接下来我们要进行hugo相关的工作了。\nHugo相关\r首先需要下载hugo，记得安装extend版本的，不然不支持sass/scss扩展，安装方法非常简单，如果你跟我一样是window系统（我是win11）那么可以直接在终端中输入：\n1 winget install Hugo.Hugo.Extended 如果你下载了别的类似pip等工具，可以考虑如下安装方法：\n1 choco install hugo-extended 1 scoop install hugo-extended 如果你是ubuntu系统等，可以按照官网的安装教程下载：\nInstallation | Hugo\n下载完成之后输入hugo version，如果显示有extended字样说明安装成功啦！\n接下来选择一款你喜欢的主题来作为网站基础样式，这里我选的是网上较多人用的stack，资料也相对多一点。\n我在下载主题时采用的是git clone一键安装，但后续我发现了问题，就是如果想使用自动部署hugo网页的话（也就是用github托管整个项目，自动hugo更新上面github.io仓库），会因为theme文件夹下git的是stack创作者的远程仓库，导致无法正常git push更新，因此这里我推荐直接下载：CaiJimmy/hugo-theme-stack: Card-style Hugo theme designed for bloggers\n下好的直接解压到theme文件夹下即可，然后把里面的hugo.yaml文件移到根目录下，像这样：\n这个hugo.yaml即是我们的网站配置文件，后续大多美化操作都需要涉及这个文件。\n再顺便介绍下其它几个常用的位置文件夹：\nassets：这个在根目录与主题文件夹中都有，存放背景图片，头像等； content：发布的博客，一般在下面同时创建post文件夹作为发布文件夹； static：根目录下，存放md文件中的图片； public：需上传github的文件夹，需要和我们的远程仓库关联。 这个static存放的东西会同步到public里面，而assets里面的一般都是和主题相关的。\n接下来就可以使用指令（根目录下）：\n1 hugo new post/index.md 来创建属于自己的第一篇博客了，此时你会在content/post下面看到index.md文件，而且文件头会有：\n1 2 3 4 5 6 --- title:xxx . . . --- 这样的字样，这就表明成功了，然后在根目录终端输入：\n1 hugo server -D 来进行网页渲染，它会返回一个网址，直接打开即可，你就能看到当前的效果了，这个只要你对目录下任何一个文件修改了都会重新渲染输出，对于测试以及美化来说非常好用。\n上面我们说到了public文件夹要关联到远程仓库，下面是具体步骤：\n1 2 3 4 5 6 cd public git init git remote add origin 仓库地址.git git add . git commit -m \u0026#34;create\u0026#34; git push origin main 其中，关于git的操作这里不多详细讲解，感兴趣的可以自行上网搜索学习。\n然后，等待几分钟，就可以通过访问{你的github用户名}.github.io来看到你的个人博客啦。\n至此，就已经完成了最基础的建站操作了，后面我会发布美化与其它功能的介绍。\n","date":"2025-01-24T20:16:00+08:00","image":"http://localhost:1313/post/002.png","permalink":"http://localhost:1313/p/hugo-stack-build-01/","title":"建站经验[一]利用github加hugo搭建属于自己的博客"},{"content":"","date":"2025-01-24T17:50:13+08:00","permalink":"http://localhost:1313/p/compiler/","title":"手动搭建编译器  基于龙芯汇编与LIGHTIR中间代码"},{"content":" \u0026mdash;\u0026mdash;by zyh 2025.1.6\n1.词法分析\r功能：将输入字符串识别为有意义的子串，即词法单元(token)\n1.1 词法单元的描述-正则式\r正则表达式(Regular Expression)是一种文本模式，包括普通字符（例如，a 到 z 之间的字母）和特殊字符（称为\u0026quot;元字符\u0026quot;），可以用来描述和匹配字符串的特定模式。\n一个简单的例子：正整数识别\n1 2 digit-\u0026gt;0|1|2|3|4|5|6|7|8|9 digits-\u0026gt;digit digit* 其中，*表示闭包，即出现零次或多次。\n下面是常用的一些正则表达式语法：\n常用语法：\n[abc] 匹配方括号中所有单字符，不一定按顺序； [^abc] 匹配除了方括号中字符外所有字符； [a-z] 匹配区间所有字符，注意大小写； [\\s\\S] 匹配所有。\\s 是匹配所有空白符，包括换行，\\S 非空白符，不包括换行； \\w 匹配字母、数字、下划线。等价于 [A-Za-z0-9_]； \\d 匹配任意一个阿拉伯数字（0 到 9）。等价于 [0-9]。 特殊字符：\n* 表示匹配前面的子表达式零次或多次； + 表示匹配前面的子表达式一次或多次； . 表示匹配除换行以外的任意字符； ? 表示匹配前面的子表达式零次或一次； | 表示两项之间选择。 如果要匹配特殊字符，需要在前面加上\\进行转义，\\本身也是特殊字符。\neg：匹配由偶数个0和奇数个1构成的01串：\n1 2 1(00|11)*((01|10)(00|11)*(01|10)(00|11)*)*|0(00|11)*(01|10) (00|11)*((01|10)(00|11)*(01|10)(00|11)*)* 1.2 词法单元的识别-转换图\r如下图的例子：\n1.3 有限自动机\rNFA：不确定的有限自动机\n如下图的例子(a|b)*ab（2是接受状态，两个圈画不出来）：\n1 2 3 4 5 6 graph LR begin--\u0026gt;a((0)) a((0))--a--\u0026gt;a((0)) a((0))--b--\u0026gt;a((0)) a((0))--a--\u0026gt;b((1)) b((1))--b--\u0026gt;c((2)) NFA对于一个token，有可能要尝试很多不同的路径，大部分都是白费功夫，效率很低。\nDFA：确定的有限自动机\n和上面一样的正则式，有如下图（2是接受状态）：\n1 2 3 4 5 6 7 8 graph LR begin--\u0026gt;a((0)) a((0))--b--\u0026gt;a((0)) a((0))--a--\u0026gt;b((1)) b((1))--a--\u0026gt;b((1)) b((1))--b--\u0026gt;c((2)) c((2))--a--\u0026gt;b((1)) c((2))--b--\u0026gt;a((0)) 语法制导的构造算法：NFA的构造(f表示接受状态)\n单字符（包括空ε）：\n1 2 3 graph LR begin--\u0026gt;a((i)) a((i))--ε/a--\u0026gt;b((f)) 选择式s|t：\n1 2 3 4 5 6 graph LR begin--\u0026gt;a((i)) a((i))--ε--\u0026gt;b(s) a((i))--ε--\u0026gt;c(t) b(s)--ε--\u0026gt;d((f)) c(t)--ε--\u0026gt;d((f)) st:\ns*:\n由上述算法即可得到NFA，具有下列性质：\nN(r)的状态数最多是r中符号和算符总数的两倍 N(r)只有一个接受状态，接受状态没有向外的转换 由NFA即可构造出DFA:从每个NFA构造时的i构成的集合出发，通过不同的输入符号构造出状态转移表，每个状态包含多个NFA中的状态。\nDFA的化简：先从终态集合和非终态集合出发，如果从非终态集合输入字符得到的输出集合不属于任何一个分割后的集合的子集，则可以继续分割，否则分割停止，最后可以得到化简后的DFA。\n2.语法分析\r2.1 上下文无关文法\r语法分析的目的是教会计算机判断输入合法性。\n上下文无关文法(CFG)就是说这个文法中所有的产生式左边只有一个非终结符，也就是说，只要找到符合产生式右边的串，就可以把它归约为对应的非终结符。\n$$\r(V_T,V_N,S,P)\r$$ VT是终结符集合，终结符是文法所定义的语言的基本符号，即token VN是非终结符集合，非终结符表示语法成分的符号，存放中间结果，也称为语法变量。 S是开始符号，属于非终结符，是该文法中最大的语法成分，分析开始的地方。 P是产生式集合，产生式描述了将终结符和非终结符组合成串的方法。 终结符集合与非终结符集合的交集为空。\n推导：是从文法推出文法所描述的语言中所包含的合法串集合的动作。\n也就是把符号串中的非终结符用其产生式右部的串来代替，有最左推导与最右推导等多种方式。\nCFG与正则表达式的联系和区别：\n正则表达式可以定义一些简单的语言，能表示给定结构的固定次数的重复或者没有指定次数的重复，但不能用于描述配对或嵌套的结构，因为有限自动机无法记录访问同一状态的次数；\n它们两个都能表示语言，能用正则表达式表示的语言都能用CFG表示。\n文法的二义性：文法的某些句子存在不止一种最左(最右)推导， 或者不止一棵分析树，则该文法是二义的。\n产生原因：有些操作都是左（右）结合的，但不同的优先级在文法中没有表达出来。\n消除办法：定义运算优先级和结合律。\n2.2 自顶向下分析方法\r自顶向下：针对输入串，从文法的开始符号出发，尝试根据产生式规则推导（derive）出该输入串。\n自底向上：针对输入串，尝试根据产生式规则归约（reduce）到文法的开始符号。\n2.2.1 递归下降语法分析\r数据结构：一个输入缓冲区和向前看指针lookahead\n分析过程：自左向右扫描输入串，设计一个辅助过程match()，将lookahead指向的位置与产生式迭代生成的终结符进行匹配，如匹配，将lookahead挪到下一个位置，为每一个非终结符写一个分析过程。\n2.2.2 消除左递归，提取左公因子\rS-\u0026gt;Sa|b这样的文法是左递归的，而自顶向下分析方法无法处理左递归，因为在输入缓冲区的lookahead指针纹丝未动。\n消除实例：\n1 2 3 4 5 直接左递归： A-\u0026gt;Aa|b 消除直接左递归： A-\u0026gt;bA\u0026#39; A\u0026#39;-\u0026gt;aA\u0026#39;|ε 1 2 3 4 5 6 7 8 9 10 非直接左递归： S-\u0026gt;Aa|b A-\u0026gt;Sd|ε 先变换成直接左递归： S-\u0026gt;Aa|b A-\u0026gt;Aad|bd|ε 再消除左递归： S-\u0026gt;Aa|b A-\u0026gt;bdA\u0026#39;|A\u0026#39; A\u0026#39;-\u0026gt;adA\u0026#39;|ε 提取左公因子其实也就是消除回溯：\n1 2 3 4 A-\u0026gt;aB1|aB2|aB3|B4 改为： A-\u0026gt;aA\u0026#39;|B4 A\u0026#39;-\u0026gt;B1|B2|B3 2.3 ll(1)文法\r两个和文法有关的函数：\n$$\rFIRST(α)=\\{a|a=\u003e*a...,a∈V_T\\}\r$$表示可从a推导得到的串的首符号的集合，具体计算时从左向右看，找产生式第一个终结符，若为非终结符则在其产生式中找。\n$$\rFOLLOW(A)=\\{a|S=\u003e*...Aa...,a∈V_T\\}\r$$表示可能在推导过程中紧跟在A右边的终结符号的集合，计算方法：\n文法开始符添加$，有下面两种情况：\nA-\u0026gt;aB 即B后为空，直接将FOLLOW(A)加入到FOLLOW(B)中； A-\u0026gt;aBb 即B后非空，若b为终结符，直接添加；若b为非终结符，则将FIRST(b)中的除ε添加到FOLLOW(B)中,若FIRST(b)中含有ε，则也把FOLLOW(A)加到FOLLOW(B)中 注意FIRST集合和FOLLOW集合都是针对非终结符的，且FIRST集合中只会出现终结符和ε\nan example:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 E-\u0026gt;TE\u0026#39; E\u0026#39;-\u0026gt;+TE\u0026#39;|ε T-\u0026gt;FT\u0026#39; T\u0026#39;-\u0026gt;*FT\u0026#39;|ε F-\u0026gt;(E)|id FIRST(E)=FIRST(T)=FIRST(F)={(,id} FIRST(E\u0026#39;)={+,ε} FIRST(T\u0026#39;)={*,ε} FOLLOW(E)={),$} FOLLOW(E\u0026#39;)=FOLLOW(E) FOLLOW(T)=FIRST(E\u0026#39;)-{ε}+FOLLOW(E\u0026#39;)={+,),$} FOLLOW(T\u0026#39;)=FOLLOW(T) FOLLOW(F)=FIRST(T\u0026#39;)-{ε}+FOLLOW(T\u0026#39;)={*,+,),$} ll(1)文法的性质：没有公共左因子，不是二义的，不含左递归\n由FIRST集与FOLLOW集可以得出LL(1)预测分析表：\n行为非终结符，列为终结符加上$，每个单元都是产生式，仍以上面例子为例：\nid + * ( ) $ E E-\u0026gt;TE' E-\u0026gt;TE' E' E\u0026rsquo;-\u0026gt;+TE' E\u0026rsquo;-\u0026gt;ε E\u0026rsquo;-\u0026gt;ε T T-\u0026gt;FT' T-\u0026gt;FT' T' T\u0026rsquo;-\u0026gt;ε T\u0026rsquo;-\u0026gt;*FT' T\u0026rsquo;-\u0026gt;ε T\u0026rsquo;-\u0026gt;ε F F-\u0026gt;id F-\u0026gt;(E) 构造规则：对文法的每个产生式A-\u0026gt;α，有如下操作：\n对FIRST(α)的每个终结符a，把A-\u0026gt;α加入M[A,a] 如果ε在FIRST(α)中，对FOLLOW(A)的每个终结符b（包括$），把A-\u0026gt;α加入M[A,b] 2.4 自底向上分析方法\r2.4.1 归约\r每一步，特定子串被替换为相匹配的某个产生式左部的非终结符，最终，把输入串归约成文法的开始符号。\n归约是最右推导的逆过程。\n2.4.2 句柄\r句柄(Handles)是指可规约串，和某个产生式右部匹配。\n句柄的右边仅含终结符，如果文法二义，那么句柄可能不唯一。\n2.4.3 移进-归约分析方法\r栈保存已扫描过的文法符号，缓冲区存放还未分析的其余符号；\n移进(shift)：将下一个输入符号放到栈顶，以形成句柄；\n归约(reduce)：将句柄替换为对应的产生式的左部非终结符；\n接受(accept)：分析成功；\n报错(error)：发现语法错误。\n$$\rE-\u003eE+E|E*E|(E)|id\r$$ stack input action $ id*id+id$ 移进 $id *id+id$ 按E-\u0026gt;id规约 $E *id+id$ 移进 $E* id+id$ 移进 $E*id +id$ 按E-\u0026gt;id规约 $E*E +id$ 移进 $E*E+ id$ 移进 $E*E+id $ 按E-\u0026gt;id规约 $E*E+E $ 按E-\u0026gt;E+E规约 $E*E $ 按E-\u0026gt;E*E规约 $E $ 接受 两类冲突：\n移进-归约冲突：解析器无法确定当前的输入是否应该作为一个终结符进行移进，还是应该作为一个非终结符进行归约。比如E-\u0026gt;A|Aa，如果此时stack为A，input为a\u0026hellip;$，此时无法判断进行移进还是规约。 归约-归约冲突：在解析过程中，解析器面对多个不同的产生式规则可以应用，但这些产生式规则的目标符号是相同的，无法确定应该应用哪个产生式。比如E-\u0026gt;a(B)|a,C-\u0026gt;a，如果此时stack为\u0026hellip;a(a，input为,a)\u0026hellip;$，此时无法判断规约到哪一个。 2.5 LR文法\r2.5.1 SLR分析\r活前缀（可行前缀）是指在解析过程中，解析器当前处理的输入串的一部分，并且该部分在当前状态下的所有可能后续扩展中都不包含任何产生式规则的左部（即产生式的左符号）。\n活前缀用于解决移进-归约冲突。\nLR分析方法的特点：栈中的文法符号总是形成一个活前缀；分析表的转移函数本质上是识别活前缀的DFA\nLR(0)项目：在右部的某个地方加点的产生式，加点的目的是用来表示分析过程中的状态。\n增广文法（拓广文法）：开始符E加上E\u0026rsquo;-\u0026gt;E。、\n$$\rE-\u003eE+T|T\\\\\rT-\u003eT*F|F\\\\\rF-\u003e(E)|id\r$$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 首先拓广文法： E\u0026#39;-\u0026gt;E E-\u0026gt;E+T|T T-\u0026gt;T*F|F F-\u0026gt;(E)|id 构造LR(0)项目集规范族： I0: E\u0026#39;-\u0026gt;·E----------------这个拓广得来的是初始项目，下面都是求闭包得来的 E-\u0026gt;·E+T E-\u0026gt;·T T-\u0026gt;·T*F T-\u0026gt;·F F-\u0026gt;·(E) F-\u0026gt;·id 这里的每个I构造规则：如果点后是产生式A-\u0026gt;a，且A-\u0026gt;·a不在闭包中，加入。\n人话：点后面如果是产生式就把产生式从头加个点添加到项目集中，单个项目集中重复的不算。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 我们可以得到其余的项目集（通过移进点后面的终结符或非终结符）： I0--E--\u0026gt;I1: E\u0026#39;-\u0026gt;E· E-\u0026gt;E·+T I0--T--\u0026gt;I2: E-\u0026gt;T· T-\u0026gt;T·*F I0--F--\u0026gt;I3: T-\u0026gt;F· I0--(--\u0026gt;I4: F-\u0026gt;(·E) E-\u0026gt;·E+T E-\u0026gt;·T T-\u0026gt;·T*F T-\u0026gt;·F F-\u0026gt;·(E) F-\u0026gt;·id I0--id--I5： F-\u0026gt;id· I1--+--\u0026gt;I6: E-\u0026gt;E+·T T-\u0026gt;·T*F T-\u0026gt;·F F-\u0026gt;·(E) F-\u0026gt;·id I2--*--\u0026gt;I7: T-\u0026gt;T*·F F-\u0026gt;·(E) F-\u0026gt;·id I4--E--\u0026gt;I8: F-\u0026gt;(E·) E-\u0026gt;E·+T I6--T--\u0026gt;I9: E-\u0026gt;E+T· T-\u0026gt;T·*F I7--F--\u0026gt;I10: T-\u0026gt;T*F· I8--)--\u0026gt;I11: F-\u0026gt;(E)· 这11个项目集组成了DFA的状态，可构造出如下的DFA：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 graph LR a((I_0))--E--\u0026gt;b((I_1)) b((I_1))--+--\u0026gt;c((I_6)) c((I_6))--T--\u0026gt;d((I_9)) a((I_0))--T--\u0026gt;e((I_2)) a((I_0))--F--\u0026gt;F((I_3)) a((I_0))--(--\u0026gt;G((I_4)) a((I_0))--id--\u0026gt;H((I_5)) e((I_2))--*--\u0026gt;I((I_7)) I((I_7))--F--\u0026gt;J((I_10)) G((I_4))--E--\u0026gt;K((I_8)) K((I_8))--)--\u0026gt;L((I_11)) c((I_6))--F--\u0026gt;F((I_3)) c((I_6))--(--\u0026gt;G((I_4)) c((I_6))--id--\u0026gt;H((I_5)) I((I_7))--(--\u0026gt;G((I_4)) I((I_7))--id--\u0026gt;H((I_5)) K((I_8))--+--\u0026gt;c((I_6)) G((I_4))--(--\u0026gt;G((I_4)) G((I_4))--T--\u0026gt;e((I_2)) G((I_4))--F--\u0026gt;F((I_3)) G((I_4))--id--\u0026gt;H((I_5)) d((I_9))--*--\u0026gt;I((I_7)) mermaid画的，有点抽象哈QAQ\n由上面的DFA可构造出SLR分析表，规则如下：\n如果A-\u0026gt;α·aβ在Ii中，并且goto(Ii,a)=Ij，将action[i,a]置为sj 如果A-\u0026gt;α·在Ii中，对FOLLOW(A)中所有a，置action[i,a]为rj，j是产生式A-\u0026gt;α的初始编号 如果S\u0026rsquo;-\u0026gt;S·在Ii中，置action[i,$]为acc 在这个规则中s表示移进，r表示规约，可以看出，如果一个Ii中同时存在·在末尾与在中间的情况时，会出现action[i,a]同时置为rj与sj的情况，也就是移进-归约冲突，此时比较两个左式的FOLLOW集，如果下一个输入符号属于归约的那个左式的FOLLOW集，那么使用归约，反之使用移进。比如该题的I2和I9就存在移进归约冲突，但计算FOLLOW(E)={),+,$},I2和I9的下一个符号为*，不在FOLLOW(E)中，所以均采用移进。\n该例的SLR分析表如下所示：\n(1)E-\u0026gt;E+T\n(2)E-\u0026gt;T\n(3)T-\u0026gt;T*F\n(4)T-\u0026gt;F\n(5)F-\u0026gt;(E)\n(6)F-\u0026gt;id\nid + * ( ) $ E T F 0 s5 s4 1 2 3 1 s6 acc 2 r2 s7 r2 r2 3 r4 r4 r4 r4 4 s5 s4 8 2 3 5 r6 r6 r6 r6 6 s5 s4 9 3 7 s5 s4 10 8 s6 s11 9 r1 s7 r1 r1 10 r3 r3 r3 r3 11 r5 r5 r5 r5 2.5.2 LR分析\rSLR文法产生移进归约冲突，但该文法不是二义的。\n在识别活前缀DFA的状态中，增加信息，排除一些不正确的归约操作。\nSLR只是简单地考察下一个输入符号b是否属于与归约项目A→α相关联的FOLLOW(A)，但b∈FOLLOW(A)只是归约α的一个必要条件，而非充分条件。归约条件被放宽松了。\n项目集：LR(0)=\u0026gt;LR(1)\nLR(1)项目由两个分量组成，第一分量为SLR中的项，第二分量为搜索符（向前看符号），1代表了搜索符a的长度。\n对于[A-\u0026gt;α·β,a]当β不为空时，a不起作用，当β为空时，如果下一个输入符号是a，将按照A-\u0026gt;α进行归约，a的集合是FOLLOW(A)的子集。\nLR(1)闭包计算方法与LR(0)有所不同，若有项目[A-\u0026gt;α·Bβ,a]在闭包中，而B-\u0026gt;γ是文法中的产生式，b是FIRST(βa)中的元素，则[B-\u0026gt;γ，b]也属于闭包。\n$$\r0)S'-\u003eS\\\\\r1)S-\u003eL=R\\\\\r2)S-\u003eR\\\\\r3)L-\u003e*R\\\\\r4)L-\u003eid\\\\\r5)R-\u003eL\r$$ 则可以得到如下所示的LR(1)项目集规范族：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 I0: S\u0026#39;-\u0026gt;·S,$-----S\u0026#39;的搜索符一定是$,因为S\u0026#39;表示规约到了最后,FIRST($)=$ S-\u0026gt;·L=R,$---------FIRST(=R$)=\u0026#34;=\u0026#34;[对于L] S-\u0026gt;·R,$-----------FIRST($)=$[对于R] L-\u0026gt;·*R,= L-\u0026gt;·id,= R-\u0026gt;·L,$-----------FIRST($)=$[对于L] L-\u0026gt;·*R,$ L-\u0026gt;·id,$ I0--S--\u0026gt;I1: S\u0026#39;-\u0026gt;S·,$ I0--L--\u0026gt;I2: S-\u0026gt;L·=R,$ R-\u0026gt;L·,$ I0--R--\u0026gt;I3: S-\u0026gt;R·,$ I0--*--\u0026gt;I4: L-\u0026gt;*·R,=-----------FIRST(=)=\u0026#34;=\u0026#34;[对于R] L-\u0026gt;*·R,$-----------FIRST($)=$[对于R] R-\u0026gt;·L,=------------FIRST(=)=\u0026#34;=\u0026#34;[对于L] R-\u0026gt;·L,$------------FIRST($)=$[对于L] L-\u0026gt;·*R,= L-\u0026gt;·*R,$ L-\u0026gt;·id,= L-\u0026gt;·id,$ I4--id--\u0026gt;I5: L-\u0026gt;id·,= L-\u0026gt;id·,$ I2--=--\u0026gt;I6: S-\u0026gt;L=·R,$----------FIRST($)=$[对于R] R-\u0026gt;·L,$------------FIRST($)=$[对于L] L-\u0026gt;·*R,$ L-\u0026gt;·id,$ I4--R--\u0026gt;I7: L-\u0026gt;*R·,= L-\u0026gt;*R·,$ I4--L--\u0026gt;I8: R-\u0026gt;L·,= R-\u0026gt;L·,$ I6--R--\u0026gt;I9: S-\u0026gt;L=R·,$ I6--L--\u0026gt;I10: R-\u0026gt;L·,$ I6--*--\u0026gt;I11: L-\u0026gt;*·R,$------------FIRST($)=$[对于R] R-\u0026gt;·L,$-------------FIRST($)=$[对于L] L-\u0026gt;·*R,$ L-\u0026gt;·id,$ I6--id--\u0026gt;I12: L-\u0026gt;id·,$ I11--R--\u0026gt;I13: L-\u0026gt;*R·,$ 如果一个项目中两个或多个式子只是搜索符不同，可以写在一起；如果两个项目除搜索符外相同，则这两个项目集是同心的。\nDFA如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 graph LR A((I_0))--S--\u0026gt;B((I_1)) A((I_0))--L--\u0026gt;C((I_2)) A((I_0))--R--\u0026gt;D((I_3)) A((I_0))--*--\u0026gt;E((I_4)) A((I_0))--id--\u0026gt;F((I_5)) C((I_2))--=--\u0026gt;G((I_6)) G((I_6))--R--\u0026gt;H((I_9)) G((I_6))--L--\u0026gt;I((I_10)) G((I_6))--*--\u0026gt;J((I_11)) G((I_6))--id--\u0026gt;K((I_12)) E((I_4))--R--\u0026gt;L((I_7)) E((I_4))--L--\u0026gt;M((I_8)) E((I_4))--id--\u0026gt;F((I_5)) E((I_4))--*--\u0026gt;E((I_4)) J((I_11))--R--\u0026gt;O((I_13)) J((I_11))--id--\u0026gt;K((I_12)) J((I_11))--L--\u0026gt;I((I_10)) J((I_11))--*--\u0026gt;J((I_11)) 则我们可以得到如下所示的LR(1)分析表：\n* id = $ S L R 0 s4 s5 1 2 3 1 acc 2 s6 r5 3 r2 4 s4 s5 8 7 5 r4 r4 6 s11 s12 10 9 7 r3 r3 8 r5 r5 9 r1 10 r5 11 s11 s12 10 13 12 r4 13 r3 每一个SLR(1)文法都是LR(1)的。\n3.中间代码\r3.1 中间代码分析\r编译器前端与后端分离，这样为新机器构建编译器只用设计从中间代码到目标机器代码的编译器即可，并且中间代码优化与源语言和目标机器均无关。\n常见的中间代码类型：\n后缀表示 语法树或DAG图 三地址码（TAC) 静态单赋值形式（SSA） 后缀表示不需要括号，便于计算机处理表达式。\n语法树是一种图形化的中间表示，DAG是有向无环图：\n三地址代码：x= y op z【最多一个算符，最多三个计算分量，每一个分量代表一个地址】\n三地址代码是语法树或DAG的一种线性表示。\n常用的三地址语句：\n运算、赋值：x=y op z,\tx = op y,\tx = y 无条件转移：goto L 条件转移：if x goto L,if False x goto L,if x relop y goto L 过程调用：param x1,param x2,call p ,n(前面设置参数,p为子过程，n为参数) 过程返回：return y 索引赋值：x=y[i],x[i]=y 地址和指针：x=\u0026amp;y,x=*y,*x=y 静态单赋值形式：和三地址代码差不多，但所有赋值指令都是对不同名字的变量的赋值，同一个变量在不同控制流路径上都被定值。\n基本块：首指令：指令序列的第一条三地址指令；任意转移指令的目标指令；紧跟一个转移指令的指令。由首指令(leader)可以划分出基本块(basicblock)。\n流图的节点是一些基本块，从基本块B到基本块C之间有一条边，当且仅当C的第一个指令可能紧跟在B的最后一条指令之后执行，称B是C的前驱(predecessor)，C是B的后继(successor)。\n流图中的一个结点集合L是一个循环，需满足：该集合有唯一的入口结点；集合结点都有一个到达入口结点的非空路径，且该路径全部在L中。\n3.2 语法制导翻译\r编译程序的目标：将源程序翻译成为语义等价的目标程序，源程序与目标程序具有不同的语法结构，表达的结果却是相同的。\n语法制导翻译：使用上下文无关文法(CFG)来引导对语言的翻译，是一种面向文法的翻译技术。通过给语法树上各个符号赋予一定的含义，并且将各个符号进行有结构的连接，可以形成语言的具体语句的含义。这给予我们以启示：可以通过扩充文法， 在文法符号上附着某些语义信息，并在这些语义信息间建立相互计算关系，从而在语法分析的同时进行语义分析。 由于这种分析是在语法分析的控制下进行的，故称为语法制导翻译。\n语法制导定义（SSD）：\n基础的上下文无关文法，每个文法符号有一组属性，每个文法产生式A-\u0026gt;α有一组形式为b=f(c1,c2,\u0026hellip;,ck)的语义规则，其中f是函数，b和c1,c2,\u0026hellip;,ck是该产生式文法符号的属性。\n两种属性：\n综合属性：用于自下而上传递信息；在语法树中，一个结点的综合属性由其子 结点的属性值确定，因此，通常使用自底向上的方法在每一个结点处使用语义规则计算综合属性的值。仅仅使用综合属性的属性文法称S-属性文法。 继承属性：用于自上而下传递信息；在语法树中，一个结点的继承属性由此结 点的父结点和/或兄弟结点的某些属性确定。 3.2.1 S属性定义\r仅仅使用综合属性的语法制导定义称为S属性的SDD,或S-属性定义，S-SDD\n如果一个SDD是S属性的，可以按照语法分析树节点的任何自底向上顺序来计算它的各个属性值;S-属性定义可在自底向上的语法分析过程中实现，如LR分析器。\n$$\rS-\u003eDSD|2\\\\\rD-\u003e0|1\r$$ solution:\n1 2 3 4 5 S\u0026#39;-\u0026gt;S\tprint(S.val) S-\u0026gt;D_1S_1D_2\tS.val = (D_1.val == D_2.val) and S_1.val S-\u0026gt;2\tS.val = true D-\u0026gt;0\tD.val = 0 D-\u0026gt;1\tD.val = 1 3.2.2 L属性定义\r在一个产生式所关联的各属性之间，依赖图的边可以从左到右，但不能从右到左，可以在LR分析器或LL分析器中实现，更加一般化。\n依赖图(dependency graph)是一个描述了分析树中结点属性间依赖关系的有向图，其中属性值为点，属性的依赖关系为边（如果X.a的值依赖于Y.b的值，则依赖图中有从Y.b的结点指向X.a的结点的有向边。\n对于任意一个产生式A-\u0026gt;X1X2\u0026hellip;Xn，其右部符号Xi的继承属性仅依赖于下列属性：\nA的继承属性 产生式Xi左边符号X1X2\u0026hellip;Xi-1的属性 Xi本身的属性，但Xi全部属性不能在依赖图中形成环路 不能依赖A的综合属性的原因：由于A的综合属性可能依赖Xi的属性，包括Xi的综合属性和继承属性，因此可能形成环路。\n一个例子：\n产生式 语义规则 D-\u0026gt;TL L.in = T.type T-\u0026gt;int T.type = integer T-\u0026gt;real T.type = real L-\u0026gt;L1,id L1.in = L.in;addType(id.entry,L.in) L-\u0026gt;id addType(id.entry,L.in) 在上面的表中，L.in是L的继承属性，type是T的综合属性，addType是把类型加到符号表中的标识符条目里（副作用）\n一个没有副作用的SDD称为属性文法，属性文法增加了语义规则描述的复杂度。\n受控的副作用：不会对属性求值产生约束，即可以按照任何拓扑顺序求值，不会影响最终结果。\n3.2.3 抽象语法树的构造\r抽象语法树(AST)，简称语法树，是分析树的浓缩表示：算符和关键字作为内部节点；语法制导翻译可基于分析树，也可基于语法树。\n数据结构：\n对基本运算对象结点： 一个域存放运算对象类别 另一个域存放其值（也可用其他域保存或其它属性或指向该属性值的指针） 对算符结点： 一个域存放算符并作为该结点的标记 其余两个域存放指向运算对象的指针 函数：\nmknode(op,left,right)：建立运算符号结点。 mkleaf(id,entry)：建立标识符结点。 mkleaf(num,val)：建立数结点。 3.2.3.1 S属性AST\r以算数表达式为例，其中nptr综合属性表示文法符号对应的抽象语法树结点。\n产生式 语义规则 E-\u0026gt;E1+T E.nptr = mkNode(\u0026rsquo;+\u0026rsquo;,E1.nptr,T.nptr) E-\u0026gt;T E.nptr = T.npt T-\u0026gt;T1*F E.nptr = mkNode(\u0026rsquo;*\u0026rsquo;,T1.nptr,F.nptr) T-\u0026gt;F T.nptr = F.nptr F-\u0026gt;(E) F.nptr = E.nptr F-\u0026gt;id F.nptr = mkLeaf(id,id.entry) F-\u0026gt;num F.nptr = mkLeaf(num,num.val) 3.2.3.2 L属性AST\r首先消除左递归，将原产生式改为：\n1 2 3 4 5 6 7 8 9 E-\u0026gt;ER R-\u0026gt;+TR1 R-\u0026gt;ε T-\u0026gt;FW W-\u0026gt;*FW1 W-\u0026gt;ε F-\u0026gt;(E) F-\u0026gt;id F-\u0026gt;num 部分如下：\n产生式 语义规则 T-\u0026gt;FW W.i = F.nptr;T.nptr = W.s W-\u0026gt;*FW1 W1.i=mkNode(\u0026rsquo;*\u0026rsquo;,W.i,F.nptr);W.s=W1.s W-\u0026gt;ε W.s = W.i F-\u0026gt;id F.nptr = mkLeaf(id,id.entry) F-\u0026gt;num F.nptr = mkLeaf(num,num.val) S-SDD与L-SDD的AST都是一样的，但分析树却是不同的，S-SDD的分析树与AST比较接近，L-SDD的分析树与AST结构不同。\n3.2.4 语法制导翻译方案\r语法制导翻译方案(SDT)是在产生式右部中嵌入了程序片段(称为语义动作)的CFG\nSDT可以看作是SDD的具体实施方案。\n将每个语义动作都放在产生式的最后并用大括号括起来就将S-SDD转换为了SDT\n3.2.4.1 S属性定义的SDT两种实现方式\r3.2.4.1.1 先建树，后计算\r建立语法分析树，将语义动作看作是虚拟结点，从左到右，深度优先遍历分析树，在访问虚拟结点时执行相应动作。如下图所示：\n3.2.4.1.2 边分析，边计算\r综合属性通过自底向上的LR来计算，当归约发生时执行相应语义动作。\n可以通过扩展的LR语法分析栈来实现，每一个栈元素包含状态，文法符号和综合属性这三个域。\n在上图中，L-\u0026gt;En的代码段：栈中先存入E，后存入n，栈顶指针top指向n，故top-1指向E，打印其在栈的对应值的域即可；E-\u0026gt;E1+T的代码段：栈中先后存入E1,+,T，栈顶指针top指向T，故top-2指向E1，直接弹出三个元素，下一个要存的E可以放在top-2的位置上；其余的类似，不作过多解释。\n3.2.4.2 L属性定义的SDT两种实现方式\rS属性定义属于L属性定义。\n消除左递归的算术表达式语法制导定义是L-SDD，后缀SDT在这里并不适用。\n将L-SDD转换为SDT的规则：\n将计算一个产生式左部符号的综合属性的动作放置在这个产生式右部的最右端 将计算某个非终结符号A的继承属性的动作插入到产生式右部中紧靠在A的本次出现之前的位置上 多个继承属性要考虑次序，防止形成环 以3.2.2中给出的L-SDD的例子来构造L-SDT：\n1 2 3 4 5 D-\u0026gt;T {L.in = T.type} L T-\u0026gt;int {T.type = integer} T-\u0026gt;real {T.type = real} L-\u0026gt;{L1.in = L.in} L1,id {addType(id.entry,L.in)} L-\u0026gt;id {addType(id.entry,L.in)} 以前两个为例，D-\u0026gt;TL，由于语义规则L.in = T.type是计算非终结符号L的继承属性，所以放在L之前紧靠着L；T-\u0026gt;int，由于语义规则T.type = integer是计算左部符号T的综合属性type的，所以放在最右端。\n3.2.4.2.1 与递归下降分析结合\r递归下降翻译器的设计：\n为每个非终结符A构造一个函数 A的每个继承属性对应该函数的一个形参 函数的返回值是A的综合属性值 在函数体中： 首先选择适当的A的产生式 用局部变量保存产生式中文法符号的属性 对产生式体中的终结符号，读入符号并获取其综合属性（由词法分析得到） 对产生式体中的非终结符，调用相应函数，记录返回值 产生式R-\u0026gt;+TR|ε的递归下降分析过程：\n1 2 3 4 5 6 7 void R(){ if (lookahead == \u0026#39;+\u0026#39;) { match(\u0026#39;+\u0026#39;); T(); R(); } else {} } 3.2.4.2.2 与LR分析结合\r将产生式中嵌入的动作删除，挪到产生式最右端，具体来说，对于产生式A-\u0026gt;α{a}β，a是语义动作，引入新的非终结符M，代替{a}，形成A-\u0026gt;αMβ，同时引入新的产生式M-\u0026gt;ε，修改a得到a\u0026rsquo;，将a需要的A或者α中的属性作为M的继承属性进行复制，按照a中的方法计算各属性，将这些属性作为M的综合属性保存起来，最后将{a\u0026rsquo;}与M-\u0026gt;ε关联起来。\neg:原：A-\u0026gt;{B.i=f(A.i)}BC，修改后为：A-\u0026gt;MBC,M-\u0026gt;ε{M.i=A.i;M.s=f(M.i)}\n3.3 中间代码生成\r3.3.1 布尔表达式的控制流翻译\r布尔表达式有两个基本目的：计算逻辑值，在控制流语句中用作条件表达式。\n布尔运算符：or,and,not\n关系运算符relop:\u0026lt;,\u0026lt;=,=,≠,\u0026gt;,\u0026gt;=\n布尔常量：true,false\n用控制流来实现计算：布尔运算符and,or,not不出现在翻译后的代码中，用程序中的位置来表示值。\neg:翻译：if (x\u0026lt;3 or x\u0026gt;5 and x!=y) x=10;\n1 2 3 4 5 6 7 8 if x\u0026lt;3 goto L2 goto L3 L3:\tif x\u0026gt;5 goto L4 goto L1 L4:\tif x!=y goto L2 goto L1 L2:\tx = 10 L1: 注意布尔运算符的优先级，not具有最高优先级，and次之，or最低\n布尔表达式控制流翻译SDD：\nB-\u0026gt;B1 or B2\n1 2 3 4 5 6 语义规则： B1.true = B.true; B1.false = newLabel(); B2.true = B.true; B2.false = B.false; B.code = B1.code || gen(B1.false,\u0026#39;:\u0026#39;) || B2.code B-\u0026gt;B1 and B2\n1 2 3 4 5 6 语义规则： B1.true = newLabel(); B1.false = B.false; B2.true = B.true; B2.false = B.false; B.code = B1.code || gen(B1.true,\u0026#39;:\u0026#39;) || B2.code B -\u0026gt;E1 relop E2\n1 2 语义规则： B.code = E1.code || E2.code || gen(\u0026#39;if\u0026#39;,E1.place,relop.op,E2.place,\u0026#39;goto\u0026#39;,B.true) || gen(\u0026#39;goto\u0026#39;,B.false) B-\u0026gt;(B1)\n1 2 3 4 语义规则： B1.true = B.true; B1.false = B.false; B.code = B1.code B-\u0026gt;not B1\n1 2 3 4 语义规则： B1.true = B.false; B1.false = B.true; B.code = B1.code B-\u0026gt;true/false\n1 2 语义规则： B.code = gen(\u0026#39;goto\u0026#39;,B.true/false) B.true和B.false都是继承属性，需要两趟分析来计算，第一趟生成语法树，第二趟dfs计算属性值。\n3.3.2 基于符号回填的布尔表达式翻译\r布尔表达式短路计算翻译中，产生了转移目标不明确的条件或无条件代码。\n解决方案：当生成跳转指令时，暂时不指定目标地址，当有关目标地址确定后，再填回到翻译代码中。\n具体实现：将有相同转移目标的转移代码的编号串起来形成链，可以方便回填目标地址。该list变成了综合属性，可以与LR结合。\n此时我们有两个综合属性：\nB.truelist：代码中所有转向真出口的代码指令链； B.falselist：所有转向假出口的代码指令链。 在生成B的代码时，跳转指令goto是不完整的，目标标号尚未填写，用truelist和falselist来管理。\n相关函数：\nmakelist(i)，创建含标号为i的指令的链表 backpatch(instruction-list,target-label)，将目标地址填回list中每条指令 merge(instruction-list1,instruction-list2)，合并两个链，当两个链中每条指令都会跳转到同一条指令时执行此操作 基于回填的布尔表达式翻译SDD(下面用的是LR分析)：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 B-\u0026gt;not B1 { B.truelist = B1.falselist; B.falselist = B1.truelist; } B-\u0026gt;(B1) { B.truelist = B1.truelist; B.falselist = B1.falselist; } B-\u0026gt;true/false { B.truelist/falselist = makelist(nextinstr); //这里因为要回填的是下面gen的goto语句，所以是nextinstr gen(\u0026#39;goto\u0026#39;,-); //-表示需要回填 } B-\u0026gt;E1 relop E2 { B.truelist = makelist(nextinstr); B.falselist = makelist(nextinstr+1); gen(\u0026#39;if\u0026#39;,E1.place,relop.op,E2.place,\u0026#39;goto\u0026#39;,\u0026#39;-\u0026#39;); gen(\u0026#39;goto\u0026#39;,-); } B-\u0026gt;B1 or M B2 { backpatch(B1.falselist,M.instr); B.truelist = merge(B1.truelist,B2.truelist); B.falselist = B2.falselist; //这里的M是为了保存B2开始的第一条指令：M-\u0026gt;ε {M.instr = nextinstr} } B-\u0026gt;B1 and M B2 { backpatch(B1.truelist,M.instr); B.falselist = merge(B1.falselist,B2.falselist); B.truelist = B2.truelist; } 3.3.3 基于符号回填的其它语句翻译\r对一般语句而言，有一个综合属性：S.nextlist，表示代码中所有跳转到紧跟S的代码之后的指令。\n用S表示一条语句，用L表示语句列表，则有如下的文法和LR分析翻译方案：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 S-\u0026gt;if B then M S1 { //这里的B是上面的布尔表达式 backpatch(B.truelist,M.instr); S.nextlist = merge(B.falselist,S1.nextlist); } M-\u0026gt;ε {M.instr = nextinstr} S-\u0026gt;if B then M1 S1 N else M2 S2 { backpatch(B.truelist,M1.instr); backpatch(B.falselist,M2.instr); temp = merge(S1.nextlist,N.nextlist); S.nextlist = merge(temp,S2.nextlist); } N-\u0026gt;ε { N.nextlist = makelist(nextinstr); gen(\u0026#39;goto\u0026#39;,-); } S-\u0026gt;while M1 B do M2 S1 { backpatch(B.truelist,M2.instr); backpatch(S1.nextlist,M1.instr); S.nextlist = B.falselist; gen(\u0026#39;goto\u0026#39;,M1.instr) } S-\u0026gt;A {S.nextlist = {};} //赋值语句 S-\u0026gt;{L} {S.nextlist = L.nextlist} L-\u0026gt;S {L.nextlist = S.nextlist} L-\u0026gt;L1;M S { backpatch(L1.nextlist,M.instr); L.nextlist = S.nextlist; } 3.4 类型表达式\r类型表达式(type expression):基本类型是类型表达式，可为类型表达式命名，类名也是类型表达式，将类型构造算子作用于类型表达式可以构造新的类型表达式。\n比如数组类型构造算子array和类型表达式integer，int[3]的类型表达式为array(3,integer)，在此基础上再作用一遍为array(2,array(3,integer))，表示int[2][3]仍为类型表达式。\n常见构造算子：\n数组类型构造算子array 指针类型构造算子pointer 笛卡尔乘积类型算子× 函数类型构造算子-\u0026gt; 记录类型构造算子record an example:\n1 2 3 4 5 6 7 8 9 10 11 12 13 typedef struct{ int address; char lexeme[15]; }row; row table[101]; row *p; 则row的类型表达式： record((address×integer)×(lexeme×(array(15,char)))) table的类型表达式： array(101,row) p的类型表达式： pointer(row) 由上述定义我们可以构造类型表达式的SDD与SDT：\n首先为每个文法符号设置综合属性t与继承属性b：\nt是指该符号对应的类型表达式，b表示将类型信息从左到右传递。\n比如下面的文法的SDD：\n产生式 语义规则 T-\u0026gt;BC T.t = C.t; C.b = B.t B-\u0026gt;int B.t = integer B-\u0026gt;float B.t = float C-\u0026gt;[num]C1 C.t = array(num.val,C1.t); C1.b = C.b C-\u0026gt;ε C.t = C.b 由上面的SDD可直接改造为SDT：\n1 2 3 4 5 T-\u0026gt;B {C.b = B.t} C {T.t = C.t;} B-\u0026gt;int {B.t = integer} B-\u0026gt;float {B.t = float} C-\u0026gt;[num] {C1.b = C.b} C1 {C.t = array(num.val,C1.t);} C-\u0026gt;ε {C.t = C.b} 如果要使用LR，同样需要改造文法，参考3.2.4.2.2的改造方法，如下所示：\n1 2 3 4 5 6 7 T-\u0026gt;B M C {T.t = C.t;} M-\u0026gt;ε {M.t = B.t} B-\u0026gt;int {B.t = integer} B-\u0026gt;float {B.t = float} C-\u0026gt;[num] N C1 {C.t = array(num.val,C1.t);} N-\u0026gt;ε {N.t = C.b} C-\u0026gt;ε {C.t = C.b} 3.5 符号表与声明语句翻译\r符号表(symbol table)用于编译过程的分析与合成，如使用前声明检查，确定作用域，内存空间分配，类型表达式构造等等，其使用和修改伴随着编译的全过程。\n声明语句翻译的要点：\n分配存储单元 名字、类型、字宽、偏移 作用域的管理 过程调用 记录类型的管理 不产生中间代码指令，但要更新符号表 符号表的组织与管理：\n各过程有各自的符号表：哈希表 符号表之间有双向链 父-\u0026gt;子：过程中包含哪些子过程定义 子-\u0026gt;父：分析完子过程后继续分析父过程 维护符号表栈和地址偏移量栈（保存尚未完成的过程的符号表指针和相对地址） 3.6 数组寻址翻译\r$$\ri×w+(base-low×w)\r$$ 其中，base是整个数组的基地址，也是分配给该数组的内存块的相对地址；low是下标的下界；w是每个数组元素的宽度。这样写因为low×w是常量，在编译时计算，减少了运行时计算。\n$$\rbase+((i-low_1)×n_2+(j-low_2))×w\r$$$$\r((i_1×n_2)+i_2)×w+(base-((low_1×n_2)+low_2)×w)\r$$$$\r((...((i_1×n_2+i_2)×n_3+i_3)...)×n_k+i_k)×w+base-((...((low_1×n_2+low_2)×n_3+low_3)...)×n_k+low_k)×w\r$$4.运行时管理\r4.1 存储组织\r编译器必须为源程序中出现的一些数据对象分配运行时的存储空间，包括静态存储分配与动态存储分配，对于那些在编译时刻就可以确定大小的数据对象，可以在编译时刻就为它们分配存储空间，这样的策略成为静态存储分配，如果不能在编译时刻完全确定数据对象的大小，就要采用动态存储分配的策略。即，在编译时刻仅产生各种必要的信息，而在运行时刻，再动态地分配存储空间。包括栈式存储分配与堆式存储分配，静态和动态这两个概念分别对应编译时刻和运行时刻。\n名字的作用域：一个声明起作用的程序部分称为该声明的作用域，即使一个名字在程序中只声明一次，该名字在程序运行时也可能表示不同的数据对象。\n环境和状态：\n环境把名字映射到左值，而状态把左值映射到右值（即名字到值有两步映射） 赋值改变状态，但不改变环境 过程调用改变环境 如果环境将名字x映射到存储单元s，则说x被绑定到s 局部数据的分布：\n字节是可编址内存的最小单位 变量所需的存储空间可以根据其类型而静态确定 一个过程所声明的局部变量，按这些变量声明时出现的次序，在局部数据域中依次分配空间 局部数据的地址可以用相对于活动记录中某个位置的地址来表示 数据对象的存储布局还有一个对齐问题 4.2 空间的栈式分配\r对于支持过程、函数和方法的语言，其编译器通常会用栈的形式来管理其运行时刻存储当一个过程被调用时，该过程的活动记录被压入栈中；当过程结束时，记录被弹出这种安排不仅允许活跃时段不交叠的多个过程调用共享空间；而且可以使得过程的非局部变量的相对地址总是固定的，和调用序列无关。\n活动树：用来描述程序运行期间控制进入和离开各个活动的情况的树，树中的每个结点对应于一个活动。根结点是启动程序执行的main过程的活动。\n运行栈：把控制栈中的信息拓广到包括过程活动所需的所有局部信息。\n代码序列 过程调用和过程返回都需要执行一些代码来管理活动记录栈，保存或恢复机器状态等 过程调用序列 过程调用时执行的分配活动记录，把信息填入它的域中，使被调用过程可以开始执行的代码 过程返回序列 被调用过程返回时执行的恢复机器状态，释放被调用过程活动记录，使调用过程能够继续执行的代码 调用序列和返回序列常常都分成两部分，分处于调用过程和被调用过程的活动记录中。 C语言活动记录结构：\n临时数据 局部数据 机器状态 控制链 返回值 参数 Pascal语言活动记录结构：\n临时数据 局部数据 机器状态 访问链 控制链 返回值 参数 4.3 非局部名字的访问\r无过程嵌套的数据访问\n过程体中的非局部引用可以直接使用静态确定的地址 (非局部数据此时是全局数据) 局部变量在栈顶的活动记录中，可以通过 base_sp 指针访问 无须深入栈中取数据，无须访问链 有过程嵌套的静态作用域\n一个过程的声明包含另一个过程的声明，嵌套的子过程可以使用父过程的局部变量 子过程代码被激活执行，要找到父过程的活动记录，需要建立访问链 嵌套深度\n过程嵌套深度：主程序为 1，进入一个被包围的过程加 1 变量的嵌套深度：声明所在过程的嵌套深度为该名字的嵌套深度 过程嵌套的静态作用域在活动记录中增加访问指针形成访问链\n用来寻找非局部名字的存储单元 假设p直接嵌套在q中，则p活动记录的访问链指针指向最靠近的q的活动记录 两个关键问题需要解决\n通过访问链访问非局部引用 访问链的建立 过程p的嵌套深度n_p，引用嵌套深度为n_a的变量 a\n追踪访问链n_p-n_a次 到达a所在的活动记录 访问链的追踪可以间接操作完成 过程p的嵌套深度n_p，调用嵌套深度为n_x的过程 x\nn_p\u0026lt;n_x，x 在 p 中，被调用过程的访问链必须hi想调用过程的活动记录的访问链 n_p\u0026gt;= n_x，找到公共祖先，也就是过程x的最近的n_x-1深度的过程，沿着访问呢连追踪n_p-n_x+1次 参数传递\n形参，存储单元 (左值)，引用调用 实参，存储内容 (右值)，传值调用 堆管理\n堆用于存放生命周期不确定、或生存到明确删除为止的数据对象 new 生成的对象可以生存到被 delete 为止 malloc 申请的空间生存到被 free 为止 分配/回收堆空间的子系统\n分配：为内存请求分配一段连续、适当大小的堆空间 首先从空闲的堆空间选择 若内存紧张，可以回收一部分内存 (C/C++ 需要手动回收，Java 可以自动回收空间) 评价指标：空间效率、程序效率、管理效率 5.代码生成\r同一中间表示代码可以由多组指令序列来实现，但不同实现之间的效率差别是很大的，因此，生成高质量代码需要知道指令代价。\n除了考虑指令的代价和序列长度外，我们还需要考虑运算对象和结果如何存储的问题。\n三地址机器模型：\n目标机器指令集(也可以称为目标语言)包含LD、ST、运算、跳转等指令 内存按照字节寻址 假设有n个通用寄存器R0, R1, …, Rn-1 假设所有运算分量都是整数 指令之前可能有一个标号 目标机器指令集：\n1 2 3 4 5 6 7 8 9 10 11 12 13 加载指令：LD dst,addr 保存指令：ST x,R 运算指令：OP dst,src1,src2 跳转指令：BR L Bcond r,L 寻址： 变量名a a(r)：数组访问，a是变量，r是寄存器 c(r)：沿指针取值，c是整数，r是寄存器 *r：在寄存器r的内容表示的位置上存放的内存位置 *c(r)：在寄存器r中内容加上c后表示的位置上存放的内存位置 #c：常数 在上述简单的目标机器上，指令代价简化为1+指令的源和目的的寻址模式的附加代价；其中，寄存器寻址模式附加代价为0，涉及内存位置或者常数的寻址方式代价为1.\n寄存器描述符：记录每个寄存器当前存放的是哪些变量的值\n地址描述符：记录运行时每个名字的当前值存放在哪个或者哪些位置，该位置可能是寄存器、栈单元、内存地址或者是它们的某个集合，这些信息可以存放在该变量名对应的符号表条目中。\n对每个形如x=y op z的三地址指令I：调用寄存器选择函数getReg(I)来为x、y、z选择寄存器Rx, Ry, Rz；如果Ry中存放的不是y，则生成指令“LD Ry, y’” , y’是存放y的内存位置之一，对于Rz和z的处理与上一步骤类似，最后，生成目标指令“OP Rx, Ry, Rz ”。 对于一个在基本块出口处可能活跃的变量x，如果它的地址描述符表明它的值没有存放在x的内存位置上，则生成指令“ST x, R”：R是在基本块结尾处存放x值的寄存器。 当生成加载、保存和其他指令时，必须同时更新寄存器和地址描述符： 对于LD R, x指令：修改R的寄存器描述符，使之只包含x，修改x的地址描述符，把R作为新增位置加入到x的位置集合中，从任何不同于x的地址描述符中删除R。 对于OP Rx, Ry, Rz指令：修改Rx的寄存器描述符，使之只包含x，从任何不同于Rx的寄存器描述符中删除x，修改x的地址描述符，使之只包含位置Rx，从任何不同于x的地址描述符中删除Rx。 对于ST x, R指令：修改x的地址描述符，使之包含自己的内存位置。 对于x = y指令，假设总是为x和y分配同一个寄存器，如果需要生成“LD Ry, y’” ，则：修改Ry的寄存器描述符，使之只包含y，修改y的地址描述符，把Ry作为新增位置加入y的位置集合中，从任何不同于y的地址描述符中删除Ry，修改Ry的寄存器描述符，使之也包含x，修改x的地址描述符，使之只包含Ry。 上面的规则非常长和复杂，下面给出一个例子帮助理解：\n1 2 3 4 5 6 7 8 基本块三地址代码： t=a-b u=a-c v=t+u a=d d=v+u exit 其中，t,u,v为临时变量，a,b,c,d在出口处活跃 初始寄存器描述符为空，地址描述符只有abcd的内存地址，处理第一句：t=a-b\n由第一条规则，为a选择寄存器R1，为b选择寄存器R2，t选择寄存器R2，可生成如下的指令：\n1 2 3 LD R1,a LD R2,b SUB R2,R1,R2 然后考虑前两句，修改R1和R2的寄存器描述符，使其包含a和b，修改a和b的地址描述符，把R1和R2加到对应位置集合中：\nR1 R2 a b a b c d a,R1 b,R2 c d 对于第三句，修改R2的寄存器描述符，使其只含t，如果别的寄存器含有t就删除，这个例子中没有，不需要管，修改t的地址描述符，使其只包含R2，如果别的地址有R2就删掉，这里把b中的R2删掉：\nR1 R2 a t a b c d t a,R1 b c d R2 第二句和第三句类似，这里不做分析，给出第四句之前的寄存器描述符和地址描述符：\nR1 R2 R3 u t v a b c d t u v a b c d R2 R1 R3 此时考虑第四句a=d，需要为a和d分配同一个寄存器，由于它们都没寄存器，故生成LD R2,d这样的语句，需要进行如下操作：修改R2的寄存器描述符，使其只包含d，修改d的地址描述符，把R2添加进去，把其他位置的R2删去，修改a的地址描述符，使其只含R2，修改R2的寄存器描述符，添加a：\nR1 R2 R3 u a,d v a b c d t u v R2 b c d,R2 R1 R3 这个例子在最后退出时，a和d的地址描述符不含内存位置，需要生成ST指令，把a和d添加到对应位置的地址描述符上。\n6.机器无关代码优化\r代码优化：在不改变程序运行效果的前提下，对程序代码进行等价变换，使之能生成更加高效目标代码。\n优化目标：运行时间更短，占用空间更小。\n6.1 常见的优化方式\r公共子表达式：若x op y已被计算过，且x和y的值没有改变，那么下一次出现就是公共子表达式。下一次计算可以删除，其值用上一次计算结果代替。删除分析：可用表达式数据流分析。 死代码删除：死代码是指计算的结果永远不被引用的语句，一些优化变换可能会引起死代码，如复制传播，常量合并。 复制传播：在复制语句x=y之后尽可能用y代替x，常用的公共子表达式删除和其他一些优化会引入一些复制语句，复制传播本身没有优化的意义，但可以给死代码删除创造机会。 常量合并：如果编译时刻推导出一个表达式的值是常量，就可以用该常量来代替这个表达式。常量合并也是本身没有优化的意义，可以给死代码删除创造机会。 循环优化：强度削弱：将程序中执行时间较长的运算替换为执行时间较短的运算，比如用增量运算替代；归纳变量删除：【归纳变量：如果存在一个常量c，使x每一次赋值总是增加c，则称x为归纳变量】一个循环中，如一组归纳变量的值的变化保持步调一致，则可只保留一个；代码移动：循环不变计算是指不管循环执行多少次都得到相同结果的表达式，代码码移动是循环优化的一种，在进入循环前就对循环不变计算进行求值。对于多重嵌套循环， loop-invariant computation是相对于某一个循环的，可能对于更加外层的循环，它就不成立了。因此，处理循环时，按照由里到外的方式，即dfs。 6.2 到达定值分析\r数据流分析：一组用来获取程序执行路径上的数据流信息的技术。\n应用有到达定值分析，活跃变量分析，可用表达式分析，在每一种应用中，都会把每个程序点和一个数据流值关联起来。\n流图上的点：基本块中，两个相邻的语句之间为程序的一个点，基本块有开始点和结束点。\n数据流值代表在任一程序点能观测到的所有可能程序状态集合的一个抽象，对于一个语句s，s之前的程序点对应的数据流值用IN[s]表示，之后的用OUT[s]表示。\n传递函数f，表示语句前后两点的数据流值受该语句的语义约束，若沿执行路径正向传播，则OUT[s]=fs(IN[s])，逆向则相反，若基本块由s1,s2,s3\u0026hellip;组成，有：IN[si+1]=OUT[si]。\n基本块上的数据流：IN[B]表示紧靠基本块B之前的数据流值，即IN[B]=IN[s1];OUT[B]表示紧靠基本块B之后的数据流值，即OUT[B]=OUT[sn]。\n到达定值分析：到达一个程序点的所有定值(gen)，定值的注销(kill)\n定值与引用：\n1 2 d:\tx:=y+z //语句d是变量x的一个定值点 u:\tw:=x+v //语句u是变量x的一个引用点 称变量x在d点的定值到达u点\n用途：\n循环不变量检测：如果循环中有x=y+z，而y和z的所有可能定值都在循环外，则y+z就是循环不变计算。 常量合并：如果对变量x的某次使用只有一个定值到达，且该定值把一个常量赋给x，则可以用该常量替换x。 错误检测：判定变量x在p点上是否未经定值就被引用。 gen和kill分别表示一个基本块生成和注销的定值。\ngenB表示B中能到达B的结束点的定值语句，killB表示整个程序中绝不会到达B结束点的定值，IN[B]表示能到达B的开始点的定值集合，OUT[B]表示能到达B的结束点的定值集合。\n$$\rIN[B]=\\cup OUT[P]\\{P是B的前驱\\}\\\\\rOUT[B]=gen_B \\cup (IN[B]-kill_B)\\\\\rOUT[ENTRY]=\\emptyset\r$$ 如下面的例子：\n可得到如下的gen和kill集合：\n1 2 3 4 5 6 7 8 9 10 11 gen[B1]={d1,d2,d3} kill[B1]={d4,d5,d6,d7} //因为把d4,d5,d6,d7左边的定值全部改了，不会到达末尾 gen[B2]={d4,d5} kill[B2]={d1,d2,d7} gen[B3]={d6} kill[B3]={d3} gen[B4]={d7} kill[B4]={d1,d4} 下面迭代计算IN和OUT：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 IN[B1]={} //前驱ENTRY的OUT为空 OUT[B1]={d1,d2,d3} IN[B2]=OUT[B1]∪OUT[B4]={d1,d2,d3} //这里初始化OUT都为空，后续会迭代更新 OUT[B2]={d3,d4,d5} IN[B3]={d3,d4,d5} OUT[B3]={d4,d5,d6} IN[B4]={d3,d4,d5,d6} OUT[B4]={d3,d5,d6,d7} IN[B2]={d1,d2,d3,d5,d6,d7} OUT[B2]={d3,d4,d5,d6} IN[B3]={d3,d4,d5,d6} OUT[B3]={d4,d5,d6} IN[B4]={d3,d4,d5,d6} OUT[B4]={d3,d5,d6,d7} 此后不再发生变化，迭代结束，共迭代3轮（加上最后一次没有OUT出现变化的一轮） 6.3 可用表达式分析\r若到点p的每条执行路径都计算x op y，并且计算后没有对x或y赋值，那么称x op y在点p可用。\ne_genB:块B产生的可用表达式集合\ne_killB:块B注销的可用表达式集合\nIN[B]：块B入口的可用表达式集合\nOUT[B]：块B出口的可用表达式集合\n$$\rIN[B]=\\cap OUT[P]\\{P是B的前驱\\}\\\\\rOUT[B]=e\\_gen_B \\cup (IN[B]-e\\_kill_B)\\\\\rOUT[ENTRY]=\\emptyset\r$$ 注意这里用的是交集，求的是最大解。\neg:\n可得到如下的e_gen和e_kill集合：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 忽略了entry和exit，因为都是空集 e_gen[B1]={3,1} //常量一定是可用表达式 e_kill[B1]={D+D,D*D,A+G} //这里改变了D和G的值，所以右边表达式含D和G的要被kill e_gen[B2]={D+D,D*D,B+C} //如果表达式左值在基本块中被修改，则不是可以表达式 e_kill[B2]={A+G,A*A} //这里没有kill掉B+C,即使B和C的值被修改了，因为最后一个语句重新计算了B+C，这样B+C又成为了可用表达式 e_gen[B3]={A+G} //这里的B+c不是可用表达式因为B是左值 e_kill[B3]={B+C} //改变了B，kill掉B+C e_gen[B4]={A*A} e_kill[B4]={B+C} e_gen[B5]={B+C} e_kill[B5]={D*D,A+G,D+D} 初始化OUT[ENTRY]为空集，其余的基本块OUT集合均为U（所有e_gen集合的并集），下面进行迭代：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 IN[B1]=OUT[ENTRY]={} OUT[B1]={3,1} IN[B2]=OUT[B1]∩OUT[B5]={3,1} OUT[B2]={3,1,D+D,D*D,B+C} IN[B3]={3,1,D+D,D*D,B+C} OUT[B3]={A+G,3,1,D+D,D*D} IN[B4]={3,1,D+D,D*D,B+C} OUT[B4]={A*A,3,1,D+D,D*D} IN[B5]={3,1,D+D,D*D} OUT[B5]={3,1,B+C} IN[EXIT]={3,1,B+C} OUT[EXIT]={3,1,B+C} 第一次迭代结束，第二次迭代结果不变这里不做展示，然后就退出了，迭代结束。 6.4 活跃变量分析\r对于变量x和程序点p，如果x的值在p点开始的某条执行路径上被引用，则说x在p点活跃，否则称x在p点已经死亡。\n如果所有寄存器都被占用，且还需要申请一个寄存器，则应该考虑使用已经存放死亡值的寄存器，如果一个值在基本块结尾处是死的，就不必在结尾处保存这个值了。\nIN[B]：块B开始点的活跃变量集合\nOUT[B]：块B结束点的活跃变量集合\nuseB：块B中有引用，且在引用前在B中没有被定值的变量集\ndefB：块B中有定值，且该定值前在B中没有被引用的变量集\n$$\rIN[EXIT]=\\emptyset\\\\\rOUT[B]=\\cup IN[S]\\{S是B的后继\\}\\\\\rIN[B]=use_B \\cup (OUT[B]-def_B)\r$$ eg:\n可得到如下的use和def集合：\n1 2 3 4 5 6 7 8 9 10 11 use[B1]={m,n,u1} def[B1]={i,j,a} use[B2]={i,j}//这里虽然i和j都被定值了，但引用在定值之前，所以仍然是use集 def[B2]={}//定值的i和j都被引用了 use[B3]={u2} def[B3]={a} use[B4]={u3} def[B4]={i} 初始化每个IN[B]都为空集参与运算，进行迭代，由于用的是后继，所以我们从最深处开始遍历：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 OUT[B4]=IN[EXIT]∪IN[B2]={} IN[B4]={u3} OUT[B3]={u3} IN[B3]={u2,u3} OUT[B2]=IN[B3]∪IN[B4]={u2,u3} IN[B2]={i,j,u2,u3} OUT[B1]={i,j,u2,u3} IN[B1]={m,n,u1,u2,u3} 第一轮迭代结束，进行第二轮： OUT[B4]=IN[EXIT]∪IN[B2]={i,j,u2,u3} IN[B4]={j,u2,u3} OUT[B3]={j,u2,u3} IN[B3]={j,u2,u3} OUT[B2]=IN[B3]∪IN[B4]={j,u2,u3} IN[B2]={i,j,u2,u3} OUT[B1]={i,j,u2,u3} IN[B1]={m,n,u1,u2,u3} 第二轮迭代结束，第三轮和第二轮结果一样，迭代结束。 6.5 基本块内优化\r基本块可以用DAG表示，构造方式：\n每个变量有一个对应的DAG结点表示其初值 每条语句s都对应一个内部结点N 结点N的标号是s中的运算符 有一组变量被关联到N，表示s是在此基本块中最晚对这些变量定值的语句 N的子结点是基本块中在s之前，最后一个对s所使用的某个运算分量进行定值的语句对应的结点。如果某个运算分量在基本块中在s之前没有被定值，则这个分量对应的子结点就是其初始值对应的结点，用下标0区分 在为x=y+z构造节点N的时候，如果x已被关联到某节点M上，那么需要从M的关联变量中删除x 如果两个语句表达式相同，可以直接在已存在的结点的关联变量中添加，而不用加入新的节点 某些结点是输出结点，在出口处活跃 一个例子：\n1 2 3 4 5 基本块： a = b + c b = a - d c = b + c d = a - d 当完成基本块优化后，就可以根据优化得到的DAG生成新的等价的三地址代码，如果结点有多个关联的活跃变量，就必须引入复制语句，为每个变量赋予正确的值。\n活跃变量是指其值可能会在以后被使用的变量，在DAG上删除死代码：删除所有没有关联活跃变量的根结点。（重复执行）\n代数恒等式使用：如x+0,x/1之类的计算可以消除，局部强度消减：x^2=x*x,2*x=x+x,x/2=x*0.5。常量合并：计算常量表达式的值【常量来源：程序员编写，宏定义展开，其他优化技术带来】交换律，结合律。\n数组引用：在构建DAG时为了避免将a[i]误判为公共子表达式，需要为x=a[i]创建一个运算符为=[]的结点，该结点的子结点为a和i，该结点的关联变量是x，为a[j]=y创建一个运算符为[]=的结点，子结点为a，j和y，没有关联变量，该结点将杀死所有已经建立的，其值依赖于a的结点，被杀死的结点不能再关联定值变量，也就不能成为公共子表达式。\n由上面的优化方法，我们得到优化后的DAG，然后重组生成等价的三地址代码，对每个具有若干关联定值变量的结点，构造一个三地址指令来计算其中某个变量的值。\n例如一个基本块：\n1 2 3 4 5 6 7 8 9 10 11 b=3 d=a+c e=a*c f=e+d g=b*f h=a+c i=a*c j=h+i k=b*5 l=k+j m=l 有如下的DAG：\n假设基本块结束时仅有l是活跃的，则m,g,j,i,h均可以删除，k可以进行常量合并，得到如下的三地址代码：\n1 2 3 4 d=a+c e=a*c f=d+e l=15+f 6.6 流图中的循环\r程序执行的大部分时间消耗在循环上，循环会影响程序分析的运行时间，改进循环性能的优化会对程序执行产生显著影响。\n循环展开：通过将循环体内的代码复制多次，增加loop每一次迭代的步长，减少循环分支指令执行的次数，增大处理器指令调度的空间，增加寄存器重用。\n循环中的一些概念：\n支配结点：\n若从初始结点起，每条到达n的路径都要经过d，写成d dom n；每个结点是它本身的支配结点，循环的入口是循环中所有结点的支配结点。\n直接支配结点：从入口结点到达n的所有路径上，结点n的最后一个支配结点。\n求解支配结点也可以用数据流分析，约束方程：OUT[B]=IN[B]∪{B}，IN[B]=∩OUT[P]{P是B的前驱}，初始化OUT[B]=N，OUT[ENTRY]={Entry}\n深度优先排序：\n深度优先排序与后序遍历相反。前进边：深度优先生成树的边；后撤边：指向祖先结点；交叉边：在树中互不为祖先\n回边：\n如果a dom b，那么边b-\u0026gt;a叫做回边，如果流图可归约，则后撤边就是回边（可归约：流图中所有回边删除掉之后，剩余的图无环）\n自然循环：是一种适合于优化的循环，具有如下性质：有唯一的入口结点，叫做首结点，首结点支配该循环中所有结点；至少存在一条回边进入该循环首结点。\n给定一条回边n-\u0026gt;d，它所对应自然循环包含d加上不经过d能到达n的所有结点，且结点d是该循环的首结点。\n其实就是找从某个结点p开始的不走过n这条路的路径到达n，把路径起点加到自然循环中。\neg:\n回边 自然循环 4-\u0026gt;3 {3,4,5,6,7,8,10} 7-\u0026gt;4 {4,5,6,7,8,10} 8-\u0026gt;3 {3,4,5,6,7,8,10} 9-\u0026gt;1 {1-10} 10-\u0026gt;7 {7,8,9} 以第一个为例：首先d(3)要在自然循环里，然后考虑其他结点，比如4可以不经过3到达4，5可以走5-\u0026gt;7-\u0026gt;4这条路到达4，所以4和5都加到自然循环里，其余类似，而像1，只有1-\u0026gt;2-\u0026gt;3-\u0026gt;4或1-\u0026gt;3-\u0026gt;4到达4必须经过3，所以不在自然循环中。\n内循环：若一个循环的结点集合是另一个循环的结点集合的子集。\n6.7 寄存器分配\r寄存器是宝贵的计算机资源，需要合理利用和分配。\n寄存器分配主要有线性扫描和图着色两类算法，前者比后者性能更好，应用更加广泛，但需要借助于变量存活区间的分析。\n","date":"2024-12-29T17:13:45+08:00","image":"http://localhost:1313/post/001.png","permalink":"http://localhost:1313/p/compiler-review/","title":"编译原理知识复习"}]