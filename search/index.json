[{"content":"左侧导航栏\r可能你已经在我第一篇建站经验里发现了问题，就是我们左侧的导航栏点进去后都是404，这是因为我们还没有创建对应的页面，在根目录content下创建page文件夹，用来存放我们的相关页面，我这里在page文件夹下创建了三个md文件，对应我左侧导航栏的三个：about.md，archives.md，search.md，这里要注意我们在建站经验[一]中写的：\n1 2 3 4 5 6 7 - identifier: archives name: 归档 url: /archives/ weight: 2 params: icon: archives newTab: false 这里的url是我们对应页面的url，一般来说，hugo创建页面默认标题就是域名，但注意stack配置文件中这句：\n1 2 3 permalinks: post: /p/:slug/ page: /:slug/ 这段规定了域名的命名规则，因此我们可以把前面三个md文件写成这样：（以about.md为例）\n1 2 3 4 5 6 7 --- title : \u0026#34;关于\u0026#34; slug: about layout : \u0026#34;关于\u0026#34; hidden : false comments : true --- 下面就写你想要的内容即可，而archives.md，search.md里面只需引入类似上面的即可，不需要正文内容。\n评论区\r这里提供两种评论系统搭建：waline与gitalk，两者各有优劣，取决于你个人爱好。\nwaline\rwaline官方文档写的比较详细，按照上面的步骤一步一步来即可：\n快速上手 | Waline\n获得了评论区服务端地址后https://\u0026lt;xxxxxx\u0026gt;.vercel.app/访问https://\u0026lt;xxxxxx\u0026gt;.vercel.app/ui/register来注册管理员身份，这里第一个注册的人会自动成为管理员，所以要及时。\n上面的操作弄完之后，在配置文件中添加：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 comments: enabled: true provider: waline waline: serverURL: \u0026lt;your-server-url\u0026gt; lang: zh-CN visitor: true pageview: emoji: - https://npm.elemecdn.com/@waline/emojis@1.1.0/bilibili - https://npm.elemecdn.com/@waline/emojis@1.1.0/bmoji - https://npm.elemecdn.com/@waline/emojis@1.1.0/weibo requiredMeta: - name - email - url placeholder: 欢迎留下宝贵的评论！ locale: admin: 站长 placeholder: 还没有人评论哦！快来抢沙发吧~ 这里的表情你可以自行选择，还有很多，在waline官方文档中都有。\ngitalk\r首先我们需要创建一个github application：New OAuth Application\n其中需要填写的有：\napplication name：随意起名 homepage url：你的博客地址，记得加https authorization callback url：和上面一样，填博客地址 点register application后，会告诉你client ID，然后我们再生成一个密钥，即client Secret，接着在配置文件中添加：\n1 2 3 4 5 6 7 8 9 10 comments: enabled: true provider: gitalk gitalk: owner: \u0026lt;your-github-name\u0026gt; admin: \u0026lt;your-github-name\u0026gt; repo: \u0026lt;仓库名，即那个github.io\u0026gt; clientID: xxx clientSecret: xxx 然后第一次进入后会让你登录，直接Github授权就完事了。\n","date":"2025-02-04T20:58:58+08:00","image":"http://localhost:1313/post/004.png","permalink":"http://localhost:1313/p/hugo-stack-build-03/","title":"建站经验[三]评论系统与其它细节"},{"content":" 这篇带领大家通过修改配置文件来做基本的美化操作。\n左侧状态栏\r顾名思义，就是左边的头像，签名等还有相关链接，像我是这样设置的：\nhugo.yaml文件：\n1 2 3 4 5 6 7 8 languages: zh-cn: languageName: 中文 title: 陌辞咖啡馆 weight: 1 params: sidebar: subtitle: 观我旧往，同我仰春 关于旁边的表情符号，在这里：\n1 2 3 4 5 6 7 sidebar: emoji: 🍥 subtitle: Lorem ipsum dolor sit amet, consectetur adipiscing elit. avatar: enabled: true local: true src: img/222.png 其中，src表示头像的存放路径，在themes/hugo-theme-stack/assets/img中存放。\n再下面的是个人相关链接，我这里有b站，CSDN和Github，如下所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 social: - identifier: github name: GitHub url: https://github.com/Zhuyh1139 weight: 1 params: icon: brand-github - identifier: bilibili name: Bilibili url: https://space.bilibili.com/527591205 weight: 2 params: icon: bilibili - identifier: CSDN name: CSDN url: https://blog.csdn.net/2301_77127818?spm=1010.2135.3001.5421 weight: 3 params: icon: csdn 其中，url填你的对应网址，icon填图标文件名，这里的图标文件都是svg文件，位于hemes/hugo-theme-stack/assets/icons下，里面主题默认有一批，若你像我一样需要别的可以在这个网站找：\niconfont-阿里巴巴矢量图标库\n这是可以查看下载下来的svg文件源码，如果有color或者fill之类的属性，需要把值修改位currentColor，像下面这样，不然会出现深色模式没有切换的情况：\n左边下面的菜单栏也可以这样设置：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 menu: main: - identifier: home name: 首页 url: / weight: 1 params: icon: home newTab: true - identifier: archives name: 归档 url: /archives/ weight: 2 params: icon: archives newTab: true - identifier: about name: 关于 url: /about/ weight: 3 params: icon: user newTab: true - identifier: search name: 搜索 url: /search/ weight: 4 params: icon: search newTab: true 这里的icon和上面一样的道理，然后不同url对应网址这里还没有做，所以现在打开应该是404not found，不用担心，后面补上就行了。\n这样我们左侧的状态栏就差不多搞定了！\n背景图片\r如果要插入静态背景图片，需要先准备一张背景图（废话）放在根目录的assets/background下，如果不存在就自行创建文件夹，我随便选了一张：\n在主题目录的页脚文件中修改，具体目录为layouts/partials/footer/custom.html，不存在就自己创建，添加下面的代码：\n1 2 3 4 5 6 7 \u0026lt;style\u0026gt; body { background: url({{ (resources.Get \u0026#34;background/背景图片名\u0026#34;).Permalink }}) no-repeat center top; background-size: cover; background-attachment: fixed; } \u0026lt;/style\u0026gt; 然后就像这样了：\n但是这种虽然好看，不过太花了挺影响观感的，于是我选择了樱花飞舞这个动态背景：letere-gzj.github.io/hugo-stack/p/hugo/custom-background/sakura.js，点开后ctrl+s保存，同理也放在上面那个background文件夹下，并在上面的custom.html文件中添加：\n1 \u0026lt;script src={{ (resources.Get \u0026#34;background/sakura.js\u0026#34;).Permalink }}\u0026gt;\u0026lt;/script\u0026gt; 然后你就可以得到和我这样一样的效果了。\nlive2d小人\r不知道你注意到没，我的博客左下角有一个小人，视线会追随着你的鼠标，这个和桌面上的live2d十分相似，下面教给大家：\n我用的是live2d-widget的自带模型，没有经过任何修改，如果你想用别的开源模型或者自定义其它功能，可以对其进行修改，还是上面那个custom.html文件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 \u0026lt;script\u0026gt; const cdnPath = \u0026#39;https://cdn.jsdelivr.net/gh/letere-gzj/live2d-widget-v3@main\u0026#39;; const config = { // 资源路径 path: { modelPath: cdnPath + \u0026#34;/Resources/\u0026#34;, cssPath: cdnPath + \u0026#34;/waifu.css\u0026#34;, tipsJsonPath: cdnPath + \u0026#34;/waifu-tips.json\u0026#34;, tipsJsPath: cdnPath + \u0026#34;/waifu-tips.js\u0026#34;, live2dCorePath: cdnPath + \u0026#34;/Core/live2dcubismcore.js\u0026#34;, live2dSdkPath: cdnPath + \u0026#34;/live2d-sdk.js\u0026#34; }, // 工具栏 tools: [\u0026#34;hitokoto\u0026#34;, \u0026#34;asteroids\u0026#34;, \u0026#34;express\u0026#34;, \u0026#34;switch-model\u0026#34;, \u0026#34;switch-texture\u0026#34;, \u0026#34;info\u0026#34;, \u0026#34;quit\u0026#34;], // 模型拖拽 drag: { enable: true, direction: [\u0026#34;x\u0026#34;, \u0026#34;y\u0026#34;] }, // 模型切换(order: 顺序切换，random: 随机切换) switchType: \u0026#34;order\u0026#34; } // 加载资源并初始化 if (screen.width \u0026gt;= 768) { Promise.all([ loadExternalResource(config.path.cssPath, \u0026#34;css\u0026#34;), loadExternalResource(config.path.live2dCorePath, \u0026#34;js\u0026#34;), loadExternalResource(config.path.live2dSdkPath, \u0026#34;js\u0026#34;), loadExternalResource(config.path.tipsJsPath, \u0026#34;js\u0026#34;) ]).then(() =\u0026gt; { initWidget({ waifuPath: config.path.tipsJsonPath, cdnPath: config.path.modelPath, tools: config.tools, dragEnable: config.drag.enable, dragDirection: config.drag.direction, switchType: config.switchType }); }); } // 异步加载资源 function loadExternalResource(url, type) { return new Promise((resolve, reject) =\u0026gt; { let tag; if (type === \u0026#34;css\u0026#34;) { tag = document.createElement(\u0026#34;link\u0026#34;); tag.rel = \u0026#34;stylesheet\u0026#34;; tag.href = url; } else if (type === \u0026#34;js\u0026#34;) { tag = document.createElement(\u0026#34;script\u0026#34;); tag.src = url; } if (tag) { tag.onload = () =\u0026gt; resolve(url); tag.onerror = () =\u0026gt; reject(url); document.head.appendChild(tag); } }); } \u0026lt;/script\u0026gt; 这样你就能看到live2d小人出现在你的网站中了！\n字体与鼠标样式\r这两个我都没弄，但想要更华丽的网站的朋友们可以参考一下，首先是字体，先下载一个自己喜欢的字体，网站：100font.com - 免费商用字体大全 - 免费字体下载网站\n下载解压到根目录下assets/font目录下，不存在自己创建。还是在上面（梅开三度）custom.html文件中添加：\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;style\u0026gt; @font-face { font-family: \u0026#39;字体名\u0026#39;; src: url({{ (resources.Get \u0026#34;font/字体文件名\u0026#34;).Permalink }}) format(\u0026#39;truetype\u0026#39;); } :root { --base-font-family: \u0026#39;字体名\u0026#39;; --code-font-family: \u0026#39;字体名\u0026#39;; } \u0026lt;/style\u0026gt; 然后就有了如下的效果（这里我用的是鼎列珠海字体）：\n下面是鼠标指针，首先需要准备你需要的不同状态的鼠标指针图片（默认，文本，指针，加载等），然后将这些图片放在根目录的static/mouse文件夹下，自己创建。\n接下来修改主题目录下的assets/scss/custom.scss（不存在自己创建），可以使用下面这个代码，适用于stack主题：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // 【Stack主题鼠标样式写法】 // default光标图片 body, html, .article-content img { cursor: url(../mouse/默认光标图片名), auto !important; } // pointer光标图片 a:hover, button:hover, .copyCodeButton:hover, #dark-mode-toggle { cursor: url(../mouse/指针光标图片名), auto; } // text光标图片 input:hover, .site-description, .article-subtitle, .article-content span, .article-content li, .article-content p { cursor: url(../mouse/文本光标图片名), auto; } 这样就能实现更改鼠标指针样式了，经测试，png,cur文件都是可以的。\n其它小细节\r文章目录折叠\r有时候，文章目录非常庞大，比如我那篇编译原理复习，这时就可以采用目录折叠，只有在到指定位置时才展开目录，只需在custom.html（梅开四度）中添加：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 \u0026lt;style\u0026gt; #TableOfContents \u0026gt; ul, ol { ul, ol { display: none; } .open { display: block; } } \u0026lt;/style\u0026gt; \u0026lt;script\u0026gt; function initTocHide() { // 判断是否存在文章目录 let toc = document.querySelector(\u0026#34;.widget--toc\u0026#34;); if (!toc) { return; } // 监听滚动 window.addEventListener(\u0026#39;scroll\u0026#39;, function() { //清除class值 let openUl = document.querySelectorAll(\u0026#34;.open\u0026#34;); if (openUl.length \u0026gt; 0) { openUl.forEach((ul) =\u0026gt; { ul.classList.remove(\u0026#34;open\u0026#34;) }) } // 获取active-class let currentLi = document.querySelector(\u0026#34;.active-class\u0026#34;); if (!currentLi) { return } // 展示子ul if (currentLi.children.length \u0026gt; 1) { currentLi.children[1].classList.add(\u0026#34;open\u0026#34;) } // 展示父ul let ul = currentLi.parentElement; do { ul.classList.add(\u0026#34;open\u0026#34;); ul = ul.parentElement.parentElement } while (ul !== undefined \u0026amp;\u0026amp; (ul.localName === \u0026#39;ul\u0026#39; || ul.localName === \u0026#39;ol\u0026#39;)) }); } initTocHide() \u0026lt;/script\u0026gt; 返回顶部按钮\r在上面的图标下载网站中选择一张你喜欢的返回顶部按钮，放在assets/icons中（自行创建），在custom.html中添加：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 \u0026lt;style\u0026gt; #backTopBtn { display: none; position: fixed; bottom: 30px; z-index: 99; cursor: pointer; width: 30px; height: 30px; background-image: url({{ (resources.Get \u0026#34;icons/图标名字.svg\u0026#34;).Permalink }}); } \u0026lt;/style\u0026gt; \u0026lt;script\u0026gt; /** * 滚动回顶部初始化 */ function initScrollTop() { let rightSideBar = document.querySelector(\u0026#34;.right-sidebar\u0026#34;); if (!rightSideBar) { return; } // 添加返回顶部按钮到右侧边栏 let btn = document.createElement(\u0026#34;div\u0026#34;); btn.id = \u0026#34;backTopBtn\u0026#34;; btn.onclick = backToTop rightSideBar.appendChild(btn) // 滚动监听 window.onscroll = function() { // 当网页向下滑动 20px 出现\u0026#34;返回顶部\u0026#34; 按钮 if (document.body.scrollTop \u0026gt; 20 || document.documentElement.scrollTop \u0026gt; 20) { btn.style.display = \u0026#34;block\u0026#34;; } else { btn.style.display = \u0026#34;none\u0026#34;; } }; } /** * 返回顶部 */ function backToTop(){ window.scrollTo({ top: 0, behavior: \u0026#34;smooth\u0026#34; }) } initScrollTop(); \u0026lt;/script\u0026gt; 引用块模版\r我自己平时写md文件用的typora，里面有不同的警示框，用不同颜色表示，但在网页上没有，于是自己手动添加：\n创建文件layouts/_default/_markup/render-blockquote-alert.html，并将以下代码复制进去：\n1 2 3 \u0026lt;blockquote class=\u0026#34;alert alert-{{ .AlertType }}\u0026#34;\u0026gt; {{ .Text | safeHTML -}} \u0026lt;/blockquote\u0026gt; 将以下代码复制进assets/scss/custom.scss文件中：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 [data-scheme=\u0026#34;light\u0026#34;] { .alert-note { --card-separator-color: #65bbee; --blockquote-background-color: #e7f2fa; } .alert-tip { --card-separator-color: #55aa55; --blockquote-background-color: #eeffee; } .alert-important { --card-separator-color: #db75f2; --blockquote-background-color: #feeeff; } .alert-warning { --card-separator-color: #ffbb78; --blockquote-background-color: #ffeecc; } .alert-caution { --card-separator-color: #cc3334; --blockquote-background-color: #ffeeef; } } [data-scheme=\u0026#34;dark\u0026#34;] { .alert-note { --card-separator-color: #006699; --blockquote-background-color: #002234; } .alert-tip { --card-separator-color: #336733; --blockquote-background-color: #112310; } .alert-important { --card-separator-color: #7e1f91; --blockquote-background-color: #331111; } .alert-warning { --card-separator-color: #aa5501; --blockquote-background-color: #452300; } .alert-caution { --card-separator-color: #880000; --blockquote-background-color: #450000; } } 然后试一下：\n这是NOTE\n这是TIP\n这是WARNING\n这是IMPORTANT\n这是CAUTION\n如果你还想添加别的，同理的操作方法在custom.scss文件中添加即可。\n代码折叠\u0026amp;展开\r和上面返回顶部一样的操作，准备一张展开的图片，放在icons文件夹下，在custom.html文件中添加：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 \u0026lt;style\u0026gt; .highlight { /* 你可以根据需要调整这个高度 */ max-height: 400px; overflow: hidden; } .code-show { max-height: none !important; } .code-more-box { width: 100%; padding-top: 78px; background-image: -webkit-gradient(linear, left top, left bottom, from(rgba(255, 255, 255, 0)), to(#fff)); position: absolute; left: 0; right: 0; bottom: 0; z-index: 1; } .code-more-btn { display: block; margin: auto; width: 44px; height: 22px; background: #f0f0f5; border-top-left-radius: 8px; border-top-right-radius: 8px; padding-top: 6px; cursor: pointer; } .code-more-img { cursor: pointer !important; display: block; margin: auto; width: 22px; height: 16px; } \u0026lt;/style\u0026gt; \u0026lt;script\u0026gt; function initCodeMoreBox() { let codeBlocks = document.querySelectorAll(\u0026#34;.highlight\u0026#34;); if (!codeBlocks) { return; } codeBlocks.forEach(codeBlock =\u0026gt; { // 校验是否overflow if (codeBlock.scrollHeight \u0026lt;= codeBlock.clientHeight) { return; } // 元素初始化 // codeMoreBox let codeMoreBox = document.createElement(\u0026#39;div\u0026#39;); codeMoreBox.classList.add(\u0026#39;code-more-box\u0026#39;); // codeMoreBtn let codeMoreBtn = document.createElement(\u0026#39;span\u0026#39;); codeMoreBtn.classList.add(\u0026#39;code-more-btn\u0026#39;); codeMoreBtn.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { codeBlock.classList.add(\u0026#39;code-show\u0026#39;); codeMoreBox.style.display = \u0026#39;none\u0026#39;; }) // img let img = document.createElement(\u0026#39;img\u0026#39;); img.classList.add(\u0026#39;code-more-img\u0026#39;); img.src = {{ (resources.Get \u0026#34;icons/codeMore.png\u0026#34;).Permalink }} // 元素添加 codeMoreBtn.appendChild(img); codeMoreBox.appendChild(codeMoreBtn); codeBlock.appendChild(codeMoreBox) }) } initCodeMoreBox(); \u0026lt;/script\u0026gt; 感谢莱特雷大佬的分享：【Hugo】Stack主题自定义修改\n","date":"2025-01-25T14:00:52+08:00","image":"http://localhost:1313/post/003.png","permalink":"http://localhost:1313/p/hugo-stack-build-02/","title":"建站经验[二]stack主题基本美化操作"},{"content":" 写在前面：在一次稀松平常的复习当中，我在查找相关资料时发现了一篇博客，不同于之前常见的CSDN，知乎与博客网等，那篇博客界面简洁清晰，还十分美观，后面我又发现了博主是自己搭建的属于自己的博客，相当于个人主页加微型社区了，我当时就对其十分感兴趣，于是在期末考试周硬生生完成了建站的基础工作并发布了第一篇博客，后续也是不断对其进行美化与建设。大多数个人博客建设者发布的第一篇博客都是记录建站经历的，那么秉承着“前人栽树，后人乘凉”的原则，这里我也将我在网上学习到的经验整合分享给大家，来尽可能少走弯路。\nGithub相关\r由于github可以免费托管网页并申请域名，因此，我们选择github存储博客源代码（也是大部分选择的），这里我认为你已经有了github账号，不然也很难看到这篇博客，如果实在没有，点击左侧栏目里的那个像猫一样的图标，花几分钟注册一个吧。\n创建新仓库用来存储博客源码，仓库名为{github用户名}.github.io，这样可以避免许多问题，比如我的github用户名为Zhuyh1139，那么就像下面这样：\n这里注意仓库要设为公开(public)，分支使用main。\n建完之后就可以先不用管了，接下来我们要进行hugo相关的工作了。\nHugo相关\r首先需要下载hugo，记得安装extend版本的，不然不支持sass/scss扩展，安装方法非常简单，如果你跟我一样是window系统（我是win11）那么可以直接在终端中输入：\n1 winget install Hugo.Hugo.Extended 如果你下载了别的类似pip等工具，可以考虑如下安装方法：\n1 choco install hugo-extended 1 scoop install hugo-extended 如果你是ubuntu系统等，可以按照官网的安装教程下载：\nInstallation | Hugo\n下载完成之后输入hugo version，如果显示有extended字样说明安装成功啦！\n接下来选择一款你喜欢的主题来作为网站基础样式，这里我选的是网上较多人用的stack，资料也相对多一点。\n我在下载主题时采用的是git clone一键安装，但后续我发现了问题，就是如果想使用自动部署hugo网页的话（也就是用github托管整个项目，自动hugo更新上面github.io仓库），会因为theme文件夹下git的是stack创作者的远程仓库，导致无法正常git push更新，因此这里我推荐直接下载：CaiJimmy/hugo-theme-stack: Card-style Hugo theme designed for bloggers\n下好的直接解压到theme文件夹下即可，然后把里面的hugo.yaml文件移到根目录下，像这样：\n这个hugo.yaml即是我们的网站配置文件，后续大多美化操作都需要涉及这个文件。\n再顺便介绍下其它几个常用的位置文件夹：\nassets：这个在根目录与主题文件夹中都有，存放背景图片，头像等； content：发布的博客，一般在下面同时创建post文件夹作为发布文件夹； static：根目录下，存放md文件中的图片； public：需上传github的文件夹，需要和我们的远程仓库关联。 这个static存放的东西会同步到public里面，而assets里面的一般都是和主题相关的。\n接下来就可以使用指令（根目录下）：\n1 hugo new post/index.md 来创建属于自己的第一篇博客了，此时你会在content/post下面看到index.md文件，而且文件头会有：\n1 2 3 4 5 6 --- title:xxx . . . --- 这样的字样，这就表明成功了，然后在根目录终端输入：\n1 hugo server -D 来进行网页渲染，它会返回一个网址，直接打开即可，你就能看到当前的效果了，这个只要你对目录下任何一个文件修改了都会重新渲染输出，对于测试以及美化来说非常好用。\n上面我们说到了public文件夹要关联到远程仓库，下面是具体步骤：\n1 2 3 4 5 6 cd public git init git remote add origin 仓库地址.git git add . git commit -m \u0026#34;create\u0026#34; git push origin main 其中，关于git的操作这里不多详细讲解，感兴趣的可以自行上网搜索学习。\n然后，等待几分钟，就可以通过访问{你的github用户名}.github.io来看到你的个人博客啦。\n至此，就已经完成了最基础的建站操作了，后面我会发布美化与其它功能的介绍。\n","date":"2025-01-24T20:16:00+08:00","image":"http://localhost:1313/post/002.png","permalink":"http://localhost:1313/p/hugo-stack-build-01/","title":"建站经验[一]利用github加hugo搭建属于自己的博客"},{"content":"此为笔者编译原理实验所做，仅供学习交流使用。\n环境：ubuntu 22.04\n相关配置: LLVM,Clang,Git,build-essential,Cmake,Flex,Bison,GDB\n上述环境与软件配置这里不做过多介绍\n完整项目：Zhuyh1139/Compiler: This is ustc 2024 fall compiler course labs.\n代码解释都在注释中，就不费篇幅了。\n词法分析器\r即用正则表达式的形式将Cminusf进行分词操作：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 %option noyywrap %{ /*****************声明和选项设置 begin*****************/ #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026#34;syntax_tree.h\u0026#34; #include \u0026#34;syntax_analyzer.h\u0026#34; int lines=1; int pos_start=1; int pos_end=1; void pass_node(char *text){ yylval.node = new_syntax_tree_node(text); } /*****************声明和选项设置 end*****************/ %} %x COMMENT %% /* to do for students */ /* two cases for you, pass_node will send flex\u0026#39;s token to bison */ \\+ {pos_start = pos_end; pos_end += 1; pass_node(yytext); return ADD;} /****请在此补全所有flex的模式与动作 end******/ \\-\t{pos_start = pos_end; pos_end += 1; pass_node(yytext); return SUB;} \\*\t{pos_start = pos_end; pos_end += 1; pass_node(yytext); return MUL;} \\/\t{pos_start = pos_end; pos_end += 1; pass_node(yytext); return DIV;} \\\u0026lt;\t{pos_start = pos_end; pos_end += 1; pass_node(yytext); return LT;} \\\u0026lt;=\t{pos_start = pos_end; pos_end += 2; pass_node(yytext); return LTE;} \\\u0026gt;\t{pos_start = pos_end; pos_end += 1; pass_node(yytext); return GT;} \\\u0026gt;=\t{pos_start = pos_end; pos_end += 2; pass_node(yytext); return GTE;} ==\t{pos_start = pos_end; pos_end += 2; pass_node(yytext); return EQ;} !=\t{pos_start = pos_end; pos_end += 2; pass_node(yytext); return NEQ;} =\t{pos_start = pos_end; pos_end += 1; pass_node(yytext); return ASSIN;} ;\t{pos_start = pos_end; pos_end += 1; pass_node(yytext); return SEMICOLON;} ,\t{pos_start = pos_end; pos_end += 1; pass_node(yytext); return COMMA;} \\(\t{pos_start = pos_end; pos_end += 1; pass_node(yytext); return LPARENTHESE;} \\)\t{pos_start = pos_end; pos_end += 1; pass_node(yytext); return RPARENTHESE;} \\[\t{pos_start = pos_end; pos_end += 1; pass_node(yytext); return LBRACKET;} \\]\t{pos_start = pos_end; pos_end += 1; pass_node(yytext); return RBRACKET;} \\{\t{pos_start = pos_end; pos_end += 1; pass_node(yytext); return LBRACE;} \\}\t{pos_start = pos_end; pos_end += 1; pass_node(yytext); return RBRACE;} else\t{pos_start = pos_end; pos_end += 4; pass_node(yytext); return ELSE;} if\t{pos_start = pos_end; pos_end += 2; pass_node(yytext); return IF;} int\t{pos_start = pos_end; pos_end += 3; pass_node(yytext); return INT;} float {pos_start = pos_end; pos_end += 5; pass_node(yytext); return FLOAT;} return {pos_start = pos_end; pos_end += 6; pass_node(yytext); return RETURN;} void {pos_start = pos_end; pos_end += 4; pass_node(yytext); return VOID;} while {pos_start = pos_end; pos_end += 5; pass_node(yytext); return WHILE;} [a-zA-Z]+\t{pos_start = pos_end; pos_end += strlen(yytext); pass_node(yytext); return IDENTIFIER;} [0-9]+\t{pos_start = pos_end; pos_end += strlen(yytext); pass_node(yytext); return INTEGER;} [0-9]+\\.[0-9]*|[0-9]*\\.[0-9]+ { pos_start = pos_end; pos_end += strlen(yytext); pass_node(yytext); return FLOATPOINT;} \\n {lines++; pos_start = 1; pos_end = 1;} [ \\t] {pos_start = pos_end; pos_end += 1;} \u0026#34;/*\u0026#34; { pos_start = pos_end; pos_end += 2; BEGIN(COMMENT); } \u0026lt;COMMENT\u0026gt;\u0026#34;*/\u0026#34; { pos_start = pos_end; pos_end += 2; BEGIN(INITIAL); } \u0026lt;COMMENT\u0026gt;. { pos_start = pos_end; pos_start += 1; } \u0026lt;COMMENT\u0026gt;\\n { pos_start = 1; pos_end = 1; lines++; } . { pos_start = pos_end; pos_end++; return ERROR; } %% 其作用为：\n文本输入：\n1 void main(void) { return; } 输出：\n1 2 3 4 5 6 7 8 9 10 Token Text Line Column (Start,End) 282 void 1 (1,5) 284 main 1 (6,10) 272 ( 1 (10,11) 282 void 1 (11,15) 273 ) 1 (15,16) 276 { 1 (17,18) 281 return 1 (19,25) 270 ; 1 (25,26) 277 } 1 (27,28) 语法分析器\rCminusf的语法和C的语法大致相同：\nprogram→declaration-listprogram→declaration-list declaration-list→declaration-list declaration ∣ declarationdeclaration-list→declaration-list declaration ∣ declaration declaration→var-declaration ∣ fun-declarationdeclaration→var-declaration ∣ fun-declaration var-declaration →type-specifier ID‾ ;‾ ∣ type-specifier ID‾ [‾ INTEGER‾ ]‾ ;‾var-declaration →type-specifier ID ; ∣ type-specifier ID [ INTEGER ] ; type-specifier→int‾ ∣ float‾ ∣ void‾type-specifier→int ∣ float ∣ void fun-declaration→type-specifier ID‾ (‾ params )‾ compound-stmtfun-declaration→type-specifier ID ( params ) compound-stmt params→param-list ∣ void‾params→param-list ∣ void param-list→param-list ,‾ param ∣ paramparam-list→param-list , param ∣ param param→type-specifier ID‾ ∣ type-specifier ID‾ [‾ ]‾param→type-specifier ID ∣ type-specifier ID [ ] compound-stmt→{‾ local-declarations statement-list }‾compound-stmt→{ local-declarations statement-list } local-declarations→local-declarations var-declaration ∣ emptylocal-declarations→local-declarations var-declaration ∣ empty statement-list→statement-list statement ∣ emptystatement-list→statement-list statement ∣ empty statement→ expression-stmt∣ compound-stmt∣ selection-stmt∣ iteration-stmt∣ return-stmtstatement→ expression-stmt∣ compound-stmt∣ selection-stmt∣ iteration-stmt∣ return-stmt expression-stmt→expression ;‾ ∣ ;‾expression-stmt→expression ; ∣ ; selection-stmt→ if‾ (‾ expression )‾ statement∣ if‾ (‾ expression )‾ statement else‾ statementselection-stmt→ if ( expression ) statement∣ if ( expression ) statement else statement iteration-stmt→while‾ (‾ expression )‾ statementiteration-stmt→while ( expression ) statement return-stmt→return‾ ;‾ ∣ return‾ expression ;‾return-stmt→return ; ∣ return expression ; expression→var =‾ expression ∣ simple-expressionexpression→var = expression ∣ simple-expression var→ID‾ ∣ ID‾ [‾ expression]‾var→ID ∣ ID [ expression**]** simple-expression→additive-expression relop additive-expression ∣ additive-expressionsimple-expression→additive-expression relop additive-expression ∣ additive-expression relop →\u0026lt;=‾ ∣ \u0026lt;‾ ∣ \u0026gt;‾ ∣ \u0026gt;=‾ ∣ ==‾ ∣ !=‾relop →\u0026lt;= ∣ \u0026lt; ∣ \u0026gt; ∣ \u0026gt;= ∣ == ∣ != additive-expression→additive-expression addop term ∣ termadditive-expression→additive-expression addop term ∣ term addop→+‾ ∣ -‾addop→+ ∣ - term→term mulop factor ∣ factorterm→term mulop factor ∣ factor mulop→*‾ ∣ /‾mulop→***** ∣ / factor→(‾ expression )‾ ∣ var ∣ call ∣ integer ∣ floatfactor→( expression ) ∣ var ∣ call ∣ integer ∣ float integer→INTEGER‾integer→INTEGER float→FLOATPOINT‾float→FLOATPOINT call→ID‾ (‾ args)‾call→ID ( args**)** args→arg-list ∣ emptyargs→arg-list ∣ empty arg-list→arg-list ,‾ expression ∣ expressionarg-list→arg-list , expression ∣ expression 语法分析器可实现如下功能：\n输入：\n1 int main(void) { return 0; } 输出语法树：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 \u0026gt;--+ program | \u0026gt;--+ declaration-list | | \u0026gt;--+ declaration | | | \u0026gt;--+ fun-declaration | | | | \u0026gt;--+ type-specifier | | | | | \u0026gt;--* int | | | | \u0026gt;--* main | | | | \u0026gt;--* ( | | | | \u0026gt;--+ params | | | | | \u0026gt;--* void | | | | \u0026gt;--* ) | | | | \u0026gt;--+ compound-stmt | | | | | \u0026gt;--* { | | | | | \u0026gt;--+ local-declarations | | | | | | \u0026gt;--* epsilon | | | | | \u0026gt;--+ statement-list | | | | | | \u0026gt;--+ statement-list | | | | | | | \u0026gt;--* epsilon | | | | | | \u0026gt;--+ statement | | | | | | | \u0026gt;--+ return-stmt | | | | | | | | \u0026gt;--* return | | | | | | | | \u0026gt;--+ expression | | | | | | | | | \u0026gt;--+ simple-expression | | | | | | | | | | \u0026gt;--+ additive-expression | | | | | | | | | | | \u0026gt;--+ term | | | | | | | | | | | | \u0026gt;--+ factor | | | | | | | | | | | | | \u0026gt;--+ integer | | | | | | | | | | | | | | \u0026gt;--* 0 | | | | | | | | \u0026gt;--* ; | | | | | \u0026gt;--* } 具体代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 %{ #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdarg.h\u0026gt; #include \u0026#34;syntax_tree.h\u0026#34; // external functions from lex extern int yylex(); extern int yyparse(); extern int yyrestart(); extern FILE * yyin; // external variables from lexical_analyzer module extern int lines; extern char * yytext; extern int pos_end; extern int pos_start; // Global syntax tree syntax_tree *gt; // Error reporting void yyerror(const char *s); // Helper functions written for you with love syntax_tree_node *node(const char *node_name, int children_num, ...); %} /* TODO: Complete this definition. */ %union { struct _syntax_tree_node * node; char * name; } /* TODO: Your tokens here. */ %token \u0026lt;node\u0026gt; ERROR %token \u0026lt;node\u0026gt; ADD %token \u0026lt;node\u0026gt; SUB %token \u0026lt;node\u0026gt; MUL %token \u0026lt;node\u0026gt; DIV %token \u0026lt;node\u0026gt; LT %token \u0026lt;node\u0026gt; LTE %token \u0026lt;node\u0026gt; GT %token \u0026lt;node\u0026gt; GTE %token \u0026lt;node\u0026gt; EQ %token \u0026lt;node\u0026gt; NEQ %token \u0026lt;node\u0026gt; ASSIN %token \u0026lt;node\u0026gt; SEMICOLON %token \u0026lt;node\u0026gt; COMMA %token \u0026lt;node\u0026gt; LPARENTHESE %token \u0026lt;node\u0026gt; RPARENTHESE %token \u0026lt;node\u0026gt; LBRACKET %token \u0026lt;node\u0026gt; RBRACKET %token \u0026lt;node\u0026gt; LBRACE %token \u0026lt;node\u0026gt; RBRACE %token \u0026lt;node\u0026gt; ELSE %token \u0026lt;node\u0026gt; IF %token \u0026lt;node\u0026gt; INT %token \u0026lt;node\u0026gt; RETURN %token \u0026lt;node\u0026gt; VOID %token \u0026lt;node\u0026gt; WHILE %token \u0026lt;node\u0026gt; IDENTIFIER %token \u0026lt;node\u0026gt; INTEGER %token \u0026lt;node\u0026gt; FLOAT %token \u0026lt;node\u0026gt; FLOATPOINT\t// 这个是 float 类型的 token //%token \u0026lt;node\u0026gt; EOL //%token \u0026lt;node\u0026gt; BLANK //%token \u0026lt;node\u0026gt; COMMENT %type \u0026lt;node\u0026gt; program declaration-list declaration var-declaration type-specifier fun-declaration params param-list param compound-stmt local-declarations statement-list statement expression-stmt selection-stmt iteration-stmt return-stmt expression var simple-expression relop additive-expression addop term mulop factor integer float call args arg-list /* compulsory starting symbol */ %start program %% /* TODO: Your rules here. */ program : declaration-list {$$ = node( \u0026#34;program\u0026#34;, 1, $1); gt-\u0026gt;root = $$;} ; declaration-list : declaration-list declaration {$$ = node( \u0026#34;declaration-list\u0026#34;, 2, $1, $2);} |\tdeclaration {$$ = node( \u0026#34;declaration-list\u0026#34;, 1, $1);} ; declaration : var-declaration {$$ = node( \u0026#34;declaration\u0026#34;, 1, $1);} | fun-declaration {$$ = node( \u0026#34;declaration\u0026#34;, 1, $1);} ; var-declaration : type-specifier IDENTIFIER SEMICOLON {$$ = node( \u0026#34;var-declaration\u0026#34;, 3, $1, $2, $3);} | type-specifier IDENTIFIER LBRACKET INTEGER RBRACKET SEMICOLON {$$ = node( \u0026#34;var-declaration\u0026#34;, 6, $1, $2, $3, $4, $5, $6);} ; type-specifier : INT {$$ = node( \u0026#34;type-specifier\u0026#34;, 1, $1);} | FLOAT { $$ = node( \u0026#34;type-specifier\u0026#34;, 1, $1); } | VOID {$$ = node( \u0026#34;type-specifier\u0026#34;, 1, $1);} ; fun-declaration : type-specifier IDENTIFIER LPARENTHESE params RPARENTHESE compound-stmt {$$ = node( \u0026#34;fun-declaration\u0026#34;, 6, $1, $2, $3, $4, $5, $6);} ; params : param-list {$$ = node( \u0026#34;params\u0026#34;, 1, $1);} |\tVOID {$$ = node( \u0026#34;params\u0026#34;, 1, $1);} ; param-list : param-list COMMA param {$$ = node( \u0026#34;param-list\u0026#34;, 3, $1, $2, $3);} | param {$$ = node( \u0026#34;param-list\u0026#34;, 1, $1);} ; param : type-specifier IDENTIFIER {$$ = node( \u0026#34;param\u0026#34;, 2, $1, $2);} | type-specifier IDENTIFIER LBRACKET RBRACKET {$$ = node( \u0026#34;param\u0026#34;, 4, $1, $2, $3, $4);} ; compound-stmt : LBRACE local-declarations statement-list RBRACE {$$ = node( \u0026#34;compound-stmt\u0026#34;, 4, $1, $2, $3, $4);} ; local-declarations : local-declarations var-declaration {$$ = node( \u0026#34;local-declarations\u0026#34;, 2, $1, $2);} | {$$ = node( \u0026#34;local-declarations\u0026#34;,0);} ; statement-list : statement-list statement {$$ = node( \u0026#34;statement-list\u0026#34;, 2, $1, $2);} | {$$ = node( \u0026#34;statement-list\u0026#34;,0);} ; statement : expression-stmt {$$ = node( \u0026#34;statement\u0026#34;, 1, $1);} | compound-stmt {$$ = node( \u0026#34;statement\u0026#34;, 1, $1);} | selection-stmt {$$ = node( \u0026#34;statement\u0026#34;, 1, $1);} | iteration-stmt {$$ = node( \u0026#34;statement\u0026#34;, 1, $1);} | return-stmt {$$ = node( \u0026#34;statement\u0026#34;, 1, $1);} ; expression-stmt : expression SEMICOLON {$$ = node( \u0026#34;expression-stmt\u0026#34;, 2, $1, $2);} | SEMICOLON {$$ = node( \u0026#34;expression-stmt\u0026#34;, 1, $1);} ; selection-stmt : IF LPARENTHESE expression RPARENTHESE statement {$$ = node( \u0026#34;selection-stmt\u0026#34;, 5, $1, $2, $3, $4, $5);} | IF LPARENTHESE expression RPARENTHESE statement ELSE statement {$$ = node( \u0026#34;selection-stmt\u0026#34;, 7, $1, $2, $3, $4, $5, $6, $7);} ; iteration-stmt : WHILE LPARENTHESE expression RPARENTHESE statement {$$ = node( \u0026#34;iteration-stmt\u0026#34;, 5, $1, $2, $3, $4, $5);} ; return-stmt : RETURN SEMICOLON {$$ = node( \u0026#34;return-stmt\u0026#34;, 2, $1, $2);} | RETURN expression SEMICOLON {$$ = node( \u0026#34;return-stmt\u0026#34;, 3, $1, $2, $3);} ; expression : var ASSIN expression {$$ = node( \u0026#34;expression\u0026#34;, 3, $1, $2, $3);} | simple-expression {$$ = node( \u0026#34;expression\u0026#34;, 1, $1);} ; var : IDENTIFIER {$$ = node( \u0026#34;var\u0026#34;, 1, $1);} | IDENTIFIER LBRACKET expression RBRACKET {$$ = node( \u0026#34;var\u0026#34;, 4, $1, $2, $3, $4);} ; simple-expression : additive-expression relop additive-expression {$$ = node( \u0026#34;simple-expression\u0026#34;, 3, $1, $2, $3);} | additive-expression {$$ = node( \u0026#34;simple-expression\u0026#34;, 1, $1);} ; relop : LT {$$ = node( \u0026#34;relop\u0026#34;, 1, $1);} | LTE {$$ = node( \u0026#34;relop\u0026#34;, 1, $1);} | GT {$$ = node( \u0026#34;relop\u0026#34;, 1, $1);} | GTE {$$ = node( \u0026#34;relop\u0026#34;, 1, $1);} | EQ {$$ = node( \u0026#34;relop\u0026#34;, 1, $1);} | NEQ {$$ = node( \u0026#34;relop\u0026#34;, 1, $1);} ; additive-expression : additive-expression addop term {$$ = node( \u0026#34;additive-expression\u0026#34;, 3, $1, $2, $3);} | term {$$ = node( \u0026#34;additive-expression\u0026#34;, 1, $1);} ; addop : ADD {$$ = node( \u0026#34;addop\u0026#34;, 1, $1);} |\tSUB {$$ = node( \u0026#34;addop\u0026#34;, 1, $1);} ; term : term mulop factor {$$ = node( \u0026#34;term\u0026#34;, 3, $1, $2, $3);} | factor {$$ = node( \u0026#34;term\u0026#34;, 1, $1);} ; mulop : MUL {$$ = node( \u0026#34;mulop\u0026#34;, 1, $1);} |\tDIV {$$ = node( \u0026#34;mulop\u0026#34;, 1, $1);} ; factor : LPARENTHESE expression RPARENTHESE {$$ = node( \u0026#34;factor\u0026#34;, 3, $1, $2, $3);} |\tvar {$$ = node( \u0026#34;factor\u0026#34;, 1, $1);} |\tcall {$$ = node( \u0026#34;factor\u0026#34;, 1, $1);} |\tinteger {$$ = node( \u0026#34;factor\u0026#34;, 1, $1);} |\tfloat {$$ = node( \u0026#34;factor\u0026#34;, 1, $1);} ; integer : INTEGER {$$ = node( \u0026#34;integer\u0026#34;, 1, $1);} ; float : FLOATPOINT {$$ = node( \u0026#34;float\u0026#34;, 1, $1);} ; call : IDENTIFIER LPARENTHESE args RPARENTHESE {$$ = node( \u0026#34;call\u0026#34;, 4, $1, $2, $3, $4);} ; args : arg-list {$$ = node( \u0026#34;args\u0026#34;, 1, $1);} | {$$ = node( \u0026#34;args\u0026#34;, 0);} ; arg-list : arg-list COMMA expression {$$ = node( \u0026#34;arg-list\u0026#34;, 3, $1, $2, $3);} | expression {$$ = node( \u0026#34;arg-list\u0026#34;, 1, $1);} ; %% /// The error reporting function. void yyerror(const char * s) { // TO STUDENTS: This is just an example. // You can customize it as you like. fprintf(stderr, \u0026#34;error at line %d column %d: %s\\n\u0026#34;, lines, pos_start, s); } /// Parse input from file `input_path`, and prints the parsing results /// to stdout. If input_path is NULL, read from stdin. /// /// This function initializes essential states before running yyparse(). syntax_tree *parse(const char *input_path) { if (input_path != NULL) { if (!(yyin = fopen(input_path, \u0026#34;r\u0026#34;))) { fprintf(stderr, \u0026#34;[ERR] Open input file %s failed.\\n\u0026#34;, input_path); exit(1); } } else { yyin = stdin; } lines = pos_start = pos_end = 1; gt = new_syntax_tree(); yyrestart(yyin); yyparse(); return gt; } /// A helper function to quickly construct a tree node. /// /// e.g. $$ = node(\u0026#34;program\u0026#34;, 1, $1); syntax_tree_node *node(const char *name, int children_num, ...) { syntax_tree_node *p = new_syntax_tree_node(name); syntax_tree_node *child; // 这里表示 epsilon结点是通过 children_num == 0 来判断的 if (children_num == 0) { child = new_syntax_tree_node(\u0026#34;epsilon\u0026#34;); syntax_tree_add_child(p, child); } else { va_list ap; va_start(ap, children_num); for (int i = 0; i \u0026lt; children_num; ++i) { child = va_arg(ap, syntax_tree_node *); syntax_tree_add_child(p, child); } va_end(ap); } return p; } 语法树-\u0026gt;中间代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 #include \u0026#34;cminusf_builder.hpp\u0026#34; #include \u0026#34;BasicBlock.hpp\u0026#34; #include \u0026#34;Constant.hpp\u0026#34; #include \u0026#34;GlobalVariable.hpp\u0026#34; #include \u0026#34;Type.hpp\u0026#34; #include \u0026#34;Value.hpp\u0026#34; #include \u0026#34;ast.hpp\u0026#34; #include \u0026lt;cassert\u0026gt; #include \u0026lt;cstddef\u0026gt; #include \u0026lt;logging.hpp\u0026gt; #define CONST_FP(num) ConstantFP::get((float)num, module.get()) #define CONST_INT(num) ConstantInt::get(num, module.get()) // types Type *VOID_T; Type *INT1_T; Type *INT32_T; Type *INT32PTR_T; Type *FLOAT_T; Type *FLOATPTR_T; /* * use CMinusfBuilder::Scope to construct scopes * scope.enter: enter a new scope * scope.exit: exit current scope * scope.push: add a new binding to current scope * scope.find: find and return the value bound to the name123456 */ Value* CminusfBuilder::visit(ASTProgram \u0026amp;node) { VOID_T = module-\u0026gt;get_void_type(); INT1_T = module-\u0026gt;get_int1_type(); INT32_T = module-\u0026gt;get_int32_type(); INT32PTR_T = module-\u0026gt;get_int32_ptr_type(); FLOAT_T = module-\u0026gt;get_float_type(); FLOATPTR_T = module-\u0026gt;get_float_ptr_type(); Value *ret_val = nullptr; for (auto \u0026amp;decl : node.declarations) { ret_val = decl-\u0026gt;accept(*this);//调用对应的visit函数 } return ret_val; } Value* CminusfBuilder::visit(ASTNum \u0026amp;node) { // TODO: This function is empty now. // Add some code here. //如果是num，直接将值存入context.var if(node.type == TYPE_INT) context.var = ConstantInt::get(node.i_val, module.get()); else if(node.type == TYPE_FLOAT) context.var = ConstantFP::get(node.f_val, module.get()); return nullptr; } Value* CminusfBuilder::visit(ASTVarDeclaration \u0026amp;node) { // TODO: This function is empty now. // Add some code here. //vardeclaration-\u0026gt;type_specifier var;|vardeclaration-\u0026gt;type_specifier var[num]; //先处理type_specifier //这个node包括Id,num和type，id是变量名，num是数组大小，type是变量类型 Type *var_type; if(node.type == TYPE_INT) var_type = INT32_T; else if(node.type == TYPE_FLOAT) var_type = FLOAT_T; else var_type = VOID_T; //这里获取node.type得到类型 if(scope.in_global())//全局变量,用GlobalVariable { if(node.num == nullptr)//不是数组 { auto global_var = GlobalVariable::create(node.id,module.get(),var_type,false,ConstantZero::get(var_type, module.get())); scope.push(node.id, global_var); } else { auto *arrayType = ArrayType::get(var_type, node.num-\u0026gt;i_val);//node.num-\u0026gt;i_val是数组大小 auto global_var_array = GlobalVariable::create(node.id,module.get(),arrayType,false,ConstantZero::get(var_type, module.get())); scope.push(node.id, global_var_array); } } else //不是全局变量就用builder分配内存 { if(node.num == nullptr) { auto alloca = builder-\u0026gt;create_alloca(var_type); scope.push(node.id, alloca); } else { auto *arrayType = ArrayType::get(var_type, node.num-\u0026gt;i_val); auto alloca_array = builder-\u0026gt;create_alloca(arrayType); scope.push(node.id, alloca_array); } } return nullptr; } Value* CminusfBuilder::visit(ASTFunDeclaration \u0026amp;node) { //FunDeclaration-\u0026gt;type_specifier id(Params) CompoundStmt //node包括type,id,params,compound_stmt,分别是返回值类型，函数名，参数，函数体 FunctionType *fun_type; Type *ret_type; std::vector\u0026lt;Type *\u0026gt; param_types; if (node.type == TYPE_INT) ret_type = INT32_T; else if (node.type == TYPE_FLOAT) ret_type = FLOAT_T; else ret_type = VOID_T; //上面处理返回值类型，下面处理参数类型 for (auto \u0026amp;param : node.params) { //这里获得每个参数，进行处理 //param-\u0026gt;type,param-\u0026gt;id，类型和名称 // TODO: Please accomplish param_types. if(param-\u0026gt;isarray)//数组 { if(param-\u0026gt;type == TYPE_INT) { param_types.push_back(INT32PTR_T);//这里用ptr的类型存入向量 } else if(param-\u0026gt;type == TYPE_FLOAT) { param_types.push_back(FLOATPTR_T); } } else { if(param-\u0026gt;type == TYPE_INT) { param_types.push_back(INT32_T); } else if(param-\u0026gt;type == TYPE_FLOAT) { param_types.push_back(FLOAT_T); } } } //上面已经把参数类型存入了param_types中，下面创建函数 fun_type = FunctionType::get(ret_type, param_types); auto func = Function::create(fun_type, node.id, module.get()); scope.push(node.id, func);//将函数名和函数绑定 context.func = func;//存入context auto funBB = BasicBlock::create(module.get(), \u0026#34;entry\u0026#34;, func); builder-\u0026gt;set_insert_point(funBB);//设置插入点 scope.enter();//进入函数作用域 std::vector\u0026lt;Value *\u0026gt; args; for (auto \u0026amp;arg : func-\u0026gt;get_args()) { args.push_back(\u0026amp;arg);//将参数存入args } for (unsigned int i = 0; i \u0026lt; node.params.size(); ++i) {//处理参数 // TODO: You need to deal with params and store them in the scope. //由于param_types中存入了参数类型，所以这里只需要用对应参数名即可 //这里处理参数，将参数存入alloca中 auto alloca = builder-\u0026gt;create_alloca(param_types[i]); builder-\u0026gt;create_store(args[i], alloca); scope.push(node.params[i]-\u0026gt;id, alloca);//将变量存入作用域，确保在函数内部可以访问，同时在函数外部不可访问，及时清理避免变量冲突和内存泄漏 } node.compound_stmt-\u0026gt;accept(*this);//访问者模式，处理函数体 if (!(builder-\u0026gt;get_insert_block()-\u0026gt;is_terminated())) //如果没有返回值,则返回0 { if (context.func-\u0026gt;get_return_type()-\u0026gt;is_void_type()) builder-\u0026gt;create_void_ret();//void类型 else if (context.func-\u0026gt;get_return_type()-\u0026gt;is_float_type()) builder-\u0026gt;create_ret(CONST_FP(0.));//float类型 else builder-\u0026gt;create_ret(CONST_INT(0));//int类型 } scope.exit(); return nullptr; } Value* CminusfBuilder::visit(ASTParam \u0026amp;node) { // TODO: This function is empty now. // Add some code here. //上面已经处理了参数 return nullptr; } Value* CminusfBuilder::visit(ASTCompoundStmt \u0026amp;node) { // TODO: This function is not complete. // You may need to add some code here // to deal with complex statements. //compoundstmt-\u0026gt;{local_declarations statement_list} scope.enter(); //进入作用域，确保局部变量不会和全局变量冲突 for (auto \u0026amp;decl : node.local_declarations) { decl-\u0026gt;accept(*this);//处理局部变量 } for (auto \u0026amp;stmt : node.statement_list) { stmt-\u0026gt;accept(*this);//处理语句 if (builder-\u0026gt;get_insert_block()-\u0026gt;is_terminated()) break;//如果没有返回值，直接退出 } scope.exit();//处理完函数体，退出作用域 return nullptr; } Value* CminusfBuilder::visit(ASTExpressionStmt \u0026amp;node) { // TODO: This function is empty now. // Add some code here. //expressionstmt-\u0026gt;expressionstmt;|; if(node.expression != nullptr) node.expression-\u0026gt;accept(*this); return nullptr; } Value* CminusfBuilder::visit(ASTSelectionStmt \u0026amp;node) { // TODO: This function is empty now. // Add some code here. auto trueBB = BasicBlock::create(module.get(), \u0026#34;\u0026#34;, context.func); auto falseBB = BasicBlock::create(module.get(), \u0026#34;\u0026#34;, context.func); auto contBB = BasicBlock::create(module.get(), \u0026#34;\u0026#34;, context.func); Value * cond; node.expression-\u0026gt;accept(*this); if(context.var-\u0026gt;get_type()-\u0026gt;is_integer_type()) { cond = builder-\u0026gt;create_icmp_gt(context.var, CONST_INT(0)); } else { cond = builder-\u0026gt;create_fcmp_gt(context.var, CONST_FP(0.0)); } //上面创建了和0比较的指令，下面创建条件跳转 if(node.else_statement == nullptr) { builder-\u0026gt;create_cond_br(cond, trueBB, contBB); } else { builder-\u0026gt;create_cond_br(cond, trueBB, falseBB); } //如果有else语句，创建条件跳转，没有就跳转接下来的语句（contBB） builder-\u0026gt;set_insert_point(trueBB);//设置插入点，指定下面的语句在trueBB中 node.if_statement-\u0026gt;accept(*this); if(!builder-\u0026gt;get_insert_block()-\u0026gt;is_terminated())//如果没有返回值，创建一个跳转，避免出现多个返回值 { builder-\u0026gt;create_br(contBB); } if(node.else_statement == nullptr) { falseBB-\u0026gt;erase_from_parent();//不存在else删除falseBB } else { builder-\u0026gt;set_insert_point(falseBB); node.else_statement-\u0026gt;accept(*this); if(!builder-\u0026gt;get_insert_block()-\u0026gt;is_terminated()) { builder-\u0026gt;create_br(contBB); } } builder-\u0026gt;set_insert_point(contBB); return nullptr; } Value* CminusfBuilder::visit(ASTIterationStmt \u0026amp;node) { // TODO: This function is empty now. // Add some code here. //iterationstmt-\u0026gt;while(expression)statement auto condBB = BasicBlock::create(module.get(), \u0026#34;\u0026#34;, context.func); auto bodyBB = BasicBlock::create(module.get(), \u0026#34;\u0026#34;, context.func); auto afterBB = BasicBlock::create(module.get(), \u0026#34;\u0026#34;, context.func); //上面三个基本块，分别是条件判断，循环体，循环结束 Value * cond; if(!builder-\u0026gt;get_insert_block()-\u0026gt;is_terminated())//如果没终结，创建一个跳转 { builder-\u0026gt;create_br(condBB); } builder-\u0026gt;set_insert_point(condBB); node.expression-\u0026gt;accept(*this);//这里处理条件，context.var存储了表达式的值，下面和0比较 if(context.var-\u0026gt;get_type()-\u0026gt;is_integer_type()) { cond = builder-\u0026gt;create_icmp_gt(context.var, CONST_INT(0)); } else { cond = builder-\u0026gt;create_fcmp_gt(context.var, CONST_FP(0.0)); } builder-\u0026gt;create_cond_br(cond, bodyBB, afterBB); builder-\u0026gt;set_insert_point(bodyBB); node.statement-\u0026gt;accept(*this);//处理循环体 if(!builder-\u0026gt;get_insert_block()-\u0026gt;is_terminated()) { builder-\u0026gt;create_br(condBB);//如果没有返回值，创建一个跳转 } builder-\u0026gt;set_insert_point(afterBB); return nullptr; } Value* CminusfBuilder::visit(ASTReturnStmt \u0026amp;node) { //returnstmt-\u0026gt;return;|return expression; if (node.expression == nullptr) {//没有返回值，置为void builder-\u0026gt;create_void_ret(); return nullptr; } else { // TODO: The given code is incomplete. // You need to solve other return cases (e.g. return an integer). node.expression-\u0026gt;accept(*this); //这句处理完，context.var存储了返回值，context.func存储了之前函数的信息 // auto fun = builder-\u0026gt;get_insert_block()-\u0026gt;get_parent(); auto ret_type = context.func-\u0026gt;get_return_type(); //下面处理不一致的情况 if(ret_type-\u0026gt;is_float_type()) { if(context.var-\u0026gt;get_type()-\u0026gt;is_integer_type()) { context.var = builder-\u0026gt;create_sitofp(context.var, FLOAT_T); } builder-\u0026gt;create_ret(context.var); } else if(ret_type-\u0026gt;is_integer_type()) { if(context.var-\u0026gt;get_type()-\u0026gt;is_float_type()) { context.var = builder-\u0026gt;create_fptosi(context.var, INT32_T); } builder-\u0026gt;create_ret(context.var); } else if(ret_type-\u0026gt;is_void_type()) { builder-\u0026gt;create_void_ret(); } } return nullptr; } Value* CminusfBuilder::visit(ASTVar \u0026amp;node) { if(node.expression == nullptr)//不是数组 { auto var = scope.find(node.id);//在当前作用域中查找变量 assert(var!=nullptr); if(var-\u0026gt;get_type()-\u0026gt;is_pointer_type()) { if(var-\u0026gt;get_type()-\u0026gt;get_pointer_element_type()-\u0026gt;is_array_type()) { var = builder-\u0026gt;create_gep(var, {CONST_INT(0), CONST_INT(0)}); } else { // LOG(DEBUG)\u0026lt;\u0026lt;\u0026#34;var type is\u0026#34;\u0026lt;\u0026lt;var-\u0026gt;get_type()-\u0026gt;print(); if(builder-\u0026gt;create_load(var)-\u0026gt;get_type()-\u0026gt;is_pointer_type()) { var = builder-\u0026gt;create_load(var); } var = builder-\u0026gt;create_gep(var, {CONST_INT(0)}); // var = builder-\u0026gt;create_load(var); } //如果是指针，则返回第一个元素地址，数组就是[0][0],普通变量就是[0] } context.var_location = var;//把地址存入context.var_location context.var = builder-\u0026gt;create_load(context.var_location);//加载变量 } else { node.expression-\u0026gt;accept(*this);//处理数组索引 // auto fun = builder-\u0026gt;get_insert_block()-\u0026gt;get_parent(); Value* index; if(context.var-\u0026gt;get_type()-\u0026gt;is_float_type())//如果是浮点数，转换为整数 { index = builder-\u0026gt;create_fptosi(context.var, INT32_T); } else { index = context.var; } //下面处理负数索引 auto index_check = builder-\u0026gt;create_icmp_lt(index, CONST_INT(0)); //index_check是一个比较指令，判断index是否小于0 auto excpetBB = BasicBlock::create(module.get(), \u0026#34;\u0026#34;, context.func); //创建异常基本块，调用neg_idx_except auto normalBB = BasicBlock::create(module.get(), \u0026#34;\u0026#34;, context.func); builder-\u0026gt;create_cond_br(index_check, excpetBB, normalBB); builder-\u0026gt;set_insert_point(excpetBB); auto except = scope.find(\u0026#34;neg_idx_except\u0026#34;); builder-\u0026gt;create_call(except, {}); builder-\u0026gt;create_br(normalBB);//异常处理完，跳转到normalBB builder-\u0026gt;set_insert_point(normalBB); auto var_array = scope.find(node.id); Value* var_array_gep; if(var_array-\u0026gt;get_type()-\u0026gt;get_pointer_element_type()-\u0026gt;is_array_type()) { var_array_gep = builder-\u0026gt;create_gep(var_array, {CONST_INT(0), index}); } else { // LOG(DEBUG)\u0026lt;\u0026lt;\u0026#34;var_array type is\u0026#34;\u0026lt;\u0026lt;var_array-\u0026gt;get_type()-\u0026gt;print(); auto var_load= builder-\u0026gt;create_load(var_array); var_array_gep = builder-\u0026gt;create_gep(var_load, {index}); } context.var_location = var_array_gep; context.var = builder-\u0026gt;create_load(var_array_gep); } return nullptr; } Value* CminusfBuilder::visit(ASTAssignExpression \u0026amp;node) { // TODO: This function is empty now. // Add some code here. //assignexpression-\u0026gt;var=expression Value* var;//存储变量地址，用于加载出context.var Value* num;//存储var的值 node.var-\u0026gt;accept(*this); var = context.var_location; num = context.var; node.expression-\u0026gt;accept(*this); //这步处理完后context.var存储了表达式的值 if(num-\u0026gt;get_type() != context.var-\u0026gt;get_type()) { if(num-\u0026gt;get_type()-\u0026gt;is_integer_type()) { context.var = builder-\u0026gt;create_fptosi(context.var, INT32_T); } else if(num-\u0026gt;get_type()-\u0026gt;is_float_type()) { context.var = builder-\u0026gt;create_sitofp(context.var, FLOAT_T); } } //强制类型转换，转换为var的类型 builder-\u0026gt;create_store(context.var, var); return nullptr; } Value* CminusfBuilder::visit(ASTSimpleExpression \u0026amp;node) { // TODO: This function is empty now. // Add some code here. //simpleexpression-\u0026gt;additive_expression relop additive_expression node.additive_expression_l-\u0026gt;accept(*this); if(node.additive_expression_r != nullptr) { Value* lhs = context.var;//前面处理过左边的表达式，context.var存储了左边的值 node.additive_expression_r-\u0026gt;accept(*this); Value* rhs = context.var; if((lhs-\u0026gt;get_type()-\u0026gt;is_integer_type())\u0026amp;\u0026amp;(rhs-\u0026gt;get_type()-\u0026gt;is_integer_type())) //如果都是整型 { switch(node.op) { case OP_EQ : context.var = builder-\u0026gt;create_icmp_eq(lhs,rhs); break; case OP_GE : context.var = builder-\u0026gt;create_icmp_ge(lhs, rhs); break; case OP_GT : context.var = builder-\u0026gt;create_icmp_gt(lhs, rhs); break; case OP_LE : context.var = builder-\u0026gt;create_icmp_le(lhs, rhs); break; case OP_LT : context.var = builder-\u0026gt;create_icmp_lt(lhs, rhs); break; case OP_NEQ : context.var = builder-\u0026gt;create_icmp_ne(lhs, rhs); break; } } else { if(lhs-\u0026gt;get_type()-\u0026gt;is_integer_type()) { lhs = builder-\u0026gt;create_sitofp(lhs, FLOAT_T); } else if(rhs-\u0026gt;get_type()-\u0026gt;is_integer_type()) { rhs = builder-\u0026gt;create_sitofp(rhs, FLOAT_T); }//如果有一个是整型，转换为浮点型 switch(node.op) { case OP_EQ : context.var = builder-\u0026gt;create_fcmp_eq(lhs,rhs); break; case OP_GE : context.var = builder-\u0026gt;create_fcmp_ge(lhs, rhs); break; case OP_GT : context.var = builder-\u0026gt;create_fcmp_gt(lhs, rhs); break; case OP_LE : context.var = builder-\u0026gt;create_fcmp_le(lhs, rhs); break; case OP_LT : context.var = builder-\u0026gt;create_fcmp_lt(lhs, rhs); break; case OP_NEQ : context.var = builder-\u0026gt;create_fcmp_ne(lhs, rhs); break; } } context.var = builder-\u0026gt;create_zext(context.var, INT32_T);//转换为整型 } return nullptr; } Value* CminusfBuilder::visit(ASTAdditiveExpression \u0026amp;node) { // TODO: This function is empty now. // Add some code here. //additiveexpression-\u0026gt;additive_expression addop term|term if(node.additive_expression == nullptr) { node.term-\u0026gt;accept(*this); } else { node.additive_expression-\u0026gt;accept(*this); Value* lhs = context.var;//lhs存储左边additive_expression的值 node.term-\u0026gt;accept(*this); Value* rhs = context.var;//rhs存储term的值 if((lhs-\u0026gt;get_type()-\u0026gt;is_integer_type())\u0026amp;\u0026amp;(rhs-\u0026gt;get_type()-\u0026gt;is_integer_type())) { switch(node.op) { case OP_PLUS : context.var = builder-\u0026gt;create_iadd(lhs, rhs); break; case OP_MINUS: context.var = builder-\u0026gt;create_isub(lhs, rhs); break; } } else { if(lhs-\u0026gt;get_type()-\u0026gt;is_integer_type()) { lhs = builder-\u0026gt;create_sitofp(lhs, FLOAT_T); } else if(rhs-\u0026gt;get_type()-\u0026gt;is_integer_type()) { rhs = builder-\u0026gt;create_sitofp(rhs, FLOAT_T); } switch(node.op) { case OP_PLUS : context.var = builder-\u0026gt;create_fadd(lhs, rhs); break; case OP_MINUS: context.var = builder-\u0026gt;create_fsub(lhs, rhs); break; } } } return nullptr; } Value* CminusfBuilder::visit(ASTTerm \u0026amp;node) { // TODO: This function is empty now. // Add some code here. //term-\u0026gt;term mulop factor|factor if(node.term == nullptr) { node.factor-\u0026gt;accept(*this); } else//和前面类似 { node.term-\u0026gt;accept(*this); Value* lhs = context.var; node.factor-\u0026gt;accept(*this); Value* rhs = context.var; if((lhs-\u0026gt;get_type()-\u0026gt;is_integer_type())\u0026amp;\u0026amp;(rhs-\u0026gt;get_type()-\u0026gt;is_integer_type())) { switch(node.op) { case OP_MUL : context.var = builder-\u0026gt;create_imul(lhs, rhs); break; case OP_DIV : context.var = builder-\u0026gt;create_isdiv(lhs, rhs); break; } } else { if(lhs-\u0026gt;get_type()-\u0026gt;is_integer_type()) { lhs = builder-\u0026gt;create_sitofp(lhs, FLOAT_T); } else if(rhs-\u0026gt;get_type()-\u0026gt;is_integer_type()) { rhs = builder-\u0026gt;create_sitofp(rhs, FLOAT_T); } switch(node.op) { case OP_MUL : context.var = builder-\u0026gt;create_fmul(lhs, rhs); break; case OP_DIV : context.var = builder-\u0026gt;create_fdiv(lhs, rhs); break; } } } return nullptr; } Value* CminusfBuilder::visit(ASTCall \u0026amp;node) { // TODO: This function is empty now. // Add some code here. //call-\u0026gt;id(args) auto func = static_cast\u0026lt;Function*\u0026gt;(scope.find(node.id)); std::vector\u0026lt;Value*\u0026gt; args; auto param_type = func-\u0026gt;get_function_type()-\u0026gt;param_begin(); for(auto \u0026amp;arg : node.args) { arg-\u0026gt;accept(*this); if((*param_type)-\u0026gt;is_pointer_type()) { args.push_back(context.var_location); } else { if((*param_type)-\u0026gt;is_integer_type() \u0026amp;\u0026amp; context.var-\u0026gt;get_type()-\u0026gt;is_float_type()) { context.var = builder-\u0026gt;create_fptosi(context.var, INT32_T); args.push_back(context.var); } else if((*param_type)-\u0026gt;is_float_type() \u0026amp;\u0026amp; context.var-\u0026gt;get_type()-\u0026gt;is_integer_type()) { context.var = builder-\u0026gt;create_sitofp(context.var, FLOAT_T); args.push_back(context.var); } else { args.push_back(context.var); } } param_type++; } if (func-\u0026gt;get_function_type()-\u0026gt;get_num_of_args() != args.size()) { std::cerr \u0026lt;\u0026lt; \u0026#34;Error: Wrong number of arguments for function \u0026#34; \u0026lt;\u0026lt; node.id \u0026lt;\u0026lt; std::endl; return nullptr; } context.var = builder-\u0026gt;create_call(func, args); return nullptr; } 中间代码-\u0026gt;龙芯汇编\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 #include \u0026#34;CodeGen.hpp\u0026#34; #include \u0026#34;ASMInstruction.hpp\u0026#34; #include \u0026#34;CodeGenUtil.hpp\u0026#34; #include \u0026#34;Instruction.hpp\u0026#34; #include \u0026#34;Register.hpp\u0026#34; #include \u0026lt;cassert\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;logging.hpp\u0026gt; void CodeGen::allocate() { // 备份 $ra $fp unsigned offset = PROLOGUE_OFFSET_BASE; // 为每个参数分配栈空间 for (auto \u0026amp;arg : context.func-\u0026gt;get_args()) { auto size = arg.get_type()-\u0026gt;get_size(); offset = offset + size; context.offset_map[\u0026amp;arg] = -static_cast\u0026lt;int\u0026gt;(offset); } // 为指令结果分配栈空间 for (auto \u0026amp;bb : context.func-\u0026gt;get_basic_blocks()) { for (auto \u0026amp;instr : bb.get_instructions()) { // 每个非 void 的定值都分配栈空间 if (not instr.is_void()) { auto size = instr.get_type()-\u0026gt;get_size(); offset = offset + size; context.offset_map[\u0026amp;instr] = -static_cast\u0026lt;int\u0026gt;(offset); } // alloca 的副作用：分配额外空间 if (instr.is_alloca()) { auto *alloca_inst = static_cast\u0026lt;AllocaInst *\u0026gt;(\u0026amp;instr); auto alloc_size = alloca_inst-\u0026gt;get_alloca_type()-\u0026gt;get_size(); offset += alloc_size; } } } // 分配栈空间，需要是 16 的整数倍 context.frame_size = ALIGN(offset, PROLOGUE_ALIGN); } void CodeGen::copy_stmt() { for (auto \u0026amp;succ : context.bb-\u0026gt;get_succ_basic_blocks()) { for (auto \u0026amp;inst : succ-\u0026gt;get_instructions()) { if (inst.is_phi()) { // 遍历后继块中 phi 的定值 bb for (unsigned i = 1; i \u0026lt; inst.get_operands().size(); i += 2) { // phi 的定值 bb 是当前翻译块 if (inst.get_operand(i) == context.bb) { auto *lvalue = inst.get_operand(i - 1); if (lvalue-\u0026gt;get_type()-\u0026gt;is_float_type()) { load_to_freg(lvalue, FReg::fa(0)); store_from_freg(\u0026amp;inst, FReg::fa(0)); } else { load_to_greg(lvalue, Reg::a(0)); store_from_greg(\u0026amp;inst, Reg::a(0)); } break; } // 如果没有找到当前翻译块，说明是 undef，无事可做 } } else { break; } } } } void CodeGen::load_to_greg(Value *val, const Reg \u0026amp;reg) { assert(val-\u0026gt;get_type()-\u0026gt;is_integer_type() || val-\u0026gt;get_type()-\u0026gt;is_pointer_type()); if (auto *constant = dynamic_cast\u0026lt;ConstantInt *\u0026gt;(val)) { int32_t val = constant-\u0026gt;get_value(); if (IS_IMM_12(val)) { append_inst(ADDI WORD, {reg.print(), \u0026#34;$zero\u0026#34;, std::to_string(val)}); } else { load_large_int32(val, reg); } } else if (auto *global = dynamic_cast\u0026lt;GlobalVariable *\u0026gt;(val)) { append_inst(LOAD_ADDR, {reg.print(), global-\u0026gt;get_name()}); } else { load_from_stack_to_greg(val, reg); } } void CodeGen::load_large_int32(int32_t val, const Reg \u0026amp;reg) { int32_t high_20 = val \u0026gt;\u0026gt; 12; // si20 uint32_t low_12 = val \u0026amp; LOW_12_MASK; append_inst(LU12I_W, {reg.print(), std::to_string(high_20)}); append_inst(ORI, {reg.print(), reg.print(), std::to_string(low_12)}); } void CodeGen::load_large_int64(int64_t val, const Reg \u0026amp;reg) { auto low_32 = static_cast\u0026lt;int32_t\u0026gt;(val \u0026amp; LOW_32_MASK); load_large_int32(low_32, reg); auto high_32 = static_cast\u0026lt;int32_t\u0026gt;(val \u0026gt;\u0026gt; 32); int32_t high_32_low_20 = (high_32 \u0026lt;\u0026lt; 12) \u0026gt;\u0026gt; 12; // si20 int32_t high_32_high_12 = high_32 \u0026gt;\u0026gt; 20; // si12 append_inst(LU32I_D, {reg.print(), std::to_string(high_32_low_20)}); append_inst(LU52I_D, {reg.print(), reg.print(), std::to_string(high_32_high_12)}); } void CodeGen::load_from_stack_to_greg(Value *val, const Reg \u0026amp;reg) { auto offset = context.offset_map.at(val); auto offset_str = std::to_string(offset); auto *type = val-\u0026gt;get_type(); if (IS_IMM_12(offset)) { if (type-\u0026gt;is_int1_type()) { append_inst(LOAD BYTE, {reg.print(), \u0026#34;$fp\u0026#34;, offset_str}); } else if (type-\u0026gt;is_int32_type()) { append_inst(LOAD WORD, {reg.print(), \u0026#34;$fp\u0026#34;, offset_str}); } else { // Pointer append_inst(LOAD DOUBLE, {reg.print(), \u0026#34;$fp\u0026#34;, offset_str}); } } else { load_large_int64(offset, reg); append_inst(ADD DOUBLE, {reg.print(), \u0026#34;$fp\u0026#34;, reg.print()}); if (type-\u0026gt;is_int1_type()) { append_inst(LOAD BYTE, {reg.print(), reg.print(), \u0026#34;0\u0026#34;}); } else if (type-\u0026gt;is_int32_type()) { append_inst(LOAD WORD, {reg.print(), reg.print(), \u0026#34;0\u0026#34;}); } else { // Pointer append_inst(LOAD DOUBLE, {reg.print(), reg.print(), \u0026#34;0\u0026#34;}); } } } void CodeGen::store_from_greg(Value *val, const Reg \u0026amp;reg) { auto offset = context.offset_map.at(val); auto offset_str = std::to_string(offset); auto *type = val-\u0026gt;get_type(); if (IS_IMM_12(offset)) { if (type-\u0026gt;is_int1_type()) { append_inst(STORE BYTE, {reg.print(), \u0026#34;$fp\u0026#34;, offset_str}); } else if (type-\u0026gt;is_int32_type()) { append_inst(STORE WORD, {reg.print(), \u0026#34;$fp\u0026#34;, offset_str}); } else { // Pointer append_inst(STORE DOUBLE, {reg.print(), \u0026#34;$fp\u0026#34;, offset_str}); } } else { auto addr = Reg::t(8); load_large_int64(offset, addr); append_inst(ADD DOUBLE, {addr.print(), \u0026#34;$fp\u0026#34;, addr.print()}); if (type-\u0026gt;is_int1_type()) { append_inst(STORE BYTE, {reg.print(), addr.print(), \u0026#34;0\u0026#34;}); } else if (type-\u0026gt;is_int32_type()) { append_inst(STORE WORD, {reg.print(), addr.print(), \u0026#34;0\u0026#34;}); } else { // Pointer append_inst(STORE DOUBLE, {reg.print(), addr.print(), \u0026#34;0\u0026#34;}); } } } void CodeGen::load_to_freg(Value *val, const FReg \u0026amp;freg) { assert(val-\u0026gt;get_type()-\u0026gt;is_float_type()); if (auto *constant = dynamic_cast\u0026lt;ConstantFP *\u0026gt;(val)) { float val = constant-\u0026gt;get_value(); load_float_imm(val, freg); } else { auto offset = context.offset_map.at(val); auto offset_str = std::to_string(offset); if (IS_IMM_12(offset)) { append_inst(FLOAD SINGLE, {freg.print(), \u0026#34;$fp\u0026#34;, offset_str}); } else { auto addr = Reg::t(8); load_large_int64(offset, addr); append_inst(ADD DOUBLE, {addr.print(), \u0026#34;$fp\u0026#34;, addr.print()}); append_inst(FLOAD SINGLE, {freg.print(), addr.print(), \u0026#34;0\u0026#34;}); } } } void CodeGen::load_float_imm(float val, const FReg \u0026amp;r) { int32_t bytes = *reinterpret_cast\u0026lt;int32_t *\u0026gt;(\u0026amp;val); load_large_int32(bytes, Reg::t(8)); append_inst(GR2FR WORD, {r.print(), Reg::t(8).print()}); } void CodeGen::store_from_freg(Value *val, const FReg \u0026amp;r) { auto offset = context.offset_map.at(val); if (IS_IMM_12(offset)) { auto offset_str = std::to_string(offset); append_inst(FSTORE SINGLE, {r.print(), \u0026#34;$fp\u0026#34;, offset_str}); } else { auto addr = Reg::t(8); load_large_int64(offset, addr); append_inst(ADD DOUBLE, {addr.print(), \u0026#34;$fp\u0026#34;, addr.print()}); append_inst(FSTORE SINGLE, {r.print(), addr.print(), \u0026#34;0\u0026#34;}); } } void CodeGen::gen_prologue() { //该函数用来插入函数的序言 if (IS_IMM_12(-static_cast\u0026lt;int\u0026gt;(context.frame_size))) //上面这个用来判断当前栈帧大小是否在12位立即数范围内 { append_inst(\u0026#34;st.d $ra, $sp, -8\u0026#34;); append_inst(\u0026#34;st.d $fp, $sp, -16\u0026#34;); append_inst(\u0026#34;addi.d $fp, $sp, 0\u0026#34;); append_inst(\u0026#34;addi.d $sp, $sp, \u0026#34; + std::to_string(-static_cast\u0026lt;int\u0026gt;(context.frame_size))); } else { load_large_int64(context.frame_size, Reg::t(0)); append_inst(\u0026#34;st.d $ra, $sp, -8\u0026#34;); append_inst(\u0026#34;st.d $fp, $sp, -16\u0026#34;); append_inst(\u0026#34;sub.d $sp, $sp, $t0\u0026#34;); append_inst(\u0026#34;add.d $fp, $sp, $t0\u0026#34;); } int garg_cnt = 0; int farg_cnt = 0; //初始化两个计数器，分别用于整数/指针类型参数和浮点类型参数的寄存器索引 for (auto \u0026amp;arg : context.func-\u0026gt;get_args()) { //遍历当前函数所有参数，如果是main传的为void就没有参数 if (arg.get_type()-\u0026gt;is_float_type()) { store_from_freg(\u0026amp;arg, FReg::fa(farg_cnt++)); } else { // int or pointer store_from_greg(\u0026amp;arg, Reg::a(garg_cnt++)); } } //先将参数传入栈帧中，以便在函数体内部可以正确访问这些参数 } void CodeGen::gen_epilogue() { // TODO 根据你的理解设定函数的 epilogue // throw not_implemented_error{__FUNCTION__}; append_inst(func_exit_label_name(context.func),ASMInstruction::Label); if(IS_IMM_12(context.frame_size)) { append_inst(\u0026#34;addi.d $sp, $sp, \u0026#34; + std::to_string(context.frame_size)); append_inst(\u0026#34;ld.d $ra, $sp, -8\u0026#34;); append_inst(\u0026#34;ld.d $fp, $sp, -16\u0026#34;); append_inst(\u0026#34;jr $ra\u0026#34;); } else { load_large_int64(context.frame_size, Reg::t(0)); append_inst(\u0026#34;addi.d $sp, $sp, $t0\u0026#34;); append_inst(\u0026#34;ld.d $ra, $sp, -8\u0026#34;); append_inst(\u0026#34;ld.d $fp, $sp, -16\u0026#34;); append_inst(\u0026#34;jr $ra\u0026#34;); } } void CodeGen::gen_ret() { // TODO 函数返回，思考如何处理返回值、寄存器备份，如何返回调用者地址 // throw not_implemented_error{__FUNCTION__}; //ReturnInst(Value *val, BasicBlock *bb); auto *retInst = static_cast\u0026lt;ReturnInst *\u0026gt;(context.inst); if(retInst-\u0026gt;is_void_ret()) { // gen_epilogue(); append_inst(\u0026#34;addi.w\u0026#34;,{\u0026#34;$a0\u0026#34;, \u0026#34;$zero\u0026#34;, \u0026#34;0\u0026#34;}); append_inst(\u0026#34;b \u0026#34; + func_exit_label_name(context.func)); } else { auto *retValue = retInst-\u0026gt;get_operand(0); if(retValue-\u0026gt;get_type()-\u0026gt;is_float_type()) { load_to_freg(retValue, FReg::fa(0)); } else if(retValue-\u0026gt;get_type()-\u0026gt;is_integer_type()) { load_to_greg(retValue, Reg::a(0)); } else { assert(false); } append_inst(\u0026#34;b \u0026#34; + func_exit_label_name(context.func)); // gen_epilogue(); } } void CodeGen::gen_br() { //BranchInst(Value *cond, BasicBlock *if_true, BasicBlock *if_false,BasicBlock *bb); auto *branchInst = static_cast\u0026lt;BranchInst *\u0026gt;(context.inst); if (branchInst-\u0026gt;is_cond_br()) { // TODO 补全条件跳转的情况 // throw not_implemented_error{__FUNCTION__}; auto *truebb = static_cast\u0026lt;BasicBlock *\u0026gt;(branchInst-\u0026gt;get_operand(1)); auto *falsebb = static_cast\u0026lt;BasicBlock *\u0026gt;(branchInst-\u0026gt;get_operand(2)); auto *cond = branchInst-\u0026gt;get_condition(); if (cond-\u0026gt;get_type()-\u0026gt;is_float_type()) { load_to_freg(cond, FReg::ft(0)); load_float_imm(0.0, FReg::ft(1)); append_inst(\u0026#34;fcmp.seq.s $fcc0, $ft0, $ft1\u0026#34;); //这句比较如果cond == 0,则fcc0 = 1,cond == 1,则fcc0 = 0 append_inst(\u0026#34;bceqz $fcc0, \u0026#34; + label_name(truebb)); //判断fcc0是否为0，为0则跳转到truebb append_inst(\u0026#34;b \u0026#34; + label_name(falsebb)); } else { load_to_greg(cond, Reg::t(1)); append_inst(\u0026#34;beq $t1, $zero, \u0026#34; + label_name(falsebb)); append_inst(\u0026#34;b \u0026#34; + label_name(truebb)); } } else { auto *branchbb = static_cast\u0026lt;BasicBlock *\u0026gt;(branchInst-\u0026gt;get_operand(0)); append_inst(\u0026#34;b \u0026#34; + label_name(branchbb)); } } void CodeGen::gen_binary() { //Instruction(Type *ty, OpID id, BasicBlock *parent = nullptr); //IBinaryInst(OpID id, Value *v1, Value *v2, BasicBlock *bb); load_to_greg(context.inst-\u0026gt;get_operand(0), Reg::t(0)); load_to_greg(context.inst-\u0026gt;get_operand(1), Reg::t(1)); switch (context.inst-\u0026gt;get_instr_type()) { case Instruction::add: output.emplace_back(\u0026#34;add.w $t2, $t0, $t1\u0026#34;); break; case Instruction::sub: output.emplace_back(\u0026#34;sub.w $t2, $t0, $t1\u0026#34;); break; case Instruction::mul: output.emplace_back(\u0026#34;mul.w $t2, $t0, $t1\u0026#34;); break; case Instruction::sdiv: output.emplace_back(\u0026#34;div.w $t2, $t0, $t1\u0026#34;); break; default: assert(false); } store_from_greg(context.inst, Reg::t(2)); } void CodeGen::gen_float_binary() { // TODO 浮点类型的二元指令 // throw not_implemented_error{__FUNCTION__}; load_to_freg(context.inst-\u0026gt;get_operand(0), FReg::ft(0)); load_to_freg(context.inst-\u0026gt;get_operand(1), FReg::ft(1)); switch (context.inst-\u0026gt;get_instr_type()) { case Instruction::fadd: output.emplace_back(\u0026#34;fadd.s $ft2, $ft0, $ft1\u0026#34;); break; case Instruction::fsub: output.emplace_back(\u0026#34;fsub.s $ft2, $ft0, $ft1\u0026#34;); break; case Instruction::fmul: output.emplace_back(\u0026#34;fmul.s $ft2, $ft0, $ft1\u0026#34;); break; case Instruction::fdiv: output.emplace_back(\u0026#34;fdiv.s $ft2, $ft0, $ft1\u0026#34;); break; default: assert(false); } store_from_freg(context.inst, FReg::ft(2)); } void CodeGen::gen_alloca() { /* 我们已经为 alloca 的内容分配空间，在此我们还需保存 alloca * 指令自身产生的定值，即指向 alloca 空间起始地址的指针 */ // TODO 将 alloca 出空间的起始地址保存在栈帧上 // throw not_implemented_error{__FUNCTION__}; //AllocaInst(Type *ty, BasicBlock *bb); auto *allocaInst = static_cast\u0026lt;AllocaInst *\u0026gt;(context.inst); auto *allocaType = allocaInst-\u0026gt;get_alloca_type(); auto offset = context.offset_map.at(allocaInst); LOG(DEBUG) \u0026lt;\u0026lt; \u0026#34;alloca offset: \u0026#34; \u0026lt;\u0026lt; allocaType-\u0026gt;get_size(); auto new_offset_sub = int(allocaType-\u0026gt;get_size()); auto new_offset = offset - new_offset_sub; if (IS_IMM_12(new_offset)) { append_inst(\u0026#34;addi.d\u0026#34;, {Reg::t(0).print(), \u0026#34;$fp\u0026#34;, std::to_string(new_offset)}); //用t0存储alloca后的地址 } else { load_large_int64(new_offset, Reg::t(0)); append_inst(\u0026#34;add.d\u0026#34;, {Reg::t(0).print(), \u0026#34;$fp\u0026#34;, Reg::t(0).print()}); } append_inst(\u0026#34;st.d\u0026#34;, {Reg::t(0).print(), \u0026#34;$fp\u0026#34;, std::to_string(offset)}); //将alloca后的地址存储到栈帧上 } void CodeGen::gen_load() { /* %op2 = load i32, i32* %op1 */ //get_operand函数只有0，返回value类型的*%op1 // auto *ptr = context.inst-\u0026gt;get_operand(0); //ptr是要加载的地址 auto *type = context.inst-\u0026gt;get_type(); //上面的例子中是i32 load_to_greg(context.inst-\u0026gt;get_operand(0), Reg::t(0)); //将ptr的值加载到t0中，也就是t0存储了要加载的地址 if (type-\u0026gt;is_float_type()) { append_inst(\u0026#34;fld.s $ft0, $t0, 0\u0026#34;); //从t0指向的地址中取值加载到ft0中 store_from_freg(context.inst, FReg::ft(0)); //将ft0的值存储到context.inst中，其实也就是赋给了左值 } else { // TODO load 整数类型的数据 // throw not_implemented_error{__FUNCTION__}; if (type-\u0026gt;is_int1_type()) { append_inst(\u0026#34;ld.b\u0026#34;, {Reg::t(0).print(), Reg::t(0).print(), \u0026#34;0\u0026#34;}); } else if (type-\u0026gt;is_int32_type()) { append_inst(\u0026#34;ld.w\u0026#34;, {Reg::t(0).print(), Reg::t(0).print(), \u0026#34;0\u0026#34;}); } else { append_inst(\u0026#34;ld.d\u0026#34;, {Reg::t(0).print(), Reg::t(0).print(), \u0026#34;0\u0026#34;}); } store_from_greg(context.inst, Reg::t(0)); } } void CodeGen::gen_store() { // TODO 翻译 store 指令 // throw not_implemented_error{__FUNCTION__}; /* store float 0x40091eb860000000, float* %op0 */ // auto *ptr = context.inst-\u0026gt;get_operand(1); //StoreInst(Value *val, Value *ptr, BasicBlock *bb); auto *type = context.inst-\u0026gt;get_operand(0)-\u0026gt;get_type(); //和load是反的，0是要存储的值，1是地址 load_to_greg(context.inst-\u0026gt;get_operand(1), Reg::t(0)); if (type-\u0026gt;is_float_type()) { load_to_freg(context.inst-\u0026gt;get_operand(0), FReg::ft(0)); //把要存储的值加载到ft0中 append_inst(\u0026#34;fst.s $ft0, $t0, 0\u0026#34;); //将ft0中的值写入内存t0指向的地址 } else { load_to_greg(context.inst-\u0026gt;get_operand(0), Reg::t(1)); if (type-\u0026gt;is_int1_type()) { append_inst(\u0026#34;st.b\u0026#34;, {Reg::t(1).print(), Reg::t(0).print(), \u0026#34;0\u0026#34;}); } else if (type-\u0026gt;is_int32_type()) { append_inst(\u0026#34;st.w\u0026#34;, {Reg::t(1).print(), Reg::t(0).print(), \u0026#34;0\u0026#34;}); } else { append_inst(\u0026#34;st.d\u0026#34;, {Reg::t(1).print(), Reg::t(0).print(), \u0026#34;0\u0026#34;}); } } } void CodeGen::gen_icmp() { // TODO 处理各种整数比较的情况 // throw not_implemented_error{__FUNCTION__}; /* %op0 = icmp sgt i32 5, 1 */ auto *icmpInst = static_cast\u0026lt;ICmpInst *\u0026gt;(context.inst); //ICmpInst(OpID id, Value *lhs, Value *rhs, BasicBlock *bb); // auto *op1 = icmpInst-\u0026gt;get_operand(0); //获得第一个value类型的lhs // auto *op2 = icmpInst-\u0026gt;get_operand(1); //获得第二个value类型的rhs load_to_greg(icmpInst-\u0026gt;get_operand(0), Reg::t(0)); load_to_greg(icmpInst-\u0026gt;get_operand(1), Reg::t(1)); switch (icmpInst-\u0026gt;get_instr_type()) { case ICmpInst::lt: //判断t0是否小于t1 output.emplace_back(\u0026#34;slt $t2, $t0, $t1\u0026#34;); break; case ICmpInst::eq: //判断t0和t1是否相等 append_inst(\u0026#34;xor\u0026#34;, {\u0026#34;$t2\u0026#34;, \u0026#34;$t0\u0026#34;, \u0026#34;$t1\u0026#34;}); append_inst(\u0026#34;sltu\u0026#34;, {\u0026#34;$t2\u0026#34;, \u0026#34;$zero\u0026#34;, \u0026#34;$t2\u0026#34;}); append_inst(\u0026#34;xori\u0026#34;, {\u0026#34;$t2\u0026#34;, \u0026#34;$t2\u0026#34;, \u0026#34;1\u0026#34;}); // 先异或，如果 t0 和 t1 相等，结果为 0，否则为非零 // 然后使用 sltu 判断结果是否为零，最后取反 break; case ICmpInst::ne: append_inst(\u0026#34;xor\u0026#34;, {\u0026#34;$t2\u0026#34;, \u0026#34;$t0\u0026#34;, \u0026#34;$t1\u0026#34;}); append_inst(\u0026#34;sltu\u0026#34;, {\u0026#34;$t2\u0026#34;, \u0026#34;$zero\u0026#34;, \u0026#34;$t2\u0026#34;}); //判断t0和t1是否不相等，先异或，再判断是否大于0，用无符号数比较， //如果t0和t1不相等，那么t2会是一个正数，此时一定比0大，所以slt后为1 break; case ICmpInst::le: append_inst(\u0026#34;slt\u0026#34;, {\u0026#34;$t2\u0026#34;, \u0026#34;$t1\u0026#34;, \u0026#34;$t0\u0026#34;}); append_inst(\u0026#34;xori\u0026#34;, {\u0026#34;$t2\u0026#34;, \u0026#34;$t2\u0026#34;, \u0026#34;1\u0026#34;}); //判断t0是否小于等于t1，先判断t1是否小于t0，如果是，那么t2为1，否则为0 //然后将t2取反，如果t0小于等于t1，那么t2为1，否则为0 break; case ICmpInst::gt: output.emplace_back(\u0026#34;slt $t2, $t1, $t0\u0026#34;); break; case ICmpInst::ge: output.emplace_back(\u0026#34;slt $t2, $t0, $t1\u0026#34;); output.emplace_back(\u0026#34;xori $t2, $t2, 1\u0026#34;); break; default: assert(false); } store_from_greg(context.inst, Reg::t(2)); //将比较的结果存储到context.inst中，即赋给左值 } void CodeGen::gen_fcmp() { // TODO 处理各种浮点数比较的情况 // throw not_implemented_error{__FUNCTION__}; //FCmpInst(OpID id, Value *lhs, Value *rhs, BasicBlock *bb); auto *fcmpInst = static_cast\u0026lt;FCmpInst *\u0026gt;(context.inst); // auto *op1 = fcmpInst-\u0026gt;get_operand(0); // auto *op2 = fcmpInst-\u0026gt;get_operand(1); load_to_freg(fcmpInst-\u0026gt;get_operand(0), FReg::ft(0)); load_to_freg(fcmpInst-\u0026gt;get_operand(1), FReg::ft(1)); switch (fcmpInst-\u0026gt;get_instr_type()) { case FCmpInst::feq: output.emplace_back(\u0026#34;fcmp.seq.s $fcc0, $ft0, $ft1\u0026#34;); break; case FCmpInst::fne: output.emplace_back(\u0026#34;fcmp.sne.s $fcc0, $ft0, $ft1\u0026#34;); break; case FCmpInst::flt: output.emplace_back(\u0026#34;fcmp.slt.s $fcc0, $ft0, $ft1\u0026#34;); break; case FCmpInst::fle: output.emplace_back(\u0026#34;fcmp.sle.s $fcc0, $ft0, $ft1\u0026#34;); break; case FCmpInst::fgt: output.emplace_back(\u0026#34;fcmp.sgt.s $fcc0, $ft0, $ft1\u0026#34;); break; case FCmpInst::fge: output.emplace_back(\u0026#34;fcmp.sge.s $fcc0, $ft0, $ft1\u0026#34;); break; default: assert(false); } append_inst(\u0026#34;bcnez\u0026#34;,{\u0026#34;$fcc0\u0026#34;,fcmp_label_name(context.bb, context.fcmp_cnt)}); //如果fcc0为0，跳转存0,否则不跳转存1 load_float_imm(1.0,FReg::ft(2)); store_from_freg(context.inst,FReg::ft(2)); append_inst(\u0026#34;b\u0026#34;, {fcmp_label_name(context.bb, context.fcmp_cnt + 1)}); append_inst(fcmp_label_name(context.bb, context.fcmp_cnt),ASMInstruction::Label); load_float_imm(0.0, FReg::ft(2)); store_from_freg(context.inst, FReg::ft(2)); append_inst(fcmp_label_name(context.bb, context.fcmp_cnt + 1),ASMInstruction::Label); context.fcmp_cnt += 2; } void CodeGen::gen_zext() { // TODO 将窄位宽的整数数据进行零扩展 // throw not_implemented_error{__FUNCTION__}; //ZextInst(Value *val, Type *ty, BasicBlock *bb); /* %op1 = zext i1 %op0 to i32 */ auto zextInst = static_cast\u0026lt;ZextInst *\u0026gt;(context.inst); auto *val = zextInst-\u0026gt;get_operand(0); load_to_greg(val, Reg::t(0)); //将val的值加载到t0中 store_from_greg(context.inst, Reg::t(0)); } void CodeGen::gen_call() { // TODO 函数调用，注意我们只需要通过寄存器传递参数，即不需考虑栈上传参的情况 // throw not_implemented_error{__FUNCTION__}; //CallInst(Function *func, std::vector\u0026lt;Value *\u0026gt; args, BasicBlock *bb); /* %op0 = call i32 @callee(i32 110) */ auto *callInst = static_cast\u0026lt;CallInst *\u0026gt;(context.inst); int garg_cnt = 0; int farg_cnt = 0; for(auto \u0026amp;arg : callInst-\u0026gt;get_operands()) { LOG(DEBUG)\u0026lt;\u0026lt;\u0026#34;arg type is \u0026#34;\u0026lt;\u0026lt;arg-\u0026gt;get_type()-\u0026gt;print(); if(arg-\u0026gt;get_type()-\u0026gt;is_float_type()) { load_to_freg(arg, FReg::fa(farg_cnt)); farg_cnt++; } else if(arg-\u0026gt;get_type()-\u0026gt;is_integer_type()) { LOG(DEBUG)\u0026lt;\u0026lt;\u0026#34;here is integer type\u0026#34;; load_to_greg(arg, Reg::a(garg_cnt)); garg_cnt++; } else if(arg-\u0026gt;get_type()-\u0026gt;is_pointer_type()) { load_to_greg(arg, Reg::a(garg_cnt)); garg_cnt++; } else if(arg-\u0026gt;get_type()-\u0026gt;is_void_type()){ break; } // else { // assert(false); // } } //将参数传入寄存器 assert(context.func \u0026amp;\u0026amp; \u0026#34;context.func is null\u0026#34;); auto *current_func = static_cast\u0026lt;Function*\u0026gt;(callInst-\u0026gt;get_operand(0)); // context.func = current_func; append_inst(\u0026#34;bl\u0026#34;,{current_func-\u0026gt;get_name()}); //调用函数 // std::cout\u0026lt;\u0026lt;\u0026#34;call function_type \u0026#34;\u0026lt;\u0026lt;callInst-\u0026gt;get_function_type()\u0026lt;\u0026lt;std::endl; if(current_func-\u0026gt;get_return_type()-\u0026gt;is_float_type()) { store_from_freg(context.inst, FReg::fa(0)); } else if(current_func-\u0026gt;get_return_type()-\u0026gt;is_int32_type() || current_func-\u0026gt;get_return_type()-\u0026gt;is_int1_type()) { store_from_greg(context.inst, Reg::a(0)); } // if(!current_func-\u0026gt;get_return_type()-\u0026gt;is_void_type()) // { // gen_epilogue(); // } //将函数返回值存储到context.inst中 // append_inst(\u0026#34;b \u0026#34; + func_exit_label_name(context.func)); //跳转到函数退出的地方 } /* * %op = getelementptr [10 x i32], [10 x i32]* %op, i32 0, i32 %op * %op = getelementptr i32, i32* %op, i32 %op * * Memory layout * - ^ * +-----------+ | Smaller address * | arg ptr |---+ | * +-----------+ | | * | | | | * +-----------+ / | * | |\u0026lt;-- | * | | \\ | * | | | | * | Array | | | * | | | | * | | | | * | | | | * +-----------+ | | * | Pointer |---+ | * +-----------+ | * | | | * +-----------+ | * | | | * +-----------+ | * | | | * +-----------+ | Larger address * + */ void CodeGen::gen_gep() { // TODO 计算内存地址 // throw not_implemented_error{__FUNCTION__}; //GetElementPtrInst(Value *ptr, std::vector\u0026lt;Value *\u0026gt; idxs, BasicBlock *bb); /* %op1 = getelementptr [10 x i32], [10 x i32]* %op0, i32 0, i32 0 */ //* %op = getelementptr i32, i32* %op, i32 %op auto *gepInst = static_cast\u0026lt;GetElementPtrInst *\u0026gt;(context.inst); auto *ptr = gepInst-\u0026gt;get_operand(0); load_to_greg(ptr, Reg::t(3)); // if() // { // } int i = 0; for(auto \u0026amp;idx : gepInst-\u0026gt;get_operands()) { if(i == 2||i == 1) { load_to_greg(idx, Reg::t(1)); append_inst(\u0026#34;addi.w\u0026#34;,{\u0026#34;$t4\u0026#34;, \u0026#34;$zero\u0026#34;, \u0026#34;4\u0026#34;}); append_inst(\u0026#34;mul.w\u0026#34;,{\u0026#34;$t2\u0026#34;, \u0026#34;$t1\u0026#34;, \u0026#34;$t4\u0026#34;}); //将idx的值乘以4 append_inst(\u0026#34;add.d\u0026#34;, {\u0026#34;$t3\u0026#34;, \u0026#34;$t2\u0026#34;, \u0026#34;$t3\u0026#34;}); //将ptr的值加上idx的值，此时t3中存储的是ptr+idx的值 } else { i++; } } store_from_greg(context.inst, Reg::t(3)); } void CodeGen::gen_sitofp() { // TODO 整数转向浮点数 // throw not_implemented_error{__FUNCTION__}; //SiToFpInst(Value *val, Type *ty, BasicBlock *bb); auto sitofpInst = static_cast\u0026lt;SiToFpInst *\u0026gt;(context.inst); // auto *val = sitofpInst-\u0026gt;get_operand(0); load_to_greg(sitofpInst-\u0026gt;get_operand(0), Reg::t(0)); append_inst(\u0026#34;movgr2fr.w\u0026#34;,{FReg::ft(0).print(), Reg::t(0).print()}); append_inst(\u0026#34;ffint.s.w\u0026#34;,{FReg::ft(1).print(), FReg::ft(0).print()}); store_from_freg(context.inst, FReg::ft(1)); } void CodeGen::gen_fptosi() { // TODO 浮点数转向整数，注意向下取整(round to zero) // throw not_implemented_error{__FUNCTION__}; //%op2 = fptosi float %op1 to i32 //FpToSiInst(Value *val, Type *ty, BasicBlock *bb); auto fptosiInst = static_cast\u0026lt;FpToSiInst *\u0026gt;(context.inst); // auto *val = fptosiInst-\u0026gt;get_operand(0); load_to_freg(fptosiInst-\u0026gt;get_operand(0), FReg::ft(0)); append_inst(\u0026#34;ftintrz.w.s\u0026#34;,{FReg::ft(1).print(), FReg::ft(0).print()}); append_inst(\u0026#34;movfr2gr.s\u0026#34;,{Reg::t(0).print(), FReg::ft(1).print()}); store_from_greg(context.inst, Reg::t(0)); } void CodeGen::run() { // 确保每个函数中基本块的名字都被设置好 m-\u0026gt;set_print_name(); /* 使用 GNU 伪指令为全局变量分配空间 * 你可以使用 `la.local` 指令将标签 (全局变量) 的地址载入寄存器中, 比如 * 要将 `a` 的地址载入 $t0, 只需要 `la.local $t0, a` */ if (!m-\u0026gt;get_global_variable().empty()) { append_inst(\u0026#34;Global variables\u0026#34;, ASMInstruction::Comment); /* 虽然下面两条伪指令可以简化为一条 `.bss` 伪指令, 但是我们还是选择使用 * `.section` 将全局变量放到可执行文件的 BSS 段, 原因如下: * - 尽可能对齐交叉编译器 loongarch64-unknown-linux-gnu-gcc 的行为 * - 支持更旧版本的 GNU 汇编器, 因为 `.bss` 伪指令是应该相对较新的指令, * GNU 汇编器在 2023 年 2 月的 2.37 版本才将其引入 */ append_inst(\u0026#34;.text\u0026#34;, ASMInstruction::Atrribute); append_inst(\u0026#34;.section\u0026#34;, {\u0026#34;.bss\u0026#34;, \u0026#34;\\\u0026#34;aw\\\u0026#34;\u0026#34;, \u0026#34;@nobits\u0026#34;}, ASMInstruction::Atrribute); for (auto \u0026amp;global : m-\u0026gt;get_global_variable()) { auto size = global.get_type()-\u0026gt;get_pointer_element_type()-\u0026gt;get_size(); append_inst(\u0026#34;.globl\u0026#34;, {global.get_name()}, ASMInstruction::Atrribute); append_inst(\u0026#34;.type\u0026#34;, {global.get_name(), \u0026#34;@object\u0026#34;}, ASMInstruction::Atrribute); append_inst(\u0026#34;.size\u0026#34;, {global.get_name(), std::to_string(size)}, ASMInstruction::Atrribute); append_inst(global.get_name(), ASMInstruction::Label); append_inst(\u0026#34;.space\u0026#34;, {std::to_string(size)}, ASMInstruction::Atrribute); } } // 函数代码段 output.emplace_back(\u0026#34;.text\u0026#34;, ASMInstruction::Atrribute); for (auto \u0026amp;func : m-\u0026gt;get_functions()) { if (not func.is_declaration()) { // 更新 context context.clear(); context.func = \u0026amp;func; // 函数信息 append_inst(\u0026#34;.globl\u0026#34;, {func.get_name()}, ASMInstruction::Atrribute); append_inst(\u0026#34;.type\u0026#34;, {func.get_name(), \u0026#34;@function\u0026#34;}, ASMInstruction::Atrribute); append_inst(func.get_name(), ASMInstruction::Label); // 分配函数栈帧 allocate(); // 生成 prologue gen_prologue(); for (auto \u0026amp;bb : func.get_basic_blocks()) { context.bb = \u0026amp;bb; append_inst(label_name(context.bb), ASMInstruction::Label); for (auto \u0026amp;instr : bb.get_instructions()) { // For debug append_inst(instr.print(), ASMInstruction::Comment); context.inst = \u0026amp;instr; // 更新 context switch (instr.get_instr_type()) { case Instruction::ret: gen_ret(); break; case Instruction::br: copy_stmt(); gen_br(); break; case Instruction::add: case Instruction::sub: case Instruction::mul: case Instruction::sdiv: gen_binary(); break; case Instruction::fadd: case Instruction::fsub: case Instruction::fmul: case Instruction::fdiv: gen_float_binary(); break; case Instruction::alloca: /* 对于 alloca 指令，我们已经为 alloca * 的内容分配空间，在此我们还需保存 alloca * 指令自身产生的定值，即指向 alloca 空间起始地址的指针 */ gen_alloca(); break; case Instruction::load: gen_load(); break; case Instruction::store: gen_store(); break; case Instruction::ge: case Instruction::gt: case Instruction::le: case Instruction::lt: case Instruction::eq: case Instruction::ne: gen_icmp(); break; case Instruction::fge: case Instruction::fgt: case Instruction::fle: case Instruction::flt: case Instruction::feq: case Instruction::fne: gen_fcmp(); break; case Instruction::phi: /* for phi, just convert to a series of * copy-stmts */ /* we can collect all phi and deal them at * the end */ break; case Instruction::call: gen_call(); break; case Instruction::getelementptr: gen_gep(); break; case Instruction::zext: gen_zext(); break; case Instruction::fptosi: gen_fptosi(); break; case Instruction::sitofp: gen_sitofp(); break; } } } // 生成 epilogue gen_epilogue(); } } } std::string CodeGen::print() const { std::string result; for (const auto \u0026amp;inst : output) { result += inst.format(); } return result; } 优化处理\rMEM2REG\r创建支配树：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 #include \u0026#34;Dominators.hpp\u0026#34; #include \u0026#34;Function.hpp\u0026#34; #include \u0026lt;fstream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026#34;BasicBlock.hpp\u0026#34; #include \u0026#34;logging.hpp\u0026#34; /** * @brief 支配器分析的入口函数 * * 遍历模块中的所有函数，对每个非声明的函数执行支配关系分析。 */ void Dominators::run() { for(auto \u0026amp;f1 : m_-\u0026gt;get_functions()) { auto f = \u0026amp;f1; if(f-\u0026gt;is_declaration()) continue; run_on_func(f); } } /** * @brief 对单个函数执行支配关系分析 * @param f 要分析的函数 * * 该函数执行完整的支配关系分析流程： * 1. 初始化数据结构 * 2. 创建反向后序遍历序列 * 3. 计算直接支配者(idom) * 4. 计算支配边界 * 5. 构建支配树的后继关系 * 6. 创建支配树的DFS序 */ void Dominators::run_on_func(Function *f) { dom_post_order_.clear(); dom_dfs_order_.clear(); for(auto \u0026amp;bb1 : f-\u0026gt;get_basic_blocks()) { auto bb = \u0026amp;bb1; idom_.insert({bb, nullptr}); dom_frontier_.insert({bb, {}}); dom_tree_succ_blocks_.insert({bb, {}}); } create_reverse_post_order(f); create_idom(f); create_dominance_frontier(f); create_dom_tree_succ(f); create_dom_dfs_order(f); // LOG(INFO)\u0026lt;\u0026lt;m_-\u0026gt;print(); // dump_dominator_tree(f); // dump_cfg(f); } /** * @brief 计算两个基本块的支配关系交集 * @param b1 第一个基本块 * @param b2 第二个基本块 * @return 返回在支配树上最深的同时支配b1和b2的节点 * * 该函数使用后序号来查找两个节点的最近公共支配者。 * 通过在支配树上向上遍历直到找到交点。 */ BasicBlock *Dominators::intersect(BasicBlock *b1, BasicBlock *b2) { while (b1 != b2) { while (get_post_order(b1) \u0026lt; get_post_order(b2)) { b1 = get_idom(b1); } while (get_post_order(b2) \u0026lt; get_post_order(b1)) { b2 = get_idom(b2); } } return b1; } /** * @brief 创建函数的反向后序遍历序列 * @param f 要处理的函数 * * 通过DFS遍历CFG来构建基本块的后序遍历序列。 * 这个序列用于后续的支配关系分析。 */ void Dominators::create_reverse_post_order(Function *f) { BBSet visited; dfs(f-\u0026gt;get_entry_block(), visited); } /** * @brief 深度优先搜索辅助函数 * @param bb 当前遍历的基本块 * @param visited 已访问的基本块集合 * * 执行DFS遍历，维护后序遍历序列和每个基本块的后序号。 */ void Dominators::dfs(BasicBlock *bb, std::set\u0026lt;BasicBlock *\u0026gt; \u0026amp;visited) { visited.insert(bb); for (auto \u0026amp;succ : bb-\u0026gt;get_succ_basic_blocks()) { if (visited.find(succ) == visited.end()) { dfs(succ, visited); } } post_order_vec_.push_back(bb); post_order_.insert({bb, post_order_.size()}); } /** * @brief 计算所有基本块的直接支配者(immediate dominator) * @param f 要分析的函数 * * 使用迭代算法计算每个基本块的直接支配者： * 1. 将入口块的直接支配者设置为自身 * 2. 重复遍历所有基本块，更新它们的直接支配者 * 3. 当没有变化时算法终止 */ void Dominators::create_idom(Function *f) { BasicBlock *entry = f-\u0026gt;get_entry_block(); idom_[entry] = entry; // LOG(INFO)\u0026lt;\u0026lt;\u0026#34;idom_[entry]:\u0026#34;\u0026lt;\u0026lt;idom_[entry]-\u0026gt;get_name(); bool changed = true; while (changed) { changed = false; for (auto rev_it = post_order_vec_.rbegin(); rev_it != post_order_vec_.rend(); ++rev_it) { auto bb = *rev_it; if(bb == entry || bb == nullptr) { continue; } auto pre_blocks = bb-\u0026gt;get_pre_basic_blocks(); if(pre_blocks.size() == 0) { continue; } auto new_idom = *pre_blocks.begin(); for (auto pred : bb-\u0026gt;get_pre_basic_blocks()) { if (idom_[pred] != nullptr \u0026amp;\u0026amp; idom_.find(pred) != idom_.end()) { new_idom = intersect(new_idom, pred); } } if (idom_[bb] != new_idom) { idom_[bb] = new_idom; changed = true; } } } } /** * @brief 计算所有基本块的支配边界(dominance frontier) * @param f 要分析的函数 * * 对于每个有多个前驱的基本块B： * 从每个前驱P开始，沿着支配树向上遍历直到遇到B的直接支配者， * 将B加入路径上所有节点的支配边界中。 */ void Dominators::create_dominance_frontier(Function *f) { for(auto \u0026amp;block : f-\u0026gt;get_basic_blocks()) { if(block.get_pre_basic_blocks().size() \u0026gt;= 2) { for(auto pred : block.get_pre_basic_blocks()) { auto runner = pred; while(runner != get_idom(\u0026amp;block) \u0026amp;\u0026amp; runner != nullptr) { dom_frontier_[runner].insert(\u0026amp;block); runner = get_idom(runner); } } } } } /** * @brief 构建支配树的后继关系 * @param f 要处理的函数 * * 基于已计算的直接支配者关系，构建支配树的子节点关系。 * 如果A是B的直接支配者，则B是A在支配树上的后继。 */ void Dominators::create_dom_tree_succ(Function *f) { // 遍历所有基本块 for (auto \u0026amp;block : f-\u0026gt;get_basic_blocks()) { auto idom = get_idom(\u0026amp;block); if (idom != nullptr \u0026amp;\u0026amp; idom_.find(idom) != idom_.end() \u0026amp;\u0026amp; idom_.at(\u0026amp;block) != \u0026amp;block) { // 检查直接支配者是否已经在 dom_tree_succ_blocks_ 中 if (dom_tree_succ_blocks_.find(idom) != dom_tree_succ_blocks_.end()) { dom_tree_succ_blocks_[idom].insert(\u0026amp;block); } else { dom_tree_succ_blocks_[idom] = {\u0026amp;block}; } } } } /** * @brief 为支配树创建深度优先搜索序 * @param f 要处理的函数 * * 该函数通过深度优先搜索遍历支配树，为每个基本块分配两个序号： * 1. dom_tree_L_：记录DFS首次访问该节点的时间戳 * 2. dom_tree_R_：记录DFS完成访问该节点子树的时间戳 * * 同时维护： * - dom_dfs_order_：按DFS访问顺序记录基本块 * - dom_post_order_：dom_dfs_order_的逆序 * * 这些序号和顺序可用于快速判断支配关系： * 如果节点A支配节点B，则A的L值小于B的L值，且A的R值大于B的R值 */ void Dominators::create_dom_dfs_order(Function *f) { // 分析得到 f 中各个基本块的支配树上的dfs序L,R unsigned int order = 0; std::function\u0026lt;void(BasicBlock *)\u0026gt; dfs = [\u0026amp;](BasicBlock *bb) { dom_tree_L_[bb] = ++ order; dom_dfs_order_.push_back(bb); for (auto \u0026amp;succ : dom_tree_succ_blocks_[bb]) { dfs(succ); } dom_tree_R_[bb] = order; }; dfs(f-\u0026gt;get_entry_block()); dom_post_order_ = std::vector(dom_dfs_order_.rbegin(), dom_dfs_order_.rend()); } /** * @brief 打印函数的直接支配关系 * @param f 要打印的函数 * * 该函数以可读格式打印函数中所有基本块的直接支配者(immediate dominator)。 * 输出格式为： * 基本块名: 其直接支配者名 * 如果基本块没有直接支配者(如入口块)，则显示\u0026#34;null\u0026#34;。 */ void Dominators::print_idom(Function *f) { f-\u0026gt;get_parent()-\u0026gt;set_print_name(); int counter = 0; std::map\u0026lt;BasicBlock *, std::string\u0026gt; bb_id; for (auto \u0026amp;bb1 : f-\u0026gt;get_basic_blocks()) { auto bb = \u0026amp;bb1; if (bb-\u0026gt;get_name().empty()) bb_id[bb] = \u0026#34;bb\u0026#34; + std::to_string(counter); else bb_id[bb] = bb-\u0026gt;get_name(); counter++; } printf(\u0026#34;Immediate dominance of function %s:\\n\u0026#34;, f-\u0026gt;get_name().c_str()); for (auto \u0026amp;bb1 : f-\u0026gt;get_basic_blocks()) { auto bb = \u0026amp;bb1; std::string output; output = bb_id[bb] + \u0026#34;: \u0026#34;; if (get_idom(bb)) { output += bb_id[get_idom(bb)]; } else { output += \u0026#34;null\u0026#34;; } printf(\u0026#34;%s\\n\u0026#34;, output.c_str()); } } /** * @brief 打印函数的支配边界信息 * @param f 要打印的函数 * * 该函数以可读格式打印函数中所有基本块的支配边界(dominance frontier)。 * 输出格式为： * 基本块名: 支配边界中的基本块列表 * 如果基本块没有支配边界，则显示\u0026#34;null\u0026#34;。 */ void Dominators::print_dominance_frontier(Function *f) { f-\u0026gt;get_parent()-\u0026gt;set_print_name(); int counter = 0; std::map\u0026lt;BasicBlock *, std::string\u0026gt; bb_id; for (auto \u0026amp;bb1 : f-\u0026gt;get_basic_blocks()) { auto bb = \u0026amp;bb1; if (bb-\u0026gt;get_name().empty()) bb_id[bb] = \u0026#34;bb\u0026#34; + std::to_string(counter); else bb_id[bb] = bb-\u0026gt;get_name(); counter++; } printf(\u0026#34;Dominance Frontier of function %s:\\n\u0026#34;, f-\u0026gt;get_name().c_str()); for (auto \u0026amp;bb1 : f-\u0026gt;get_basic_blocks()) { auto bb = \u0026amp;bb1; std::string output; output = bb_id[bb] + \u0026#34;: \u0026#34;; if (get_dominance_frontier(bb).empty()) { output += \u0026#34;null\u0026#34;; } else { bool first = true; for (auto df : get_dominance_frontier(bb)) { if (first) { first = false; } else { output += \u0026#34;, \u0026#34;; } output += bb_id[df]; } } printf(\u0026#34;%s\\n\u0026#34;, output.c_str()); } } /** * @brief 将函数的控制流图(CFG)导出为图形文件 * @param f 要导出的函数 * * 该函数生成函数的控制流图的DOT格式描述，并使用graphviz将其转换为PNG图像。 * 生成两个文件： * - {函数名}_cfg.dot：DOT格式的图形描述 * - {函数名}_cfg.png：可视化的控制流图 */ void Dominators::dump_cfg(Function *f) { f-\u0026gt;get_parent()-\u0026gt;set_print_name(); if(f-\u0026gt;is_declaration()) return; std::vector\u0026lt;std::string\u0026gt; edge_set; bool has_edges = false; for (auto \u0026amp;bb : f-\u0026gt;get_basic_blocks()) { auto succ_blocks = bb.get_succ_basic_blocks(); if(!succ_blocks.empty()) has_edges = true; for (auto succ : succ_blocks) { edge_set.push_back(\u0026#39;\\t\u0026#39; + bb.get_name() + \u0026#34;-\u0026gt;\u0026#34; + succ-\u0026gt;get_name() + \u0026#34;;\\n\u0026#34;); } } std::string digraph = \u0026#34;digraph G {\\n\u0026#34;; if (!has_edges \u0026amp;\u0026amp; !f-\u0026gt;get_basic_blocks().empty()) { // 如果没有边且至少有一个基本块，添加一个自环以显示唯一的基本块 auto \u0026amp;bb = f-\u0026gt;get_basic_blocks().front(); digraph += \u0026#39;\\t\u0026#39; + bb.get_name() + \u0026#34;;\\n\u0026#34;; } else { for (auto \u0026amp;edge : edge_set) { digraph += edge; } } digraph += \u0026#34;}\\n\u0026#34;; std::ofstream file_output; file_output.open(f-\u0026gt;get_name() + \u0026#34;_cfg.dot\u0026#34;, std::ios::out); file_output \u0026lt;\u0026lt; digraph; file_output.close(); std::string dot_cmd = \u0026#34;dot -Tpng \u0026#34; + f-\u0026gt;get_name() + \u0026#34;_cfg.dot\u0026#34; + \u0026#34; -o \u0026#34; + f-\u0026gt;get_name() + \u0026#34;_cfg.png\u0026#34;; std::system(dot_cmd.c_str()); } /** * @brief 将函数的支配树导出为图形文件 * @param f 要导出的函数 * * 该函数生成函数的支配树的DOT格式描述，并使用graphviz将其转换为PNG图像。 * 生成两个文件： * - {函数名}_dom_tree.dot：DOT格式的图形描述 * - {函数名}_dom_tree.png：可视化的支配树 */ void Dominators::dump_dominator_tree(Function *f) { f-\u0026gt;get_parent()-\u0026gt;set_print_name(); if(f-\u0026gt;is_declaration()) return; std::vector\u0026lt;std::string\u0026gt; edge_set; bool has_edges = false; // 用于检查是否有边存在 for (auto \u0026amp;b : f-\u0026gt;get_basic_blocks()) { if (idom_.find(\u0026amp;b) != idom_.end() \u0026amp;\u0026amp; idom_[\u0026amp;b] != \u0026amp;b) { edge_set.push_back(\u0026#39;\\t\u0026#39; + idom_[\u0026amp;b]-\u0026gt;get_name() + \u0026#34;-\u0026gt;\u0026#34; + b.get_name() + \u0026#34;;\\n\u0026#34;); has_edges = true; // 如果存在支配边，标记为 true } } std::string digraph = \u0026#34;digraph G {\\n\u0026#34;; if (!has_edges \u0026amp;\u0026amp; !f-\u0026gt;get_basic_blocks().empty()) { // 如果没有边且至少有一个基本块，直接添加该块以显示它 auto \u0026amp;b = f-\u0026gt;get_basic_blocks().front(); digraph += \u0026#39;\\t\u0026#39; + b.get_name() + \u0026#34;;\\n\u0026#34;; } else { for (auto \u0026amp;edge : edge_set) { digraph += edge; } } digraph += \u0026#34;}\\n\u0026#34;; std::ofstream file_output; file_output.open(f-\u0026gt;get_name() + \u0026#34;_dom_tree.dot\u0026#34;, std::ios::out); file_output \u0026lt;\u0026lt; digraph; file_output.close(); std::string dot_cmd = \u0026#34;dot -Tpng \u0026#34; + f-\u0026gt;get_name() + \u0026#34;_dom_tree.dot\u0026#34; + \u0026#34; -o \u0026#34; + f-\u0026gt;get_name() + \u0026#34;_dom_tree.png\u0026#34;; std::system(dot_cmd.c_str()); } MEM2REG：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 #include \u0026#34;Mem2Reg.hpp\u0026#34; #include \u0026#34;IRBuilder.hpp\u0026#34; #include \u0026#34;Instruction.hpp\u0026#34; #include \u0026#34;Value.hpp\u0026#34; #include \u0026lt;memory\u0026gt; #include \u0026lt;vector\u0026gt; /** * @brief Mem2Reg Pass的主入口函数 * * 该函数执行内存到寄存器的提升过程，将栈上的局部变量提升到SSA格式。 * 主要步骤： * 1. 创建并运行支配树分析 * 2. 对每个非声明函数： * - 清空相关数据结构 * - 插入必要的phi指令 * - 执行变量重命名 * * 注意：函数执行后，冗余的局部变量分配指令将由后续的死代码删除Pass处理 */ void Mem2Reg::run() { // 创建支配树分析 Pass 的实例 dominators_ = std::make_unique\u0026lt;Dominators\u0026gt;(m_); // 建立支配树 dominators_-\u0026gt;run(); // 以函数为单元遍历实现 Mem2Reg 算法 for (auto \u0026amp;f : m_-\u0026gt;get_functions()) { if (f.is_declaration()) continue; func_ = \u0026amp;f; var_val_stack.clear(); phi_lval.clear(); if (func_-\u0026gt;get_basic_blocks().size() \u0026gt;= 1) { // 对应伪代码中 phi 指令插入的阶段 generate_phi(); // 对应伪代码中重命名阶段 rename(func_-\u0026gt;get_entry_block()); } // 后续 DeadCode 将移除冗余的局部变量的分配空间 } } /** * @brief 在必要的位置插入phi指令 * * 该函数实现了经典的phi节点插入算法： * 1. 收集全局活跃变量： * - 扫描所有store指令 * - 识别在多个基本块中被赋值的变量 * * 2. 插入phi指令： * - 对每个全局活跃变量 * - 在其定值点的支配边界处插入phi指令 * - 使用工作表法处理迭代式的phi插入 * * phi指令的插入遵循最小化原则，只在必要的位置插入phi节点 */ void Mem2Reg::generate_phi() { // global_live_var_name 是全局名字集合，以 alloca 出的局部变量来统计。 // 步骤一：找到活跃在多个 block 的全局名字集合，以及它们所属的 bb 块 std::set\u0026lt;Value *\u0026gt; global_live_var_name; std::map\u0026lt;Value *, std::set\u0026lt;BasicBlock *\u0026gt;\u0026gt; live_var_2blocks; for (auto \u0026amp;bb : func_-\u0026gt;get_basic_blocks()) { std::set\u0026lt;Value *\u0026gt; var_is_killed; for (auto \u0026amp;instr : bb.get_instructions()) { if (instr.is_store()) { // store i32 a, i32 *b // a is r_val, b is l_val auto l_val = static_cast\u0026lt;StoreInst *\u0026gt;(\u0026amp;instr)-\u0026gt;get_lval(); if (is_valid_ptr(l_val)) { global_live_var_name.insert(l_val); live_var_2blocks[l_val].insert(\u0026amp;bb); } } } } // 步骤二：从支配树获取支配边界信息，并在对应位置插入 phi 指令 std::map\u0026lt;std::pair\u0026lt;BasicBlock *, Value *\u0026gt;, bool\u0026gt; bb_has_var_phi; // bb has phi for var for (auto var : global_live_var_name) { std::vector\u0026lt;BasicBlock *\u0026gt; work_list; work_list.assign(live_var_2blocks[var].begin(), live_var_2blocks[var].end()); for (unsigned i = 0; i \u0026lt; work_list.size(); i++) { auto bb = work_list[i]; for (auto bb_dominance_frontier_bb : dominators_-\u0026gt;get_dominance_frontier(bb)) { if (bb_has_var_phi.find({bb_dominance_frontier_bb, var}) == bb_has_var_phi.end()) { // generate phi for bb_dominance_frontier_bb \u0026amp; add // bb_dominance_frontier_bb to work list auto phi = PhiInst::create_phi( var-\u0026gt;get_type()-\u0026gt;get_pointer_element_type(), bb_dominance_frontier_bb); phi_lval.emplace(phi, var); bb_dominance_frontier_bb-\u0026gt;add_instr_begin(phi); work_list.push_back(bb_dominance_frontier_bb); bb_has_var_phi[{bb_dominance_frontier_bb, var}] = true; } } } } } void Mem2Reg::rename(BasicBlock *bb) { std::vector\u0026lt;Instruction *\u0026gt; wait_delete; // 步骤一：将 phi 指令作为 lval 的最新定值，lval 即是为局部变量 alloca 出的地址空间 for (auto \u0026amp;inst : bb-\u0026gt;get_instructions()) { if (inst.get_instr_type() == Instruction::phi) { auto phi_inst = static_cast\u0026lt;PhiInst *\u0026gt;(\u0026amp;inst); auto it = phi_lval.find(phi_inst); if (it != phi_lval.end()) { auto lval = it-\u0026gt;second; if (is_valid_ptr(lval)) { var_val_stack[lval].push_back(static_cast\u0026lt;Value*\u0026gt;(\u0026amp;inst)); } } } if (inst.get_instr_type() == Instruction::load) { auto loadinst = static_cast\u0026lt;LoadInst *\u0026gt;(\u0026amp;inst); auto lval = loadinst-\u0026gt;get_lval(); if (is_valid_ptr(lval) \u0026amp;\u0026amp; var_val_stack.find(lval) != var_val_stack.end() \u0026amp;\u0026amp; !var_val_stack[lval].empty()) { Value* rval = var_val_stack[lval].back(); loadinst-\u0026gt;replace_all_use_with(rval); wait_delete.push_back(loadinst); } } if (inst.get_instr_type() == Instruction::store) { auto storeinst = static_cast\u0026lt;StoreInst *\u0026gt;(\u0026amp;inst); auto lval = storeinst-\u0026gt;get_lval(); auto rval = storeinst-\u0026gt;get_rval(); if (is_valid_ptr(lval)) { var_val_stack[lval].push_back(rval); wait_delete.push_back(storeinst); } } } // 步骤二：用 lval 最新的定值替代对应的load指令 // 步骤三：将 store 指令的 rval，也即被存入内存的值，作为 lval 的最新定值 // 步骤四：为 lval 对应的 phi 指令参数补充完整 for (auto succ : bb-\u0026gt;get_succ_basic_blocks()) { for (auto \u0026amp;inst : succ-\u0026gt;get_instructions()) { if (inst.get_instr_type() == Instruction::phi) { auto phi = static_cast\u0026lt;PhiInst *\u0026gt;(\u0026amp;inst); auto it = phi_lval.find(phi); if (it != phi_lval.end()) { auto lval = it-\u0026gt;second; if (is_valid_ptr(lval) \u0026amp;\u0026amp; !var_val_stack[lval].empty()) { Value *rval = var_val_stack[lval].back(); phi-\u0026gt;add_phi_pair_operand(rval, bb); } } } } } // 步骤五：对 bb 在支配树上的所有后继节点，递归执行 rename 操作 auto dom_succ_blocks = dominators_-\u0026gt;get_dom_tree_succ_blocks(bb); if (!dom_succ_blocks.empty()) { for (auto succ : dom_succ_blocks) { rename(succ); } } // 步骤六：pop出 lval 的最新定值 for (auto \u0026amp;inst : bb-\u0026gt;get_instructions()) { if (inst.get_instr_type() == Instruction::store) { auto storeinst = static_cast\u0026lt;StoreInst *\u0026gt;(\u0026amp;inst); auto lval = storeinst-\u0026gt;get_lval(); if (is_valid_ptr(lval) \u0026amp;\u0026amp; var_val_stack.find(lval) != var_val_stack.end() \u0026amp;\u0026amp; !var_val_stack[lval].empty()) { var_val_stack[lval].pop_back(); } } if (inst.get_instr_type() == Instruction::phi) { auto phiinst = static_cast\u0026lt;PhiInst *\u0026gt;(\u0026amp;inst); auto it = phi_lval.find(phiinst); if (it != phi_lval.end()) { auto lval = it-\u0026gt;second; if (is_valid_ptr(lval) \u0026amp;\u0026amp; var_val_stack.find(lval) != var_val_stack.end() \u0026amp;\u0026amp; !var_val_stack[lval].empty()) { var_val_stack[lval].pop_back(); } } } } for (auto instr : wait_delete) { bb-\u0026gt;erase_instr(instr); } } 循环不变量外提\r循环检测：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 #include \u0026#34;LoopDetection.hpp\u0026#34; #include \u0026#34;Dominators.hpp\u0026#34; #include \u0026lt;cstddef\u0026gt; #include \u0026lt;memory\u0026gt; /** * @brief 循环检测Pass的主入口函数 * * 该函数执行以下步骤： * 1. 创建支配树分析实例 * 2. 遍历模块中的所有函数 * 3. 对每个非声明函数执行循环检测 * 4. 最后打印检测结果 */ void LoopDetection::run() { dominators_ = std::make_unique\u0026lt;Dominators\u0026gt;(m_); for (auto \u0026amp;f1 : m_-\u0026gt;get_functions()) { auto f = \u0026amp;f1; if (f-\u0026gt;is_declaration()) continue; func_ = f; run_on_func(f); } print(); } /** * @brief 发现循环及其子循环 * @param bb 循环的header块 * @param latches 循环的回边终点(latch)集合 * @param loop 当前正在处理的循环对象 */ void LoopDetection::discover_loop_and_sub_loops(BasicBlock *bb, BBset \u0026amp;latches, std::shared_ptr\u0026lt;Loop\u0026gt; loop) { // TODO List: // 1. 初始化工作表，将所有latch块加入 // 2. 实现主循环逻辑 // 3. 处理未分配给任何循环的节点 // 4. 处理已属于其他循环的节点 // 5. 建立正确的循环嵌套关系 BBvec work_list = {latches.begin(), latches.end()}; // 初始化工作表 while (!work_list.empty()) { // 当工作表非空时继续处理 auto bb = work_list.back(); work_list.pop_back(); // TODO-1: 处理未分配给任何循环的节点 if (bb_to_loop_.find(bb) == bb_to_loop_.end()) { /* 在此添加代码： * 1. 使用loop-\u0026gt;add_block将bb加入当前循环 * 2. 更新bb_to_loop_映射 * 3. 将bb的所有前驱加入工作表 */ loop-\u0026gt;add_block(bb); bb_to_loop_[bb] = loop; for (auto pred : bb-\u0026gt;get_pre_basic_blocks()) { work_list.push_back(pred); } // throw std::runtime_error(\u0026#34;Lab4: 你有一个TODO需要完成！\u0026#34;); } // TODO-2: 处理已属于其他循环的节点 else if (bb_to_loop_[bb] != loop) { /* 在此添加代码： * 1. 获取bb当前所属的循环sub_loop * 2. 找到sub_loop的最顶层父循环 * 3. 检查是否需要继续处理 * 4. 建立循环嵌套关系： * - 设置父循环 * - 添加子循环 * 5. 将子循环的所有基本快加入到父循环中 * 6. 将子循环header的前驱加入工作表 */ auto sub_loop = bb_to_loop_[bb]; auto parent_loop = sub_loop-\u0026gt;get_parent(); // 找到最顶层的父循环 while (parent_loop != nullptr \u0026amp;\u0026amp; parent_loop != loop) { sub_loop = parent_loop; parent_loop = sub_loop-\u0026gt;get_parent(); } // 如果当前循环不是最顶层父循环，则建立嵌套关系 if (parent_loop == nullptr) { sub_loop-\u0026gt;set_parent(loop); loop-\u0026gt;add_sub_loop(sub_loop); for (auto block : sub_loop-\u0026gt;get_blocks()) { loop-\u0026gt;add_block(block); } work_list.push_back(sub_loop-\u0026gt;get_header()); } // throw std::runtime_error(\u0026#34;Lab4: 你有一个TODO需要完成！\u0026#34;); } } } /** * @brief 对单个函数执行循环检测 * @param f 要分析的函数 * * 该函数通过以下步骤检测循环： * 1. 运行支配树分析 * 2. 按支配树后序遍历所有基本块 * 3. 对每个块，检查其前驱是否存在回边 * 4. 如果存在回边，创建新的循环并： * - 设置循环header * - 添加latch节点 * - 发现循环体和子循环 */ void LoopDetection::run_on_func(Function *f) { dominators_-\u0026gt;run_on_func(f); for (auto \u0026amp;bb1 : dominators_-\u0026gt;get_dom_post_order()) { auto bb = bb1; BBset latches; for (auto \u0026amp;pred : bb-\u0026gt;get_pre_basic_blocks()) { if (dominators_-\u0026gt;is_dominate(bb, pred)) { // pred is a back edge // pred -\u0026gt; bb , pred is the latch node latches.insert(pred); } } if (latches.empty()) { continue; } // create loop auto loop = std::make_shared\u0026lt;Loop\u0026gt;(bb); bb_to_loop_[bb] = loop; // add latch nodes for (auto \u0026amp;latch : latches) { loop-\u0026gt;add_latch(latch); } loops_.push_back(loop); discover_loop_and_sub_loops(bb, latches, loop); } } /** * @brief 打印循环检测的结果 * * 为每个检测到的循环打印： * 1. 循环的header块 * 2. 循环包含的所有基本块 * 3. 循环的所有子循环 */ void LoopDetection::print() { m_-\u0026gt;set_print_name(); std::cerr \u0026lt;\u0026lt; \u0026#34;Loop Detection Result:\u0026#34; \u0026lt;\u0026lt; std::endl; for (auto \u0026amp;loop : loops_) { std::cerr \u0026lt;\u0026lt; \u0026#34;Loop header: \u0026#34; \u0026lt;\u0026lt; loop-\u0026gt;get_header()-\u0026gt;get_name() \u0026lt;\u0026lt; std::endl; std::cerr \u0026lt;\u0026lt; \u0026#34;Loop blocks: \u0026#34;; for (auto \u0026amp;bb : loop-\u0026gt;get_blocks()) { std::cerr \u0026lt;\u0026lt; bb-\u0026gt;get_name() \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } std::cerr \u0026lt;\u0026lt; std::endl; std::cerr \u0026lt;\u0026lt; \u0026#34;Sub loops: \u0026#34;; for (auto \u0026amp;sub_loop : loop-\u0026gt;get_sub_loops()) { std::cerr \u0026lt;\u0026lt; sub_loop-\u0026gt;get_header()-\u0026gt;get_name() \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } std::cerr \u0026lt;\u0026lt; std::endl; } } 外提循环不变量：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 #include \u0026#34;BasicBlock.hpp\u0026#34; #include \u0026#34;Constant.hpp\u0026#34; #include \u0026#34;FuncInfo.hpp\u0026#34; #include \u0026#34;Function.hpp\u0026#34; #include \u0026#34;GlobalVariable.hpp\u0026#34; #include \u0026#34;Instruction.hpp\u0026#34; #include \u0026#34;LICM.hpp\u0026#34; #include \u0026#34;PassManager.hpp\u0026#34; #include \u0026lt;cstddef\u0026gt; #include \u0026lt;memory\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026#34;logging.hpp\u0026#34; /** * @brief 循环不变式外提Pass的主入口函数 * */ int label_num = 0; void LoopInvariantCodeMotion::run() { loop_detection_ = std::make_unique\u0026lt;LoopDetection\u0026gt;(m_); loop_detection_-\u0026gt;run(); func_info_ = std::make_unique\u0026lt;FuncInfo\u0026gt;(m_); func_info_-\u0026gt;run(); for (auto \u0026amp;loop : loop_detection_-\u0026gt;get_loops()) { is_loop_done_[loop] = false; } for (auto \u0026amp;loop : loop_detection_-\u0026gt;get_loops()) { traverse_loop(loop); } } /** * @brief 遍历循环及其子循环 * @param loop 当前要处理的循环 * */ void LoopInvariantCodeMotion::traverse_loop(std::shared_ptr\u0026lt;Loop\u0026gt; loop) { if (is_loop_done_[loop]) { return; } is_loop_done_[loop] = true; for (auto \u0026amp;sub_loop : loop-\u0026gt;get_sub_loops()) { traverse_loop(sub_loop); } run_on_loop(loop); } // TODO: 实现collect_loop_info函数 // 1. 遍历当前循环及其子循环的所有指令 // 2. 收集所有指令到loop_instructions中 // 3. 检查store指令是否修改了全局变量，如果是则添加到updated_global中 // 4. 检查是否包含非纯函数调用，如果有则设置contains_impure_call为true void LoopInvariantCodeMotion::collect_loop_info( std::shared_ptr\u0026lt;Loop\u0026gt; loop, std::set\u0026lt;Value *\u0026gt; \u0026amp;loop_instructions, std::set\u0026lt;Value *\u0026gt; \u0026amp;updated_global, bool \u0026amp;contains_impure_call) { auto sub_loops = loop-\u0026gt;get_sub_loops(); for (auto \u0026amp;bb : loop-\u0026gt;get_blocks()) { for (auto \u0026amp;inst : bb-\u0026gt;get_instructions()) { loop_instructions.insert(\u0026amp;inst); if (inst.get_instr_type() == Instruction::store) { LOG(DEBUG) \u0026lt;\u0026lt; \u0026#34;store_inst: \u0026#34; \u0026lt;\u0026lt; inst.print(); auto store_inst = dynamic_cast\u0026lt;StoreInst *\u0026gt;(\u0026amp;inst); //左值是地址，右值是值 auto rval = store_inst-\u0026gt;get_rval(); if (dynamic_cast\u0026lt;GlobalVariable *\u0026gt;(rval) != nullptr) { LOG(DEBUG) \u0026lt;\u0026lt; \u0026#34;add gloabl\u0026#34;; updated_global.insert(rval); } } if (inst.get_instr_type() == Instruction::call) { auto func = static_cast\u0026lt;Function*\u0026gt;(inst.get_operand(0)); if(func_info_-\u0026gt;is_pure_function(func)) { LOG(DEBUG) \u0026lt;\u0026lt; \u0026#34;contains_pure_call\u0026#34;; contains_impure_call = false; } else { LOG(DEBUG) \u0026lt;\u0026lt; \u0026#34;contains_impure_call\u0026#34;; contains_impure_call = true; } } } } for (auto sub_loop : sub_loops) { for (auto \u0026amp;bb : sub_loop-\u0026gt;get_blocks()) { for (auto \u0026amp;inst : bb-\u0026gt;get_instructions()) { loop_instructions.insert(\u0026amp;inst); if (inst.get_instr_type() == Instruction::store) { LOG(DEBUG) \u0026lt;\u0026lt; \u0026#34;store_inst: \u0026#34; \u0026lt;\u0026lt; inst.print(); auto store_inst = dynamic_cast\u0026lt;StoreInst *\u0026gt;(\u0026amp;inst); //左值是地址，右值是值 auto rval = store_inst-\u0026gt;get_rval(); if (dynamic_cast\u0026lt;GlobalVariable *\u0026gt;(rval) != nullptr) { LOG(DEBUG) \u0026lt;\u0026lt; \u0026#34;add gloabl\u0026#34;; updated_global.insert(rval); } } if (inst.get_instr_type() == Instruction::call) { auto func = static_cast\u0026lt;Function*\u0026gt;(inst.get_operand(0)); if(func_info_-\u0026gt;is_pure_function(func)) { contains_impure_call = false; } else { contains_impure_call = true; } } } } } } /** * @brief 对单个循环执行不变式外提优化 * @param loop 要优化的循环 * */ void LoopInvariantCodeMotion::run_on_loop(std::shared_ptr\u0026lt;Loop\u0026gt; loop) { std::set\u0026lt;Value *\u0026gt; loop_instructions; std::set\u0026lt;Value *\u0026gt; updated_global; bool contains_impure_call = false; collect_loop_info(loop, loop_instructions, updated_global, contains_impure_call); for (auto global : updated_global) { LOG(DEBUG) \u0026lt;\u0026lt; \u0026#34;updated_global: \u0026#34; \u0026lt;\u0026lt; global-\u0026gt;get_name(); } std::vector\u0026lt;Value *\u0026gt; loop_invariant; // TODO: 识别循环不变式指令 // // - 如果指令已被标记为不变式则跳过 // - 跳过 store、ret、br、phi 等指令与非纯函数调用 // - 特殊处理全局变量的 load 指令 // - 检查指令的所有操作数是否都是循环不变的 // - 如果有新的不变式被添加则注意更新 changed 标志，继续迭代 bool changed; do { changed = false; for (auto inst : loop_instructions) { auto it = std::find(loop_invariant.begin(), loop_invariant.end(), inst); if (it != loop_invariant.end()) { continue; } auto instr = dynamic_cast\u0026lt;Instruction *\u0026gt;(inst); if (instr == nullptr) { continue; } if (instr-\u0026gt;get_instr_type() == Instruction::store || instr-\u0026gt;get_instr_type() == Instruction::ret || instr-\u0026gt;get_instr_type() == Instruction::br || instr-\u0026gt;get_instr_type() == Instruction::phi) { continue; } if (instr-\u0026gt;get_instr_type() == Instruction::call) { if (contains_impure_call) { continue; } } //特殊处理全局变量的load指令，如果是全局变量的load指令，且没有被更新过，则加入循环不变式 if (instr-\u0026gt;get_instr_type() == Instruction::load) { auto load_inst = dynamic_cast\u0026lt;LoadInst *\u0026gt;(instr); auto lval = load_inst-\u0026gt;get_lval(); if (dynamic_cast\u0026lt;GlobalVariable *\u0026gt;(lval) != nullptr) { LOG(DEBUG) \u0026lt;\u0026lt; \u0026#34;global_lval: \u0026#34; \u0026lt;\u0026lt; lval-\u0026gt;get_name(); if (updated_global.find(lval) == updated_global.end()) { LOG(DEBUG) \u0026lt;\u0026lt; \u0026#34;insert global inval \u0026#34; ; loop_invariant.push_back(instr); changed = true; continue; } else { continue; } } } //下面对其他的指令进行判断，如果不在循环中则加入循环不变式 //获得操作数，逐个检查是不是常数，是不是循环不变式，在当前循环中是否存在，当前循环找不到的话就是循环不变式 bool operands_are_invariant = true; for(auto operand : instr-\u0026gt;get_operands()) { if (loop_instructions.find(operand) != loop_instructions.end()) { if (std::find(loop_invariant.begin(), loop_invariant.end(), operand) == loop_invariant.end()) { //如果操作数都是循环不变式 //如果有一个不是循环不变式 operands_are_invariant = false; break; } } } if (operands_are_invariant) { loop_invariant.push_back(instr); changed = true; } //由于是递归分析 //不能用下面的方法，因为这样会导致循环不变式的增加，但是实际上这个循环不变式并不是循环不变式 // bool is_invariant = true; // for (auto operand : instr-\u0026gt;get_operands()) { // auto it = std::find(loop_invariant.begin(), loop_invariant.end(), operand); // if (it == loop_invariant.end()) { // is_invariant = false; // break; // } // } // if (is_invariant) { // loop_invariant.push_back(inst); // changed = true; // } } // throw std::runtime_error(\u0026#34;Lab4: 你有一个TODO需要完成！\u0026#34;); // LOG(DEBUG) \u0026lt;\u0026lt; \u0026#34;Loop invariant not done\u0026#34;; } while (changed); // LOG(DEBUG) \u0026lt;\u0026lt; \u0026#34;Loop invariant done\u0026#34;; if (loop-\u0026gt;get_preheader() == nullptr) { //如果没有前置块，则创建一个 auto name = \u0026#34;preheader\u0026#34; + std::to_string(label_num++); loop-\u0026gt;set_preheader( BasicBlock::create(m_, \u0026#34;\u0026#34;, loop-\u0026gt;get_header()-\u0026gt;get_parent())); } if (loop_invariant.empty()) return; // insert preheader auto preheader = loop-\u0026gt;get_preheader(); for (auto \u0026amp;phi_inst_ : loop-\u0026gt;get_header()-\u0026gt;get_instructions()) { //遍历循环头部的phi指令,如果遇到了非phi指令则退出 if (phi_inst_.get_instr_type() != Instruction::phi) break; // LOG(DEBUG) \u0026lt;\u0026lt; \u0026#34;phi_inst_:\u0026#34; \u0026lt;\u0026lt; phi_inst_.print(); //检查phi指令中所有非latch的前驱，改为preheader auto phi_inst = dynamic_cast\u0026lt;PhiInst *\u0026gt;(\u0026amp;phi_inst_); if (phi_inst == nullptr) { continue; } // auto num = static_cast\u0026lt;int\u0026gt;(phi_inst-\u0026gt;get_num_operand()); if (!preheader-\u0026gt;empty()) { //如果有br指令，需要删除,因为后面会重新插入 if (preheader-\u0026gt;is_terminated()) { auto \u0026amp;inst = preheader-\u0026gt;get_instructions().back(); if (inst.get_instr_type() == Instruction::br) { preheader-\u0026gt;remove_instr(\u0026amp;inst); } } continue; } else { //如果原本不存在preheader，即是创建的空的preheader,此时需要在preheader处插入一个新的phi指令用于替换，同时将原phi指令的前驱改为preheader // preheader-\u0026gt;add_instruction(phi_inst); auto new_phi = PhiInst::create_phi(phi_inst-\u0026gt;get_type(), preheader); preheader-\u0026gt;add_instruction(new_phi); // LOG(INFO) \u0026lt;\u0026lt; \u0026#34;preheader\u0026#34; \u0026lt;\u0026lt; preheader-\u0026gt;print(); auto val_bbs = phi_inst-\u0026gt;get_phi_pairs(); phi_inst-\u0026gt;remove_all_operands(); // LOG(INFO) \u0026lt;\u0026lt; \u0026#34;BEFORE phi——new: \u0026#34; \u0026lt;\u0026lt; new_phi-\u0026gt;print(); // LOG(INFO) \u0026lt;\u0026lt; \u0026#34;BEFORE phi: \u0026#34; \u0026lt;\u0026lt; phi_inst-\u0026gt;print(); for (auto val_bb : val_bbs) { auto val = val_bb.first; int flag = 0; auto val_new = static_cast\u0026lt;Instruction*\u0026gt;(val); if(!val-\u0026gt;get_name().empty()) { flag = 1; } auto bb = val_bb.second; // LOG(INFO) \u0026lt;\u0026lt; \u0026#34;bb: \u0026#34; \u0026lt;\u0026lt; bb-\u0026gt;print(); if (std::find(loop-\u0026gt;get_latches().begin(), loop-\u0026gt;get_latches().end(), bb) != loop-\u0026gt;get_latches().end()) { phi_inst-\u0026gt;add_phi_pair_operand(val, bb); continue; } if (flag == 1) { new_phi-\u0026gt;add_phi_pair_operand(val_new, bb); phi_inst-\u0026gt;add_phi_pair_operand(val_new, preheader); } else { new_phi-\u0026gt;add_phi_pair_operand(val, bb); phi_inst-\u0026gt;add_phi_pair_operand(val, preheader); } } } } // TODO: 用跳转指令重构控制流图 // 将所有非 latch 的 header 前驱块的跳转指向 preheader // 并将 preheader 的跳转指向 header // 注意这里需要更新前驱块的后继和后继的前驱 std::vector\u0026lt;BasicBlock *\u0026gt; pred_to_remove; auto latches_1 = loop-\u0026gt;get_latches(); auto header = loop-\u0026gt;get_header(); auto preds = header-\u0026gt;get_pre_basic_blocks(); for (auto pred : preds) { if (pred == preheader) { continue; } if (pred == nullptr) { std::cerr \u0026lt;\u0026lt; \u0026#34;Error: pred is nullptr\u0026#34; \u0026lt;\u0026lt; std::endl; continue; } if (!latches_1.empty() \u0026amp;\u0026amp; std::find(latches_1.begin(), latches_1.end(), pred) != latches_1.end()) { continue; } //创建跳转指令重构控制流图 if (pred-\u0026gt;is_terminated()) { // LOG(INFO) \u0026lt;\u0026lt; \u0026#34;chongjian\u0026#34;; auto \u0026amp;br_before = pred-\u0026gt;get_instructions().back(); if (br_before.get_instr_type() != Instruction::br) { continue; } else { auto br_11 = dynamic_cast\u0026lt;BranchInst *\u0026gt;(\u0026amp;br_before); // LOG(INFO) \u0026lt;\u0026lt; \u0026#34;br_11\u0026#34; \u0026lt;\u0026lt; br_11-\u0026gt;print(); pred-\u0026gt;remove_instr(\u0026amp;br_before); // LOG(DEBUG) \u0026lt;\u0026lt; \u0026#34;remove_instr_2: \u0026#34; \u0026lt;\u0026lt; br_before.print(); if (br_11-\u0026gt;is_cond_br()) { auto br_cond = br_11-\u0026gt;get_condition(); auto false_bb = static_cast\u0026lt;BasicBlock*\u0026gt;(br_11-\u0026gt;get_operand(2)); BranchInst::create_cond_br(br_cond, preheader, false_bb, pred); } else { BranchInst::create_br(preheader, pred); } } } pred_to_remove.push_back(pred); } header-\u0026gt;add_pre_basic_block(preheader); preheader-\u0026gt;add_succ_basic_block(header); for (auto \u0026amp;pred : pred_to_remove) { loop-\u0026gt;get_header()-\u0026gt;remove_pre_basic_block(pred); } // TODO: 外提循环不变指令 // throw std::runtime_error(\u0026#34;Lab4: 你有一个TODO需要完成！\u0026#34;); for (auto inst : loop_invariant) { LOG(INFO) \u0026lt;\u0026lt; \u0026#34;loop_invariant: \u0026#34; \u0026lt;\u0026lt; inst-\u0026gt;print(); auto instr = dynamic_cast\u0026lt;Instruction *\u0026gt;(inst); if (instr == nullptr) { continue; } if (preheader-\u0026gt;is_terminated()) { continue; } //遍历基本块，找到instr所在的基本块,并将instr从原基本块中删除 for (auto bb : loop-\u0026gt;get_blocks()) { if (instr-\u0026gt;get_parent() == bb) { bb-\u0026gt;remove_instr(instr); LOG(DEBUG) \u0026lt;\u0026lt; \u0026#34;remove_instr_1: \u0026#34; \u0026lt;\u0026lt; instr-\u0026gt;print(); } } preheader-\u0026gt;add_instruction(instr); } // insert preheader br to header BranchInst::create_br(loop-\u0026gt;get_header(), preheader); // insert preheader to parent loop if (loop-\u0026gt;get_parent() != nullptr) { loop-\u0026gt;get_parent()-\u0026gt;add_block(preheader); } } ","date":"2025-01-24T17:50:13+08:00","image":"http://localhost:1313/post/005.png","permalink":"http://localhost:1313/p/compiler/","title":"手动搭建编译器  基于龙芯汇编与LIGHTIR中间代码"},{"content":" \u0026mdash;\u0026mdash;by zyh 2025.1.6\n1.词法分析\r功能：将输入字符串识别为有意义的子串，即词法单元(token)\n1.1 词法单元的描述-正则式\r正则表达式(Regular Expression)是一种文本模式，包括普通字符（例如，a 到 z 之间的字母）和特殊字符（称为\u0026quot;元字符\u0026quot;），可以用来描述和匹配字符串的特定模式。\n一个简单的例子：正整数识别\n1 2 digit-\u0026gt;0|1|2|3|4|5|6|7|8|9 digits-\u0026gt;digit digit* 其中，*表示闭包，即出现零次或多次。\n下面是常用的一些正则表达式语法：\n常用语法：\n[abc] 匹配方括号中所有单字符，不一定按顺序； [^abc] 匹配除了方括号中字符外所有字符； [a-z] 匹配区间所有字符，注意大小写； [\\s\\S] 匹配所有。\\s 是匹配所有空白符，包括换行，\\S 非空白符，不包括换行； \\w 匹配字母、数字、下划线。等价于 [A-Za-z0-9_]； \\d 匹配任意一个阿拉伯数字（0 到 9）。等价于 [0-9]。 特殊字符：\n* 表示匹配前面的子表达式零次或多次； + 表示匹配前面的子表达式一次或多次； . 表示匹配除换行以外的任意字符； ? 表示匹配前面的子表达式零次或一次； | 表示两项之间选择。 如果要匹配特殊字符，需要在前面加上\\进行转义，\\本身也是特殊字符。\neg：匹配由偶数个0和奇数个1构成的01串：\n1 2 1(00|11)*((01|10)(00|11)*(01|10)(00|11)*)*|0(00|11)*(01|10) (00|11)*((01|10)(00|11)*(01|10)(00|11)*)* 1.2 词法单元的识别-转换图\r如下图的例子：\n1.3 有限自动机\rNFA：不确定的有限自动机\n如下图的例子(a|b)*ab（2是接受状态，两个圈画不出来）：\n1 2 3 4 5 6 graph LR begin--\u0026gt;a((0)) a((0))--a--\u0026gt;a((0)) a((0))--b--\u0026gt;a((0)) a((0))--a--\u0026gt;b((1)) b((1))--b--\u0026gt;c((2)) NFA对于一个token，有可能要尝试很多不同的路径，大部分都是白费功夫，效率很低。\nDFA：确定的有限自动机\n和上面一样的正则式，有如下图（2是接受状态）：\n1 2 3 4 5 6 7 8 graph LR begin--\u0026gt;a((0)) a((0))--b--\u0026gt;a((0)) a((0))--a--\u0026gt;b((1)) b((1))--a--\u0026gt;b((1)) b((1))--b--\u0026gt;c((2)) c((2))--a--\u0026gt;b((1)) c((2))--b--\u0026gt;a((0)) 语法制导的构造算法：NFA的构造(f表示接受状态)\n单字符（包括空ε）：\n1 2 3 graph LR begin--\u0026gt;a((i)) a((i))--ε/a--\u0026gt;b((f)) 选择式s|t：\n1 2 3 4 5 6 graph LR begin--\u0026gt;a((i)) a((i))--ε--\u0026gt;b(s) a((i))--ε--\u0026gt;c(t) b(s)--ε--\u0026gt;d((f)) c(t)--ε--\u0026gt;d((f)) st:\ns*:\n由上述算法即可得到NFA，具有下列性质：\nN(r)的状态数最多是r中符号和算符总数的两倍 N(r)只有一个接受状态，接受状态没有向外的转换 由NFA即可构造出DFA:从每个NFA构造时的i构成的集合出发，通过不同的输入符号构造出状态转移表，每个状态包含多个NFA中的状态。\nDFA的化简：先从终态集合和非终态集合出发，如果从非终态集合输入字符得到的输出集合不属于任何一个分割后的集合的子集，则可以继续分割，否则分割停止，最后可以得到化简后的DFA。\n2.语法分析\r2.1 上下文无关文法\r语法分析的目的是教会计算机判断输入合法性。\n上下文无关文法(CFG)就是说这个文法中所有的产生式左边只有一个非终结符，也就是说，只要找到符合产生式右边的串，就可以把它归约为对应的非终结符。\n$$\r(V_T,V_N,S,P)\r$$ VT是终结符集合，终结符是文法所定义的语言的基本符号，即token VN是非终结符集合，非终结符表示语法成分的符号，存放中间结果，也称为语法变量。 S是开始符号，属于非终结符，是该文法中最大的语法成分，分析开始的地方。 P是产生式集合，产生式描述了将终结符和非终结符组合成串的方法。 终结符集合与非终结符集合的交集为空。\n推导：是从文法推出文法所描述的语言中所包含的合法串集合的动作。\n也就是把符号串中的非终结符用其产生式右部的串来代替，有最左推导与最右推导等多种方式。\nCFG与正则表达式的联系和区别：\n正则表达式可以定义一些简单的语言，能表示给定结构的固定次数的重复或者没有指定次数的重复，但不能用于描述配对或嵌套的结构，因为有限自动机无法记录访问同一状态的次数；\n它们两个都能表示语言，能用正则表达式表示的语言都能用CFG表示。\n文法的二义性：文法的某些句子存在不止一种最左(最右)推导， 或者不止一棵分析树，则该文法是二义的。\n产生原因：有些操作都是左（右）结合的，但不同的优先级在文法中没有表达出来。\n消除办法：定义运算优先级和结合律。\n2.2 自顶向下分析方法\r自顶向下：针对输入串，从文法的开始符号出发，尝试根据产生式规则推导（derive）出该输入串。\n自底向上：针对输入串，尝试根据产生式规则归约（reduce）到文法的开始符号。\n2.2.1 递归下降语法分析\r数据结构：一个输入缓冲区和向前看指针lookahead\n分析过程：自左向右扫描输入串，设计一个辅助过程match()，将lookahead指向的位置与产生式迭代生成的终结符进行匹配，如匹配，将lookahead挪到下一个位置，为每一个非终结符写一个分析过程。\n2.2.2 消除左递归，提取左公因子\rS-\u0026gt;Sa|b这样的文法是左递归的，而自顶向下分析方法无法处理左递归，因为在输入缓冲区的lookahead指针纹丝未动。\n消除实例：\n1 2 3 4 5 直接左递归： A-\u0026gt;Aa|b 消除直接左递归： A-\u0026gt;bA\u0026#39; A\u0026#39;-\u0026gt;aA\u0026#39;|ε 1 2 3 4 5 6 7 8 9 10 非直接左递归： S-\u0026gt;Aa|b A-\u0026gt;Sd|ε 先变换成直接左递归： S-\u0026gt;Aa|b A-\u0026gt;Aad|bd|ε 再消除左递归： S-\u0026gt;Aa|b A-\u0026gt;bdA\u0026#39;|A\u0026#39; A\u0026#39;-\u0026gt;adA\u0026#39;|ε 提取左公因子其实也就是消除回溯：\n1 2 3 4 A-\u0026gt;aB1|aB2|aB3|B4 改为： A-\u0026gt;aA\u0026#39;|B4 A\u0026#39;-\u0026gt;B1|B2|B3 2.3 ll(1)文法\r两个和文法有关的函数：\n$$\rFIRST(α)=\\{a|a=\u003e*a...,a∈V_T\\}\r$$表示可从a推导得到的串的首符号的集合，具体计算时从左向右看，找产生式第一个终结符，若为非终结符则在其产生式中找。\n$$\rFOLLOW(A)=\\{a|S=\u003e*...Aa...,a∈V_T\\}\r$$表示可能在推导过程中紧跟在A右边的终结符号的集合，计算方法：\n文法开始符添加$，有下面两种情况：\nA-\u0026gt;aB 即B后为空，直接将FOLLOW(A)加入到FOLLOW(B)中； A-\u0026gt;aBb 即B后非空，若b为终结符，直接添加；若b为非终结符，则将FIRST(b)中的除ε添加到FOLLOW(B)中,若FIRST(b)中含有ε，则也把FOLLOW(A)加到FOLLOW(B)中 注意FIRST集合和FOLLOW集合都是针对非终结符的，且FIRST集合中只会出现终结符和ε\nan example:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 E-\u0026gt;TE\u0026#39; E\u0026#39;-\u0026gt;+TE\u0026#39;|ε T-\u0026gt;FT\u0026#39; T\u0026#39;-\u0026gt;*FT\u0026#39;|ε F-\u0026gt;(E)|id FIRST(E)=FIRST(T)=FIRST(F)={(,id} FIRST(E\u0026#39;)={+,ε} FIRST(T\u0026#39;)={*,ε} FOLLOW(E)={),$} FOLLOW(E\u0026#39;)=FOLLOW(E) FOLLOW(T)=FIRST(E\u0026#39;)-{ε}+FOLLOW(E\u0026#39;)={+,),$} FOLLOW(T\u0026#39;)=FOLLOW(T) FOLLOW(F)=FIRST(T\u0026#39;)-{ε}+FOLLOW(T\u0026#39;)={*,+,),$} ll(1)文法的性质：没有公共左因子，不是二义的，不含左递归\n由FIRST集与FOLLOW集可以得出LL(1)预测分析表：\n行为非终结符，列为终结符加上$，每个单元都是产生式，仍以上面例子为例：\nid + * ( ) $ E E-\u0026gt;TE' E-\u0026gt;TE' E' E\u0026rsquo;-\u0026gt;+TE' E\u0026rsquo;-\u0026gt;ε E\u0026rsquo;-\u0026gt;ε T T-\u0026gt;FT' T-\u0026gt;FT' T' T\u0026rsquo;-\u0026gt;ε T\u0026rsquo;-\u0026gt;*FT' T\u0026rsquo;-\u0026gt;ε T\u0026rsquo;-\u0026gt;ε F F-\u0026gt;id F-\u0026gt;(E) 构造规则：对文法的每个产生式A-\u0026gt;α，有如下操作：\n对FIRST(α)的每个终结符a，把A-\u0026gt;α加入M[A,a] 如果ε在FIRST(α)中，对FOLLOW(A)的每个终结符b（包括$），把A-\u0026gt;α加入M[A,b] 2.4 自底向上分析方法\r2.4.1 归约\r每一步，特定子串被替换为相匹配的某个产生式左部的非终结符，最终，把输入串归约成文法的开始符号。\n归约是最右推导的逆过程。\n2.4.2 句柄\r句柄(Handles)是指可规约串，和某个产生式右部匹配。\n句柄的右边仅含终结符，如果文法二义，那么句柄可能不唯一。\n2.4.3 移进-归约分析方法\r栈保存已扫描过的文法符号，缓冲区存放还未分析的其余符号；\n移进(shift)：将下一个输入符号放到栈顶，以形成句柄；\n归约(reduce)：将句柄替换为对应的产生式的左部非终结符；\n接受(accept)：分析成功；\n报错(error)：发现语法错误。\n$$\rE-\u003eE+E|E*E|(E)|id\r$$ stack input action $ id*id+id$ 移进 $id *id+id$ 按E-\u0026gt;id规约 $E *id+id$ 移进 $E* id+id$ 移进 $E*id +id$ 按E-\u0026gt;id规约 $E*E +id$ 移进 $E*E+ id$ 移进 $E*E+id $ 按E-\u0026gt;id规约 $E*E+E $ 按E-\u0026gt;E+E规约 $E*E $ 按E-\u0026gt;E*E规约 $E $ 接受 两类冲突：\n移进-归约冲突：解析器无法确定当前的输入是否应该作为一个终结符进行移进，还是应该作为一个非终结符进行归约。比如E-\u0026gt;A|Aa，如果此时stack为A，input为a\u0026hellip;$，此时无法判断进行移进还是规约。 归约-归约冲突：在解析过程中，解析器面对多个不同的产生式规则可以应用，但这些产生式规则的目标符号是相同的，无法确定应该应用哪个产生式。比如E-\u0026gt;a(B)|a,C-\u0026gt;a，如果此时stack为\u0026hellip;a(a，input为,a)\u0026hellip;$，此时无法判断规约到哪一个。 2.5 LR文法\r2.5.1 SLR分析\r活前缀（可行前缀）是指在解析过程中，解析器当前处理的输入串的一部分，并且该部分在当前状态下的所有可能后续扩展中都不包含任何产生式规则的左部（即产生式的左符号）。\n活前缀用于解决移进-归约冲突。\nLR分析方法的特点：栈中的文法符号总是形成一个活前缀；分析表的转移函数本质上是识别活前缀的DFA\nLR(0)项目：在右部的某个地方加点的产生式，加点的目的是用来表示分析过程中的状态。\n增广文法（拓广文法）：开始符E加上E\u0026rsquo;-\u0026gt;E。、\n$$\rE-\u003eE+T|T\\\\\rT-\u003eT*F|F\\\\\rF-\u003e(E)|id\r$$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 首先拓广文法： E\u0026#39;-\u0026gt;E E-\u0026gt;E+T|T T-\u0026gt;T*F|F F-\u0026gt;(E)|id 构造LR(0)项目集规范族： I0: E\u0026#39;-\u0026gt;·E----------------这个拓广得来的是初始项目，下面都是求闭包得来的 E-\u0026gt;·E+T E-\u0026gt;·T T-\u0026gt;·T*F T-\u0026gt;·F F-\u0026gt;·(E) F-\u0026gt;·id 这里的每个I构造规则：如果点后是产生式A-\u0026gt;a，且A-\u0026gt;·a不在闭包中，加入。\n人话：点后面如果是产生式就把产生式从头加个点添加到项目集中，单个项目集中重复的不算。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 我们可以得到其余的项目集（通过移进点后面的终结符或非终结符）： I0--E--\u0026gt;I1: E\u0026#39;-\u0026gt;E· E-\u0026gt;E·+T I0--T--\u0026gt;I2: E-\u0026gt;T· T-\u0026gt;T·*F I0--F--\u0026gt;I3: T-\u0026gt;F· I0--(--\u0026gt;I4: F-\u0026gt;(·E) E-\u0026gt;·E+T E-\u0026gt;·T T-\u0026gt;·T*F T-\u0026gt;·F F-\u0026gt;·(E) F-\u0026gt;·id I0--id--I5： F-\u0026gt;id· I1--+--\u0026gt;I6: E-\u0026gt;E+·T T-\u0026gt;·T*F T-\u0026gt;·F F-\u0026gt;·(E) F-\u0026gt;·id I2--*--\u0026gt;I7: T-\u0026gt;T*·F F-\u0026gt;·(E) F-\u0026gt;·id I4--E--\u0026gt;I8: F-\u0026gt;(E·) E-\u0026gt;E·+T I6--T--\u0026gt;I9: E-\u0026gt;E+T· T-\u0026gt;T·*F I7--F--\u0026gt;I10: T-\u0026gt;T*F· I8--)--\u0026gt;I11: F-\u0026gt;(E)· 这11个项目集组成了DFA的状态，可构造出如下的DFA：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 graph LR a((I_0))--E--\u0026gt;b((I_1)) b((I_1))--+--\u0026gt;c((I_6)) c((I_6))--T--\u0026gt;d((I_9)) a((I_0))--T--\u0026gt;e((I_2)) a((I_0))--F--\u0026gt;F((I_3)) a((I_0))--(--\u0026gt;G((I_4)) a((I_0))--id--\u0026gt;H((I_5)) e((I_2))--*--\u0026gt;I((I_7)) I((I_7))--F--\u0026gt;J((I_10)) G((I_4))--E--\u0026gt;K((I_8)) K((I_8))--)--\u0026gt;L((I_11)) c((I_6))--F--\u0026gt;F((I_3)) c((I_6))--(--\u0026gt;G((I_4)) c((I_6))--id--\u0026gt;H((I_5)) I((I_7))--(--\u0026gt;G((I_4)) I((I_7))--id--\u0026gt;H((I_5)) K((I_8))--+--\u0026gt;c((I_6)) G((I_4))--(--\u0026gt;G((I_4)) G((I_4))--T--\u0026gt;e((I_2)) G((I_4))--F--\u0026gt;F((I_3)) G((I_4))--id--\u0026gt;H((I_5)) d((I_9))--*--\u0026gt;I((I_7)) mermaid画的，有点抽象哈QAQ\n由上面的DFA可构造出SLR分析表，规则如下：\n如果A-\u0026gt;α·aβ在Ii中，并且goto(Ii,a)=Ij，将action[i,a]置为sj 如果A-\u0026gt;α·在Ii中，对FOLLOW(A)中所有a，置action[i,a]为rj，j是产生式A-\u0026gt;α的初始编号 如果S\u0026rsquo;-\u0026gt;S·在Ii中，置action[i,$]为acc 在这个规则中s表示移进，r表示规约，可以看出，如果一个Ii中同时存在·在末尾与在中间的情况时，会出现action[i,a]同时置为rj与sj的情况，也就是移进-归约冲突，此时比较两个左式的FOLLOW集，如果下一个输入符号属于归约的那个左式的FOLLOW集，那么使用归约，反之使用移进。比如该题的I2和I9就存在移进归约冲突，但计算FOLLOW(E)={),+,$},I2和I9的下一个符号为*，不在FOLLOW(E)中，所以均采用移进。\n该例的SLR分析表如下所示：\n(1)E-\u0026gt;E+T\n(2)E-\u0026gt;T\n(3)T-\u0026gt;T*F\n(4)T-\u0026gt;F\n(5)F-\u0026gt;(E)\n(6)F-\u0026gt;id\nid + * ( ) $ E T F 0 s5 s4 1 2 3 1 s6 acc 2 r2 s7 r2 r2 3 r4 r4 r4 r4 4 s5 s4 8 2 3 5 r6 r6 r6 r6 6 s5 s4 9 3 7 s5 s4 10 8 s6 s11 9 r1 s7 r1 r1 10 r3 r3 r3 r3 11 r5 r5 r5 r5 2.5.2 LR分析\rSLR文法产生移进归约冲突，但该文法不是二义的。\n在识别活前缀DFA的状态中，增加信息，排除一些不正确的归约操作。\nSLR只是简单地考察下一个输入符号b是否属于与归约项目A→α相关联的FOLLOW(A)，但b∈FOLLOW(A)只是归约α的一个必要条件，而非充分条件。归约条件被放宽松了。\n项目集：LR(0)=\u0026gt;LR(1)\nLR(1)项目由两个分量组成，第一分量为SLR中的项，第二分量为搜索符（向前看符号），1代表了搜索符a的长度。\n对于[A-\u0026gt;α·β,a]当β不为空时，a不起作用，当β为空时，如果下一个输入符号是a，将按照A-\u0026gt;α进行归约，a的集合是FOLLOW(A)的子集。\nLR(1)闭包计算方法与LR(0)有所不同，若有项目[A-\u0026gt;α·Bβ,a]在闭包中，而B-\u0026gt;γ是文法中的产生式，b是FIRST(βa)中的元素，则[B-\u0026gt;γ，b]也属于闭包。\n$$\r0)S'-\u003eS\\\\\r1)S-\u003eL=R\\\\\r2)S-\u003eR\\\\\r3)L-\u003e*R\\\\\r4)L-\u003eid\\\\\r5)R-\u003eL\r$$ 则可以得到如下所示的LR(1)项目集规范族：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 I0: S\u0026#39;-\u0026gt;·S,$-----S\u0026#39;的搜索符一定是$,因为S\u0026#39;表示规约到了最后,FIRST($)=$ S-\u0026gt;·L=R,$---------FIRST(=R$)=\u0026#34;=\u0026#34;[对于L] S-\u0026gt;·R,$-----------FIRST($)=$[对于R] L-\u0026gt;·*R,= L-\u0026gt;·id,= R-\u0026gt;·L,$-----------FIRST($)=$[对于L] L-\u0026gt;·*R,$ L-\u0026gt;·id,$ I0--S--\u0026gt;I1: S\u0026#39;-\u0026gt;S·,$ I0--L--\u0026gt;I2: S-\u0026gt;L·=R,$ R-\u0026gt;L·,$ I0--R--\u0026gt;I3: S-\u0026gt;R·,$ I0--*--\u0026gt;I4: L-\u0026gt;*·R,=-----------FIRST(=)=\u0026#34;=\u0026#34;[对于R] L-\u0026gt;*·R,$-----------FIRST($)=$[对于R] R-\u0026gt;·L,=------------FIRST(=)=\u0026#34;=\u0026#34;[对于L] R-\u0026gt;·L,$------------FIRST($)=$[对于L] L-\u0026gt;·*R,= L-\u0026gt;·*R,$ L-\u0026gt;·id,= L-\u0026gt;·id,$ I4--id--\u0026gt;I5: L-\u0026gt;id·,= L-\u0026gt;id·,$ I2--=--\u0026gt;I6: S-\u0026gt;L=·R,$----------FIRST($)=$[对于R] R-\u0026gt;·L,$------------FIRST($)=$[对于L] L-\u0026gt;·*R,$ L-\u0026gt;·id,$ I4--R--\u0026gt;I7: L-\u0026gt;*R·,= L-\u0026gt;*R·,$ I4--L--\u0026gt;I8: R-\u0026gt;L·,= R-\u0026gt;L·,$ I6--R--\u0026gt;I9: S-\u0026gt;L=R·,$ I6--L--\u0026gt;I10: R-\u0026gt;L·,$ I6--*--\u0026gt;I11: L-\u0026gt;*·R,$------------FIRST($)=$[对于R] R-\u0026gt;·L,$-------------FIRST($)=$[对于L] L-\u0026gt;·*R,$ L-\u0026gt;·id,$ I6--id--\u0026gt;I12: L-\u0026gt;id·,$ I11--R--\u0026gt;I13: L-\u0026gt;*R·,$ 如果一个项目中两个或多个式子只是搜索符不同，可以写在一起；如果两个项目除搜索符外相同，则这两个项目集是同心的。\nDFA如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 graph LR A((I_0))--S--\u0026gt;B((I_1)) A((I_0))--L--\u0026gt;C((I_2)) A((I_0))--R--\u0026gt;D((I_3)) A((I_0))--*--\u0026gt;E((I_4)) A((I_0))--id--\u0026gt;F((I_5)) C((I_2))--=--\u0026gt;G((I_6)) G((I_6))--R--\u0026gt;H((I_9)) G((I_6))--L--\u0026gt;I((I_10)) G((I_6))--*--\u0026gt;J((I_11)) G((I_6))--id--\u0026gt;K((I_12)) E((I_4))--R--\u0026gt;L((I_7)) E((I_4))--L--\u0026gt;M((I_8)) E((I_4))--id--\u0026gt;F((I_5)) E((I_4))--*--\u0026gt;E((I_4)) J((I_11))--R--\u0026gt;O((I_13)) J((I_11))--id--\u0026gt;K((I_12)) J((I_11))--L--\u0026gt;I((I_10)) J((I_11))--*--\u0026gt;J((I_11)) 则我们可以得到如下所示的LR(1)分析表：\n* id = $ S L R 0 s4 s5 1 2 3 1 acc 2 s6 r5 3 r2 4 s4 s5 8 7 5 r4 r4 6 s11 s12 10 9 7 r3 r3 8 r5 r5 9 r1 10 r5 11 s11 s12 10 13 12 r4 13 r3 每一个SLR(1)文法都是LR(1)的。\n3.中间代码\r3.1 中间代码分析\r编译器前端与后端分离，这样为新机器构建编译器只用设计从中间代码到目标机器代码的编译器即可，并且中间代码优化与源语言和目标机器均无关。\n常见的中间代码类型：\n后缀表示 语法树或DAG图 三地址码（TAC) 静态单赋值形式（SSA） 后缀表示不需要括号，便于计算机处理表达式。\n语法树是一种图形化的中间表示，DAG是有向无环图：\n三地址代码：x= y op z【最多一个算符，最多三个计算分量，每一个分量代表一个地址】\n三地址代码是语法树或DAG的一种线性表示。\n常用的三地址语句：\n运算、赋值：x=y op z,\tx = op y,\tx = y 无条件转移：goto L 条件转移：if x goto L,if False x goto L,if x relop y goto L 过程调用：param x1,param x2,call p ,n(前面设置参数,p为子过程，n为参数) 过程返回：return y 索引赋值：x=y[i],x[i]=y 地址和指针：x=\u0026amp;y,x=*y,*x=y 静态单赋值形式：和三地址代码差不多，但所有赋值指令都是对不同名字的变量的赋值，同一个变量在不同控制流路径上都被定值。\n基本块：首指令：指令序列的第一条三地址指令；任意转移指令的目标指令；紧跟一个转移指令的指令。由首指令(leader)可以划分出基本块(basicblock)。\n流图的节点是一些基本块，从基本块B到基本块C之间有一条边，当且仅当C的第一个指令可能紧跟在B的最后一条指令之后执行，称B是C的前驱(predecessor)，C是B的后继(successor)。\n流图中的一个结点集合L是一个循环，需满足：该集合有唯一的入口结点；集合结点都有一个到达入口结点的非空路径，且该路径全部在L中。\n3.2 语法制导翻译\r编译程序的目标：将源程序翻译成为语义等价的目标程序，源程序与目标程序具有不同的语法结构，表达的结果却是相同的。\n语法制导翻译：使用上下文无关文法(CFG)来引导对语言的翻译，是一种面向文法的翻译技术。通过给语法树上各个符号赋予一定的含义，并且将各个符号进行有结构的连接，可以形成语言的具体语句的含义。这给予我们以启示：可以通过扩充文法， 在文法符号上附着某些语义信息，并在这些语义信息间建立相互计算关系，从而在语法分析的同时进行语义分析。 由于这种分析是在语法分析的控制下进行的，故称为语法制导翻译。\n语法制导定义（SSD）：\n基础的上下文无关文法，每个文法符号有一组属性，每个文法产生式A-\u0026gt;α有一组形式为b=f(c1,c2,\u0026hellip;,ck)的语义规则，其中f是函数，b和c1,c2,\u0026hellip;,ck是该产生式文法符号的属性。\n两种属性：\n综合属性：用于自下而上传递信息；在语法树中，一个结点的综合属性由其子 结点的属性值确定，因此，通常使用自底向上的方法在每一个结点处使用语义规则计算综合属性的值。仅仅使用综合属性的属性文法称S-属性文法。 继承属性：用于自上而下传递信息；在语法树中，一个结点的继承属性由此结 点的父结点和/或兄弟结点的某些属性确定。 3.2.1 S属性定义\r仅仅使用综合属性的语法制导定义称为S属性的SDD,或S-属性定义，S-SDD\n如果一个SDD是S属性的，可以按照语法分析树节点的任何自底向上顺序来计算它的各个属性值;S-属性定义可在自底向上的语法分析过程中实现，如LR分析器。\n$$\rS-\u003eDSD|2\\\\\rD-\u003e0|1\r$$ solution:\n1 2 3 4 5 S\u0026#39;-\u0026gt;S\tprint(S.val) S-\u0026gt;D_1S_1D_2\tS.val = (D_1.val == D_2.val) and S_1.val S-\u0026gt;2\tS.val = true D-\u0026gt;0\tD.val = 0 D-\u0026gt;1\tD.val = 1 3.2.2 L属性定义\r在一个产生式所关联的各属性之间，依赖图的边可以从左到右，但不能从右到左，可以在LR分析器或LL分析器中实现，更加一般化。\n依赖图(dependency graph)是一个描述了分析树中结点属性间依赖关系的有向图，其中属性值为点，属性的依赖关系为边（如果X.a的值依赖于Y.b的值，则依赖图中有从Y.b的结点指向X.a的结点的有向边。\n对于任意一个产生式A-\u0026gt;X1X2\u0026hellip;Xn，其右部符号Xi的继承属性仅依赖于下列属性：\nA的继承属性 产生式Xi左边符号X1X2\u0026hellip;Xi-1的属性 Xi本身的属性，但Xi全部属性不能在依赖图中形成环路 不能依赖A的综合属性的原因：由于A的综合属性可能依赖Xi的属性，包括Xi的综合属性和继承属性，因此可能形成环路。\n一个例子：\n产生式 语义规则 D-\u0026gt;TL L.in = T.type T-\u0026gt;int T.type = integer T-\u0026gt;real T.type = real L-\u0026gt;L1,id L1.in = L.in;addType(id.entry,L.in) L-\u0026gt;id addType(id.entry,L.in) 在上面的表中，L.in是L的继承属性，type是T的综合属性，addType是把类型加到符号表中的标识符条目里（副作用）\n一个没有副作用的SDD称为属性文法，属性文法增加了语义规则描述的复杂度。\n受控的副作用：不会对属性求值产生约束，即可以按照任何拓扑顺序求值，不会影响最终结果。\n3.2.3 抽象语法树的构造\r抽象语法树(AST)，简称语法树，是分析树的浓缩表示：算符和关键字作为内部节点；语法制导翻译可基于分析树，也可基于语法树。\n数据结构：\n对基本运算对象结点： 一个域存放运算对象类别 另一个域存放其值（也可用其他域保存或其它属性或指向该属性值的指针） 对算符结点： 一个域存放算符并作为该结点的标记 其余两个域存放指向运算对象的指针 函数：\nmknode(op,left,right)：建立运算符号结点。 mkleaf(id,entry)：建立标识符结点。 mkleaf(num,val)：建立数结点。 3.2.3.1 S属性AST\r以算数表达式为例，其中nptr综合属性表示文法符号对应的抽象语法树结点。\n产生式 语义规则 E-\u0026gt;E1+T E.nptr = mkNode(\u0026rsquo;+\u0026rsquo;,E1.nptr,T.nptr) E-\u0026gt;T E.nptr = T.npt T-\u0026gt;T1*F E.nptr = mkNode(\u0026rsquo;*\u0026rsquo;,T1.nptr,F.nptr) T-\u0026gt;F T.nptr = F.nptr F-\u0026gt;(E) F.nptr = E.nptr F-\u0026gt;id F.nptr = mkLeaf(id,id.entry) F-\u0026gt;num F.nptr = mkLeaf(num,num.val) 3.2.3.2 L属性AST\r首先消除左递归，将原产生式改为：\n1 2 3 4 5 6 7 8 9 E-\u0026gt;ER R-\u0026gt;+TR1 R-\u0026gt;ε T-\u0026gt;FW W-\u0026gt;*FW1 W-\u0026gt;ε F-\u0026gt;(E) F-\u0026gt;id F-\u0026gt;num 部分如下：\n产生式 语义规则 T-\u0026gt;FW W.i = F.nptr;T.nptr = W.s W-\u0026gt;*FW1 W1.i=mkNode(\u0026rsquo;*\u0026rsquo;,W.i,F.nptr);W.s=W1.s W-\u0026gt;ε W.s = W.i F-\u0026gt;id F.nptr = mkLeaf(id,id.entry) F-\u0026gt;num F.nptr = mkLeaf(num,num.val) S-SDD与L-SDD的AST都是一样的，但分析树却是不同的，S-SDD的分析树与AST比较接近，L-SDD的分析树与AST结构不同。\n3.2.4 语法制导翻译方案\r语法制导翻译方案(SDT)是在产生式右部中嵌入了程序片段(称为语义动作)的CFG\nSDT可以看作是SDD的具体实施方案。\n将每个语义动作都放在产生式的最后并用大括号括起来就将S-SDD转换为了SDT\n3.2.4.1 S属性定义的SDT两种实现方式\r3.2.4.1.1 先建树，后计算\r建立语法分析树，将语义动作看作是虚拟结点，从左到右，深度优先遍历分析树，在访问虚拟结点时执行相应动作。如下图所示：\n3.2.4.1.2 边分析，边计算\r综合属性通过自底向上的LR来计算，当归约发生时执行相应语义动作。\n可以通过扩展的LR语法分析栈来实现，每一个栈元素包含状态，文法符号和综合属性这三个域。\n在上图中，L-\u0026gt;En的代码段：栈中先存入E，后存入n，栈顶指针top指向n，故top-1指向E，打印其在栈的对应值的域即可；E-\u0026gt;E1+T的代码段：栈中先后存入E1,+,T，栈顶指针top指向T，故top-2指向E1，直接弹出三个元素，下一个要存的E可以放在top-2的位置上；其余的类似，不作过多解释。\n3.2.4.2 L属性定义的SDT两种实现方式\rS属性定义属于L属性定义。\n消除左递归的算术表达式语法制导定义是L-SDD，后缀SDT在这里并不适用。\n将L-SDD转换为SDT的规则：\n将计算一个产生式左部符号的综合属性的动作放置在这个产生式右部的最右端 将计算某个非终结符号A的继承属性的动作插入到产生式右部中紧靠在A的本次出现之前的位置上 多个继承属性要考虑次序，防止形成环 以3.2.2中给出的L-SDD的例子来构造L-SDT：\n1 2 3 4 5 D-\u0026gt;T {L.in = T.type} L T-\u0026gt;int {T.type = integer} T-\u0026gt;real {T.type = real} L-\u0026gt;{L1.in = L.in} L1,id {addType(id.entry,L.in)} L-\u0026gt;id {addType(id.entry,L.in)} 以前两个为例，D-\u0026gt;TL，由于语义规则L.in = T.type是计算非终结符号L的继承属性，所以放在L之前紧靠着L；T-\u0026gt;int，由于语义规则T.type = integer是计算左部符号T的综合属性type的，所以放在最右端。\n3.2.4.2.1 与递归下降分析结合\r递归下降翻译器的设计：\n为每个非终结符A构造一个函数 A的每个继承属性对应该函数的一个形参 函数的返回值是A的综合属性值 在函数体中： 首先选择适当的A的产生式 用局部变量保存产生式中文法符号的属性 对产生式体中的终结符号，读入符号并获取其综合属性（由词法分析得到） 对产生式体中的非终结符，调用相应函数，记录返回值 产生式R-\u0026gt;+TR|ε的递归下降分析过程：\n1 2 3 4 5 6 7 void R(){ if (lookahead == \u0026#39;+\u0026#39;) { match(\u0026#39;+\u0026#39;); T(); R(); } else {} } 3.2.4.2.2 与LR分析结合\r将产生式中嵌入的动作删除，挪到产生式最右端，具体来说，对于产生式A-\u0026gt;α{a}β，a是语义动作，引入新的非终结符M，代替{a}，形成A-\u0026gt;αMβ，同时引入新的产生式M-\u0026gt;ε，修改a得到a\u0026rsquo;，将a需要的A或者α中的属性作为M的继承属性进行复制，按照a中的方法计算各属性，将这些属性作为M的综合属性保存起来，最后将{a\u0026rsquo;}与M-\u0026gt;ε关联起来。\neg:原：A-\u0026gt;{B.i=f(A.i)}BC，修改后为：A-\u0026gt;MBC,M-\u0026gt;ε{M.i=A.i;M.s=f(M.i)}\n3.3 中间代码生成\r3.3.1 布尔表达式的控制流翻译\r布尔表达式有两个基本目的：计算逻辑值，在控制流语句中用作条件表达式。\n布尔运算符：or,and,not\n关系运算符relop:\u0026lt;,\u0026lt;=,=,≠,\u0026gt;,\u0026gt;=\n布尔常量：true,false\n用控制流来实现计算：布尔运算符and,or,not不出现在翻译后的代码中，用程序中的位置来表示值。\neg:翻译：if (x\u0026lt;3 or x\u0026gt;5 and x!=y) x=10;\n1 2 3 4 5 6 7 8 if x\u0026lt;3 goto L2 goto L3 L3:\tif x\u0026gt;5 goto L4 goto L1 L4:\tif x!=y goto L2 goto L1 L2:\tx = 10 L1: 注意布尔运算符的优先级，not具有最高优先级，and次之，or最低\n布尔表达式控制流翻译SDD：\nB-\u0026gt;B1 or B2\n1 2 3 4 5 6 语义规则： B1.true = B.true; B1.false = newLabel(); B2.true = B.true; B2.false = B.false; B.code = B1.code || gen(B1.false,\u0026#39;:\u0026#39;) || B2.code B-\u0026gt;B1 and B2\n1 2 3 4 5 6 语义规则： B1.true = newLabel(); B1.false = B.false; B2.true = B.true; B2.false = B.false; B.code = B1.code || gen(B1.true,\u0026#39;:\u0026#39;) || B2.code B -\u0026gt;E1 relop E2\n1 2 语义规则： B.code = E1.code || E2.code || gen(\u0026#39;if\u0026#39;,E1.place,relop.op,E2.place,\u0026#39;goto\u0026#39;,B.true) || gen(\u0026#39;goto\u0026#39;,B.false) B-\u0026gt;(B1)\n1 2 3 4 语义规则： B1.true = B.true; B1.false = B.false; B.code = B1.code B-\u0026gt;not B1\n1 2 3 4 语义规则： B1.true = B.false; B1.false = B.true; B.code = B1.code B-\u0026gt;true/false\n1 2 语义规则： B.code = gen(\u0026#39;goto\u0026#39;,B.true/false) B.true和B.false都是继承属性，需要两趟分析来计算，第一趟生成语法树，第二趟dfs计算属性值。\n3.3.2 基于符号回填的布尔表达式翻译\r布尔表达式短路计算翻译中，产生了转移目标不明确的条件或无条件代码。\n解决方案：当生成跳转指令时，暂时不指定目标地址，当有关目标地址确定后，再填回到翻译代码中。\n具体实现：将有相同转移目标的转移代码的编号串起来形成链，可以方便回填目标地址。该list变成了综合属性，可以与LR结合。\n此时我们有两个综合属性：\nB.truelist：代码中所有转向真出口的代码指令链； B.falselist：所有转向假出口的代码指令链。 在生成B的代码时，跳转指令goto是不完整的，目标标号尚未填写，用truelist和falselist来管理。\n相关函数：\nmakelist(i)，创建含标号为i的指令的链表 backpatch(instruction-list,target-label)，将目标地址填回list中每条指令 merge(instruction-list1,instruction-list2)，合并两个链，当两个链中每条指令都会跳转到同一条指令时执行此操作 基于回填的布尔表达式翻译SDD(下面用的是LR分析)：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 B-\u0026gt;not B1 { B.truelist = B1.falselist; B.falselist = B1.truelist; } B-\u0026gt;(B1) { B.truelist = B1.truelist; B.falselist = B1.falselist; } B-\u0026gt;true/false { B.truelist/falselist = makelist(nextinstr); //这里因为要回填的是下面gen的goto语句，所以是nextinstr gen(\u0026#39;goto\u0026#39;,-); //-表示需要回填 } B-\u0026gt;E1 relop E2 { B.truelist = makelist(nextinstr); B.falselist = makelist(nextinstr+1); gen(\u0026#39;if\u0026#39;,E1.place,relop.op,E2.place,\u0026#39;goto\u0026#39;,\u0026#39;-\u0026#39;); gen(\u0026#39;goto\u0026#39;,-); } B-\u0026gt;B1 or M B2 { backpatch(B1.falselist,M.instr); B.truelist = merge(B1.truelist,B2.truelist); B.falselist = B2.falselist; //这里的M是为了保存B2开始的第一条指令：M-\u0026gt;ε {M.instr = nextinstr} } B-\u0026gt;B1 and M B2 { backpatch(B1.truelist,M.instr); B.falselist = merge(B1.falselist,B2.falselist); B.truelist = B2.truelist; } 3.3.3 基于符号回填的其它语句翻译\r对一般语句而言，有一个综合属性：S.nextlist，表示代码中所有跳转到紧跟S的代码之后的指令。\n用S表示一条语句，用L表示语句列表，则有如下的文法和LR分析翻译方案：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 S-\u0026gt;if B then M S1 { //这里的B是上面的布尔表达式 backpatch(B.truelist,M.instr); S.nextlist = merge(B.falselist,S1.nextlist); } M-\u0026gt;ε {M.instr = nextinstr} S-\u0026gt;if B then M1 S1 N else M2 S2 { backpatch(B.truelist,M1.instr); backpatch(B.falselist,M2.instr); temp = merge(S1.nextlist,N.nextlist); S.nextlist = merge(temp,S2.nextlist); } N-\u0026gt;ε { N.nextlist = makelist(nextinstr); gen(\u0026#39;goto\u0026#39;,-); } S-\u0026gt;while M1 B do M2 S1 { backpatch(B.truelist,M2.instr); backpatch(S1.nextlist,M1.instr); S.nextlist = B.falselist; gen(\u0026#39;goto\u0026#39;,M1.instr) } S-\u0026gt;A {S.nextlist = {};} //赋值语句 S-\u0026gt;{L} {S.nextlist = L.nextlist} L-\u0026gt;S {L.nextlist = S.nextlist} L-\u0026gt;L1;M S { backpatch(L1.nextlist,M.instr); L.nextlist = S.nextlist; } 3.4 类型表达式\r类型表达式(type expression):基本类型是类型表达式，可为类型表达式命名，类名也是类型表达式，将类型构造算子作用于类型表达式可以构造新的类型表达式。\n比如数组类型构造算子array和类型表达式integer，int[3]的类型表达式为array(3,integer)，在此基础上再作用一遍为array(2,array(3,integer))，表示int[2][3]仍为类型表达式。\n常见构造算子：\n数组类型构造算子array 指针类型构造算子pointer 笛卡尔乘积类型算子× 函数类型构造算子-\u0026gt; 记录类型构造算子record an example:\n1 2 3 4 5 6 7 8 9 10 11 12 13 typedef struct{ int address; char lexeme[15]; }row; row table[101]; row *p; 则row的类型表达式： record((address×integer)×(lexeme×(array(15,char)))) table的类型表达式： array(101,row) p的类型表达式： pointer(row) 由上述定义我们可以构造类型表达式的SDD与SDT：\n首先为每个文法符号设置综合属性t与继承属性b：\nt是指该符号对应的类型表达式，b表示将类型信息从左到右传递。\n比如下面的文法的SDD：\n产生式 语义规则 T-\u0026gt;BC T.t = C.t; C.b = B.t B-\u0026gt;int B.t = integer B-\u0026gt;float B.t = float C-\u0026gt;[num]C1 C.t = array(num.val,C1.t); C1.b = C.b C-\u0026gt;ε C.t = C.b 由上面的SDD可直接改造为SDT：\n1 2 3 4 5 T-\u0026gt;B {C.b = B.t} C {T.t = C.t;} B-\u0026gt;int {B.t = integer} B-\u0026gt;float {B.t = float} C-\u0026gt;[num] {C1.b = C.b} C1 {C.t = array(num.val,C1.t);} C-\u0026gt;ε {C.t = C.b} 如果要使用LR，同样需要改造文法，参考3.2.4.2.2的改造方法，如下所示：\n1 2 3 4 5 6 7 T-\u0026gt;B M C {T.t = C.t;} M-\u0026gt;ε {M.t = B.t} B-\u0026gt;int {B.t = integer} B-\u0026gt;float {B.t = float} C-\u0026gt;[num] N C1 {C.t = array(num.val,C1.t);} N-\u0026gt;ε {N.t = C.b} C-\u0026gt;ε {C.t = C.b} 3.5 符号表与声明语句翻译\r符号表(symbol table)用于编译过程的分析与合成，如使用前声明检查，确定作用域，内存空间分配，类型表达式构造等等，其使用和修改伴随着编译的全过程。\n声明语句翻译的要点：\n分配存储单元 名字、类型、字宽、偏移 作用域的管理 过程调用 记录类型的管理 不产生中间代码指令，但要更新符号表 符号表的组织与管理：\n各过程有各自的符号表：哈希表 符号表之间有双向链 父-\u0026gt;子：过程中包含哪些子过程定义 子-\u0026gt;父：分析完子过程后继续分析父过程 维护符号表栈和地址偏移量栈（保存尚未完成的过程的符号表指针和相对地址） 3.6 数组寻址翻译\r$$\ri×w+(base-low×w)\r$$ 其中，base是整个数组的基地址，也是分配给该数组的内存块的相对地址；low是下标的下界；w是每个数组元素的宽度。这样写因为low×w是常量，在编译时计算，减少了运行时计算。\n$$\rbase+((i-low_1)×n_2+(j-low_2))×w\r$$$$\r((i_1×n_2)+i_2)×w+(base-((low_1×n_2)+low_2)×w)\r$$$$\r((...((i_1×n_2+i_2)×n_3+i_3)...)×n_k+i_k)×w+base-((...((low_1×n_2+low_2)×n_3+low_3)...)×n_k+low_k)×w\r$$4.运行时管理\r4.1 存储组织\r编译器必须为源程序中出现的一些数据对象分配运行时的存储空间，包括静态存储分配与动态存储分配，对于那些在编译时刻就可以确定大小的数据对象，可以在编译时刻就为它们分配存储空间，这样的策略成为静态存储分配，如果不能在编译时刻完全确定数据对象的大小，就要采用动态存储分配的策略。即，在编译时刻仅产生各种必要的信息，而在运行时刻，再动态地分配存储空间。包括栈式存储分配与堆式存储分配，静态和动态这两个概念分别对应编译时刻和运行时刻。\n名字的作用域：一个声明起作用的程序部分称为该声明的作用域，即使一个名字在程序中只声明一次，该名字在程序运行时也可能表示不同的数据对象。\n环境和状态：\n环境把名字映射到左值，而状态把左值映射到右值（即名字到值有两步映射） 赋值改变状态，但不改变环境 过程调用改变环境 如果环境将名字x映射到存储单元s，则说x被绑定到s 局部数据的分布：\n字节是可编址内存的最小单位 变量所需的存储空间可以根据其类型而静态确定 一个过程所声明的局部变量，按这些变量声明时出现的次序，在局部数据域中依次分配空间 局部数据的地址可以用相对于活动记录中某个位置的地址来表示 数据对象的存储布局还有一个对齐问题 4.2 空间的栈式分配\r对于支持过程、函数和方法的语言，其编译器通常会用栈的形式来管理其运行时刻存储当一个过程被调用时，该过程的活动记录被压入栈中；当过程结束时，记录被弹出这种安排不仅允许活跃时段不交叠的多个过程调用共享空间；而且可以使得过程的非局部变量的相对地址总是固定的，和调用序列无关。\n活动树：用来描述程序运行期间控制进入和离开各个活动的情况的树，树中的每个结点对应于一个活动。根结点是启动程序执行的main过程的活动。\n运行栈：把控制栈中的信息拓广到包括过程活动所需的所有局部信息。\n代码序列 过程调用和过程返回都需要执行一些代码来管理活动记录栈，保存或恢复机器状态等 过程调用序列 过程调用时执行的分配活动记录，把信息填入它的域中，使被调用过程可以开始执行的代码 过程返回序列 被调用过程返回时执行的恢复机器状态，释放被调用过程活动记录，使调用过程能够继续执行的代码 调用序列和返回序列常常都分成两部分，分处于调用过程和被调用过程的活动记录中。 C语言活动记录结构：\n临时数据 局部数据 机器状态 控制链 返回值 参数 Pascal语言活动记录结构：\n临时数据 局部数据 机器状态 访问链 控制链 返回值 参数 4.3 非局部名字的访问\r无过程嵌套的数据访问\n过程体中的非局部引用可以直接使用静态确定的地址 (非局部数据此时是全局数据) 局部变量在栈顶的活动记录中，可以通过 base_sp 指针访问 无须深入栈中取数据，无须访问链 有过程嵌套的静态作用域\n一个过程的声明包含另一个过程的声明，嵌套的子过程可以使用父过程的局部变量 子过程代码被激活执行，要找到父过程的活动记录，需要建立访问链 嵌套深度\n过程嵌套深度：主程序为 1，进入一个被包围的过程加 1 变量的嵌套深度：声明所在过程的嵌套深度为该名字的嵌套深度 过程嵌套的静态作用域在活动记录中增加访问指针形成访问链\n用来寻找非局部名字的存储单元 假设p直接嵌套在q中，则p活动记录的访问链指针指向最靠近的q的活动记录 两个关键问题需要解决\n通过访问链访问非局部引用 访问链的建立 过程p的嵌套深度n_p，引用嵌套深度为n_a的变量 a\n追踪访问链n_p-n_a次 到达a所在的活动记录 访问链的追踪可以间接操作完成 过程p的嵌套深度n_p，调用嵌套深度为n_x的过程 x\nn_p\u0026lt;n_x，x 在 p 中，被调用过程的访问链必须hi想调用过程的活动记录的访问链 n_p\u0026gt;= n_x，找到公共祖先，也就是过程x的最近的n_x-1深度的过程，沿着访问呢连追踪n_p-n_x+1次 参数传递\n形参，存储单元 (左值)，引用调用 实参，存储内容 (右值)，传值调用 堆管理\n堆用于存放生命周期不确定、或生存到明确删除为止的数据对象 new 生成的对象可以生存到被 delete 为止 malloc 申请的空间生存到被 free 为止 分配/回收堆空间的子系统\n分配：为内存请求分配一段连续、适当大小的堆空间 首先从空闲的堆空间选择 若内存紧张，可以回收一部分内存 (C/C++ 需要手动回收，Java 可以自动回收空间) 评价指标：空间效率、程序效率、管理效率 5.代码生成\r同一中间表示代码可以由多组指令序列来实现，但不同实现之间的效率差别是很大的，因此，生成高质量代码需要知道指令代价。\n除了考虑指令的代价和序列长度外，我们还需要考虑运算对象和结果如何存储的问题。\n三地址机器模型：\n目标机器指令集(也可以称为目标语言)包含LD、ST、运算、跳转等指令 内存按照字节寻址 假设有n个通用寄存器R0, R1, …, Rn-1 假设所有运算分量都是整数 指令之前可能有一个标号 目标机器指令集：\n1 2 3 4 5 6 7 8 9 10 11 12 13 加载指令：LD dst,addr 保存指令：ST x,R 运算指令：OP dst,src1,src2 跳转指令：BR L Bcond r,L 寻址： 变量名a a(r)：数组访问，a是变量，r是寄存器 c(r)：沿指针取值，c是整数，r是寄存器 *r：在寄存器r的内容表示的位置上存放的内存位置 *c(r)：在寄存器r中内容加上c后表示的位置上存放的内存位置 #c：常数 在上述简单的目标机器上，指令代价简化为1+指令的源和目的的寻址模式的附加代价；其中，寄存器寻址模式附加代价为0，涉及内存位置或者常数的寻址方式代价为1.\n寄存器描述符：记录每个寄存器当前存放的是哪些变量的值\n地址描述符：记录运行时每个名字的当前值存放在哪个或者哪些位置，该位置可能是寄存器、栈单元、内存地址或者是它们的某个集合，这些信息可以存放在该变量名对应的符号表条目中。\n对每个形如x=y op z的三地址指令I：调用寄存器选择函数getReg(I)来为x、y、z选择寄存器Rx, Ry, Rz；如果Ry中存放的不是y，则生成指令“LD Ry, y’” , y’是存放y的内存位置之一，对于Rz和z的处理与上一步骤类似，最后，生成目标指令“OP Rx, Ry, Rz ”。 对于一个在基本块出口处可能活跃的变量x，如果它的地址描述符表明它的值没有存放在x的内存位置上，则生成指令“ST x, R”：R是在基本块结尾处存放x值的寄存器。 当生成加载、保存和其他指令时，必须同时更新寄存器和地址描述符： 对于LD R, x指令：修改R的寄存器描述符，使之只包含x，修改x的地址描述符，把R作为新增位置加入到x的位置集合中，从任何不同于x的地址描述符中删除R。 对于OP Rx, Ry, Rz指令：修改Rx的寄存器描述符，使之只包含x，从任何不同于Rx的寄存器描述符中删除x，修改x的地址描述符，使之只包含位置Rx，从任何不同于x的地址描述符中删除Rx。 对于ST x, R指令：修改x的地址描述符，使之包含自己的内存位置。 对于x = y指令，假设总是为x和y分配同一个寄存器，如果需要生成“LD Ry, y’” ，则：修改Ry的寄存器描述符，使之只包含y，修改y的地址描述符，把Ry作为新增位置加入y的位置集合中，从任何不同于y的地址描述符中删除Ry，修改Ry的寄存器描述符，使之也包含x，修改x的地址描述符，使之只包含Ry。 上面的规则非常长和复杂，下面给出一个例子帮助理解：\n1 2 3 4 5 6 7 8 基本块三地址代码： t=a-b u=a-c v=t+u a=d d=v+u exit 其中，t,u,v为临时变量，a,b,c,d在出口处活跃 初始寄存器描述符为空，地址描述符只有abcd的内存地址，处理第一句：t=a-b\n由第一条规则，为a选择寄存器R1，为b选择寄存器R2，t选择寄存器R2，可生成如下的指令：\n1 2 3 LD R1,a LD R2,b SUB R2,R1,R2 然后考虑前两句，修改R1和R2的寄存器描述符，使其包含a和b，修改a和b的地址描述符，把R1和R2加到对应位置集合中：\nR1 R2 a b a b c d a,R1 b,R2 c d 对于第三句，修改R2的寄存器描述符，使其只含t，如果别的寄存器含有t就删除，这个例子中没有，不需要管，修改t的地址描述符，使其只包含R2，如果别的地址有R2就删掉，这里把b中的R2删掉：\nR1 R2 a t a b c d t a,R1 b c d R2 第二句和第三句类似，这里不做分析，给出第四句之前的寄存器描述符和地址描述符：\nR1 R2 R3 u t v a b c d t u v a b c d R2 R1 R3 此时考虑第四句a=d，需要为a和d分配同一个寄存器，由于它们都没寄存器，故生成LD R2,d这样的语句，需要进行如下操作：修改R2的寄存器描述符，使其只包含d，修改d的地址描述符，把R2添加进去，把其他位置的R2删去，修改a的地址描述符，使其只含R2，修改R2的寄存器描述符，添加a：\nR1 R2 R3 u a,d v a b c d t u v R2 b c d,R2 R1 R3 这个例子在最后退出时，a和d的地址描述符不含内存位置，需要生成ST指令，把a和d添加到对应位置的地址描述符上。\n6.机器无关代码优化\r代码优化：在不改变程序运行效果的前提下，对程序代码进行等价变换，使之能生成更加高效目标代码。\n优化目标：运行时间更短，占用空间更小。\n6.1 常见的优化方式\r公共子表达式：若x op y已被计算过，且x和y的值没有改变，那么下一次出现就是公共子表达式。下一次计算可以删除，其值用上一次计算结果代替。删除分析：可用表达式数据流分析。 死代码删除：死代码是指计算的结果永远不被引用的语句，一些优化变换可能会引起死代码，如复制传播，常量合并。 复制传播：在复制语句x=y之后尽可能用y代替x，常用的公共子表达式删除和其他一些优化会引入一些复制语句，复制传播本身没有优化的意义，但可以给死代码删除创造机会。 常量合并：如果编译时刻推导出一个表达式的值是常量，就可以用该常量来代替这个表达式。常量合并也是本身没有优化的意义，可以给死代码删除创造机会。 循环优化：强度削弱：将程序中执行时间较长的运算替换为执行时间较短的运算，比如用增量运算替代；归纳变量删除：【归纳变量：如果存在一个常量c，使x每一次赋值总是增加c，则称x为归纳变量】一个循环中，如一组归纳变量的值的变化保持步调一致，则可只保留一个；代码移动：循环不变计算是指不管循环执行多少次都得到相同结果的表达式，代码码移动是循环优化的一种，在进入循环前就对循环不变计算进行求值。对于多重嵌套循环， loop-invariant computation是相对于某一个循环的，可能对于更加外层的循环，它就不成立了。因此，处理循环时，按照由里到外的方式，即dfs。 6.2 到达定值分析\r数据流分析：一组用来获取程序执行路径上的数据流信息的技术。\n应用有到达定值分析，活跃变量分析，可用表达式分析，在每一种应用中，都会把每个程序点和一个数据流值关联起来。\n流图上的点：基本块中，两个相邻的语句之间为程序的一个点，基本块有开始点和结束点。\n数据流值代表在任一程序点能观测到的所有可能程序状态集合的一个抽象，对于一个语句s，s之前的程序点对应的数据流值用IN[s]表示，之后的用OUT[s]表示。\n传递函数f，表示语句前后两点的数据流值受该语句的语义约束，若沿执行路径正向传播，则OUT[s]=fs(IN[s])，逆向则相反，若基本块由s1,s2,s3\u0026hellip;组成，有：IN[si+1]=OUT[si]。\n基本块上的数据流：IN[B]表示紧靠基本块B之前的数据流值，即IN[B]=IN[s1];OUT[B]表示紧靠基本块B之后的数据流值，即OUT[B]=OUT[sn]。\n到达定值分析：到达一个程序点的所有定值(gen)，定值的注销(kill)\n定值与引用：\n1 2 d:\tx:=y+z //语句d是变量x的一个定值点 u:\tw:=x+v //语句u是变量x的一个引用点 称变量x在d点的定值到达u点\n用途：\n循环不变量检测：如果循环中有x=y+z，而y和z的所有可能定值都在循环外，则y+z就是循环不变计算。 常量合并：如果对变量x的某次使用只有一个定值到达，且该定值把一个常量赋给x，则可以用该常量替换x。 错误检测：判定变量x在p点上是否未经定值就被引用。 gen和kill分别表示一个基本块生成和注销的定值。\ngenB表示B中能到达B的结束点的定值语句，killB表示整个程序中绝不会到达B结束点的定值，IN[B]表示能到达B的开始点的定值集合，OUT[B]表示能到达B的结束点的定值集合。\n$$\rIN[B]=\\cup OUT[P]\\{P是B的前驱\\}\\\\\rOUT[B]=gen_B \\cup (IN[B]-kill_B)\\\\\rOUT[ENTRY]=\\emptyset\r$$ 如下面的例子：\n可得到如下的gen和kill集合：\n1 2 3 4 5 6 7 8 9 10 11 gen[B1]={d1,d2,d3} kill[B1]={d4,d5,d6,d7} //因为把d4,d5,d6,d7左边的定值全部改了，不会到达末尾 gen[B2]={d4,d5} kill[B2]={d1,d2,d7} gen[B3]={d6} kill[B3]={d3} gen[B4]={d7} kill[B4]={d1,d4} 下面迭代计算IN和OUT：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 IN[B1]={} //前驱ENTRY的OUT为空 OUT[B1]={d1,d2,d3} IN[B2]=OUT[B1]∪OUT[B4]={d1,d2,d3} //这里初始化OUT都为空，后续会迭代更新 OUT[B2]={d3,d4,d5} IN[B3]={d3,d4,d5} OUT[B3]={d4,d5,d6} IN[B4]={d3,d4,d5,d6} OUT[B4]={d3,d5,d6,d7} IN[B2]={d1,d2,d3,d5,d6,d7} OUT[B2]={d3,d4,d5,d6} IN[B3]={d3,d4,d5,d6} OUT[B3]={d4,d5,d6} IN[B4]={d3,d4,d5,d6} OUT[B4]={d3,d5,d6,d7} 此后不再发生变化，迭代结束，共迭代3轮（加上最后一次没有OUT出现变化的一轮） 6.3 可用表达式分析\r若到点p的每条执行路径都计算x op y，并且计算后没有对x或y赋值，那么称x op y在点p可用。\ne_genB:块B产生的可用表达式集合\ne_killB:块B注销的可用表达式集合\nIN[B]：块B入口的可用表达式集合\nOUT[B]：块B出口的可用表达式集合\n$$\rIN[B]=\\cap OUT[P]\\{P是B的前驱\\}\\\\\rOUT[B]=e\\_gen_B \\cup (IN[B]-e\\_kill_B)\\\\\rOUT[ENTRY]=\\emptyset\r$$ 注意这里用的是交集，求的是最大解。\neg:\n可得到如下的e_gen和e_kill集合：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 忽略了entry和exit，因为都是空集 e_gen[B1]={3,1} //常量一定是可用表达式 e_kill[B1]={D+D,D*D,A+G} //这里改变了D和G的值，所以右边表达式含D和G的要被kill e_gen[B2]={D+D,D*D,B+C} //如果表达式左值在基本块中被修改，则不是可以表达式 e_kill[B2]={A+G,A*A} //这里没有kill掉B+C,即使B和C的值被修改了，因为最后一个语句重新计算了B+C，这样B+C又成为了可用表达式 e_gen[B3]={A+G} //这里的B+c不是可用表达式因为B是左值 e_kill[B3]={B+C} //改变了B，kill掉B+C e_gen[B4]={A*A} e_kill[B4]={B+C} e_gen[B5]={B+C} e_kill[B5]={D*D,A+G,D+D} 初始化OUT[ENTRY]为空集，其余的基本块OUT集合均为U（所有e_gen集合的并集），下面进行迭代：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 IN[B1]=OUT[ENTRY]={} OUT[B1]={3,1} IN[B2]=OUT[B1]∩OUT[B5]={3,1} OUT[B2]={3,1,D+D,D*D,B+C} IN[B3]={3,1,D+D,D*D,B+C} OUT[B3]={A+G,3,1,D+D,D*D} IN[B4]={3,1,D+D,D*D,B+C} OUT[B4]={A*A,3,1,D+D,D*D} IN[B5]={3,1,D+D,D*D} OUT[B5]={3,1,B+C} IN[EXIT]={3,1,B+C} OUT[EXIT]={3,1,B+C} 第一次迭代结束，第二次迭代结果不变这里不做展示，然后就退出了，迭代结束。 6.4 活跃变量分析\r对于变量x和程序点p，如果x的值在p点开始的某条执行路径上被引用，则说x在p点活跃，否则称x在p点已经死亡。\n如果所有寄存器都被占用，且还需要申请一个寄存器，则应该考虑使用已经存放死亡值的寄存器，如果一个值在基本块结尾处是死的，就不必在结尾处保存这个值了。\nIN[B]：块B开始点的活跃变量集合\nOUT[B]：块B结束点的活跃变量集合\nuseB：块B中有引用，且在引用前在B中没有被定值的变量集\ndefB：块B中有定值，且该定值前在B中没有被引用的变量集\n$$\rIN[EXIT]=\\emptyset\\\\\rOUT[B]=\\cup IN[S]\\{S是B的后继\\}\\\\\rIN[B]=use_B \\cup (OUT[B]-def_B)\r$$ eg:\n可得到如下的use和def集合：\n1 2 3 4 5 6 7 8 9 10 11 use[B1]={m,n,u1} def[B1]={i,j,a} use[B2]={i,j}//这里虽然i和j都被定值了，但引用在定值之前，所以仍然是use集 def[B2]={}//定值的i和j都被引用了 use[B3]={u2} def[B3]={a} use[B4]={u3} def[B4]={i} 初始化每个IN[B]都为空集参与运算，进行迭代，由于用的是后继，所以我们从最深处开始遍历：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 OUT[B4]=IN[EXIT]∪IN[B2]={} IN[B4]={u3} OUT[B3]={u3} IN[B3]={u2,u3} OUT[B2]=IN[B3]∪IN[B4]={u2,u3} IN[B2]={i,j,u2,u3} OUT[B1]={i,j,u2,u3} IN[B1]={m,n,u1,u2,u3} 第一轮迭代结束，进行第二轮： OUT[B4]=IN[EXIT]∪IN[B2]={i,j,u2,u3} IN[B4]={j,u2,u3} OUT[B3]={j,u2,u3} IN[B3]={j,u2,u3} OUT[B2]=IN[B3]∪IN[B4]={j,u2,u3} IN[B2]={i,j,u2,u3} OUT[B1]={i,j,u2,u3} IN[B1]={m,n,u1,u2,u3} 第二轮迭代结束，第三轮和第二轮结果一样，迭代结束。 6.5 基本块内优化\r基本块可以用DAG表示，构造方式：\n每个变量有一个对应的DAG结点表示其初值 每条语句s都对应一个内部结点N 结点N的标号是s中的运算符 有一组变量被关联到N，表示s是在此基本块中最晚对这些变量定值的语句 N的子结点是基本块中在s之前，最后一个对s所使用的某个运算分量进行定值的语句对应的结点。如果某个运算分量在基本块中在s之前没有被定值，则这个分量对应的子结点就是其初始值对应的结点，用下标0区分 在为x=y+z构造节点N的时候，如果x已被关联到某节点M上，那么需要从M的关联变量中删除x 如果两个语句表达式相同，可以直接在已存在的结点的关联变量中添加，而不用加入新的节点 某些结点是输出结点，在出口处活跃 一个例子：\n1 2 3 4 5 基本块： a = b + c b = a - d c = b + c d = a - d 当完成基本块优化后，就可以根据优化得到的DAG生成新的等价的三地址代码，如果结点有多个关联的活跃变量，就必须引入复制语句，为每个变量赋予正确的值。\n活跃变量是指其值可能会在以后被使用的变量，在DAG上删除死代码：删除所有没有关联活跃变量的根结点。（重复执行）\n代数恒等式使用：如x+0,x/1之类的计算可以消除，局部强度消减：x^2=x*x,2*x=x+x,x/2=x*0.5。常量合并：计算常量表达式的值【常量来源：程序员编写，宏定义展开，其他优化技术带来】交换律，结合律。\n数组引用：在构建DAG时为了避免将a[i]误判为公共子表达式，需要为x=a[i]创建一个运算符为=[]的结点，该结点的子结点为a和i，该结点的关联变量是x，为a[j]=y创建一个运算符为[]=的结点，子结点为a，j和y，没有关联变量，该结点将杀死所有已经建立的，其值依赖于a的结点，被杀死的结点不能再关联定值变量，也就不能成为公共子表达式。\n由上面的优化方法，我们得到优化后的DAG，然后重组生成等价的三地址代码，对每个具有若干关联定值变量的结点，构造一个三地址指令来计算其中某个变量的值。\n例如一个基本块：\n1 2 3 4 5 6 7 8 9 10 11 b=3 d=a+c e=a*c f=e+d g=b*f h=a+c i=a*c j=h+i k=b*5 l=k+j m=l 有如下的DAG：\n假设基本块结束时仅有l是活跃的，则m,g,j,i,h均可以删除，k可以进行常量合并，得到如下的三地址代码：\n1 2 3 4 d=a+c e=a*c f=d+e l=15+f 6.6 流图中的循环\r程序执行的大部分时间消耗在循环上，循环会影响程序分析的运行时间，改进循环性能的优化会对程序执行产生显著影响。\n循环展开：通过将循环体内的代码复制多次，增加loop每一次迭代的步长，减少循环分支指令执行的次数，增大处理器指令调度的空间，增加寄存器重用。\n循环中的一些概念：\n支配结点：\n若从初始结点起，每条到达n的路径都要经过d，写成d dom n；每个结点是它本身的支配结点，循环的入口是循环中所有结点的支配结点。\n直接支配结点：从入口结点到达n的所有路径上，结点n的最后一个支配结点。\n求解支配结点也可以用数据流分析，约束方程：OUT[B]=IN[B]∪{B}，IN[B]=∩OUT[P]{P是B的前驱}，初始化OUT[B]=N，OUT[ENTRY]={Entry}\n深度优先排序：\n深度优先排序与后序遍历相反。前进边：深度优先生成树的边；后撤边：指向祖先结点；交叉边：在树中互不为祖先\n回边：\n如果a dom b，那么边b-\u0026gt;a叫做回边，如果流图可归约，则后撤边就是回边（可归约：流图中所有回边删除掉之后，剩余的图无环）\n自然循环：是一种适合于优化的循环，具有如下性质：有唯一的入口结点，叫做首结点，首结点支配该循环中所有结点；至少存在一条回边进入该循环首结点。\n给定一条回边n-\u0026gt;d，它所对应自然循环包含d加上不经过d能到达n的所有结点，且结点d是该循环的首结点。\n其实就是找从某个结点p开始的不走过n这条路的路径到达n，把路径起点加到自然循环中。\neg:\n回边 自然循环 4-\u0026gt;3 {3,4,5,6,7,8,10} 7-\u0026gt;4 {4,5,6,7,8,10} 8-\u0026gt;3 {3,4,5,6,7,8,10} 9-\u0026gt;1 {1-10} 10-\u0026gt;7 {7,8,9} 以第一个为例：首先d(3)要在自然循环里，然后考虑其他结点，比如4可以不经过3到达4，5可以走5-\u0026gt;7-\u0026gt;4这条路到达4，所以4和5都加到自然循环里，其余类似，而像1，只有1-\u0026gt;2-\u0026gt;3-\u0026gt;4或1-\u0026gt;3-\u0026gt;4到达4必须经过3，所以不在自然循环中。\n内循环：若一个循环的结点集合是另一个循环的结点集合的子集。\n6.7 寄存器分配\r寄存器是宝贵的计算机资源，需要合理利用和分配。\n寄存器分配主要有线性扫描和图着色两类算法，前者比后者性能更好，应用更加广泛，但需要借助于变量存活区间的分析。\n","date":"2024-12-29T17:13:45+08:00","image":"http://localhost:1313/post/001.png","permalink":"http://localhost:1313/p/compiler-review/","title":"编译原理知识复习"}]