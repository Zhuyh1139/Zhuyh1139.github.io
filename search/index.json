[{"content":"å·¦ä¾§å¯¼èˆªæ \rå¯èƒ½ä½ å·²ç»åœ¨æˆ‘ç¬¬ä¸€ç¯‡å»ºç«™ç»éªŒé‡Œå‘ç°äº†é—®é¢˜ï¼Œå°±æ˜¯æˆ‘ä»¬å·¦ä¾§çš„å¯¼èˆªæ ç‚¹è¿›å»åéƒ½æ˜¯404ï¼Œè¿™æ˜¯å› ä¸ºæˆ‘ä»¬è¿˜æ²¡æœ‰åˆ›å»ºå¯¹åº”çš„é¡µé¢ï¼Œåœ¨æ ¹ç›®å½•contentä¸‹åˆ›å»ºpageæ–‡ä»¶å¤¹ï¼Œç”¨æ¥å­˜æ”¾æˆ‘ä»¬çš„ç›¸å…³é¡µé¢ï¼Œæˆ‘è¿™é‡Œåœ¨pageæ–‡ä»¶å¤¹ä¸‹åˆ›å»ºäº†ä¸‰ä¸ªmdæ–‡ä»¶ï¼Œå¯¹åº”æˆ‘å·¦ä¾§å¯¼èˆªæ çš„ä¸‰ä¸ªï¼šabout.mdï¼Œarchives.mdï¼Œsearch.mdï¼Œè¿™é‡Œè¦æ³¨æ„æˆ‘ä»¬åœ¨å»ºç«™ç»éªŒ[ä¸€]ä¸­å†™çš„ï¼š\n1 2 3 4 5 6 7 - identifier: archives name: å½’æ¡£ url: /archives/ weight: 2 params: icon: archives newTab: false è¿™é‡Œçš„urlæ˜¯æˆ‘ä»¬å¯¹åº”é¡µé¢çš„urlï¼Œä¸€èˆ¬æ¥è¯´ï¼Œhugoåˆ›å»ºé¡µé¢é»˜è®¤æ ‡é¢˜å°±æ˜¯åŸŸåï¼Œä½†æ³¨æ„stacké…ç½®æ–‡ä»¶ä¸­è¿™å¥ï¼š\n1 2 3 permalinks: post: /p/:slug/ page: /:slug/ è¿™æ®µè§„å®šäº†åŸŸåçš„å‘½åè§„åˆ™ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥æŠŠå‰é¢ä¸‰ä¸ªmdæ–‡ä»¶å†™æˆè¿™æ ·ï¼šï¼ˆä»¥about.mdä¸ºä¾‹ï¼‰\n1 2 3 4 5 6 7 --- title : \u0026#34;å…³äº\u0026#34; slug: about layout : \u0026#34;å…³äº\u0026#34; hidden : false comments : true --- ä¸‹é¢å°±å†™ä½ æƒ³è¦çš„å†…å®¹å³å¯ï¼Œè€Œarchives.mdï¼Œsearch.mdé‡Œé¢åªéœ€å¼•å…¥ç±»ä¼¼ä¸Šé¢çš„å³å¯ï¼Œä¸éœ€è¦æ­£æ–‡å†…å®¹ã€‚\nè¯„è®ºåŒº\rè¿™é‡Œæä¾›ä¸¤ç§è¯„è®ºç³»ç»Ÿæ­å»ºï¼šwalineä¸gitalkï¼Œä¸¤è€…å„æœ‰ä¼˜åŠ£ï¼Œå–å†³äºä½ ä¸ªäººçˆ±å¥½ã€‚\nwaline\rwalineå®˜æ–¹æ–‡æ¡£å†™çš„æ¯”è¾ƒè¯¦ç»†ï¼ŒæŒ‰ç…§ä¸Šé¢çš„æ­¥éª¤ä¸€æ­¥ä¸€æ­¥æ¥å³å¯ï¼š\nå¿«é€Ÿä¸Šæ‰‹ | Waline\nè·å¾—äº†è¯„è®ºåŒºæœåŠ¡ç«¯åœ°å€åhttps://\u0026lt;xxxxxx\u0026gt;.vercel.app/è®¿é—®https://\u0026lt;xxxxxx\u0026gt;.vercel.app/ui/registeræ¥æ³¨å†Œç®¡ç†å‘˜èº«ä»½ï¼Œè¿™é‡Œç¬¬ä¸€ä¸ªæ³¨å†Œçš„äººä¼šè‡ªåŠ¨æˆä¸ºç®¡ç†å‘˜ï¼Œæ‰€ä»¥è¦åŠæ—¶ã€‚\nä¸Šé¢çš„æ“ä½œå¼„å®Œä¹‹åï¼Œåœ¨é…ç½®æ–‡ä»¶ä¸­æ·»åŠ ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 comments: enabled: true provider: waline waline: serverURL: \u0026lt;your-server-url\u0026gt; lang: zh-CN visitor: true pageview: emoji: - https://npm.elemecdn.com/@waline/emojis@1.1.0/bilibili - https://npm.elemecdn.com/@waline/emojis@1.1.0/bmoji - https://npm.elemecdn.com/@waline/emojis@1.1.0/weibo requiredMeta: - name - email - url placeholder: æ¬¢è¿ç•™ä¸‹å®è´µçš„è¯„è®ºï¼ locale: admin: ç«™é•¿ placeholder: è¿˜æ²¡æœ‰äººè¯„è®ºå“¦ï¼å¿«æ¥æŠ¢æ²™å‘å§~ è¿™é‡Œçš„è¡¨æƒ…ä½ å¯ä»¥è‡ªè¡Œé€‰æ‹©ï¼Œè¿˜æœ‰å¾ˆå¤šï¼Œåœ¨walineå®˜æ–¹æ–‡æ¡£ä¸­éƒ½æœ‰ã€‚\ngitalk\ré¦–å…ˆæˆ‘ä»¬éœ€è¦åˆ›å»ºä¸€ä¸ªgithub applicationï¼šNew OAuth Application\nå…¶ä¸­éœ€è¦å¡«å†™çš„æœ‰ï¼š\napplication nameï¼šéšæ„èµ·å homepage urlï¼šä½ çš„åšå®¢åœ°å€ï¼Œè®°å¾—åŠ https authorization callback urlï¼šå’Œä¸Šé¢ä¸€æ ·ï¼Œå¡«åšå®¢åœ°å€ ç‚¹register applicationåï¼Œä¼šå‘Šè¯‰ä½ client IDï¼Œç„¶åæˆ‘ä»¬å†ç”Ÿæˆä¸€ä¸ªå¯†é’¥ï¼Œå³client Secretï¼Œæ¥ç€åœ¨é…ç½®æ–‡ä»¶ä¸­æ·»åŠ ï¼š\n1 2 3 4 5 6 7 8 9 10 comments: enabled: true provider: gitalk gitalk: owner: \u0026lt;your-github-name\u0026gt; admin: \u0026lt;your-github-name\u0026gt; repo: \u0026lt;ä»“åº“åï¼Œå³é‚£ä¸ªgithub.io\u0026gt; clientID: xxx clientSecret: xxx ç„¶åç¬¬ä¸€æ¬¡è¿›å…¥åä¼šè®©ä½ ç™»å½•ï¼Œç›´æ¥Githubæˆæƒå°±å®Œäº‹äº†ã€‚\n","date":"2025-02-04T20:58:58+08:00","image":"http://localhost:1313/post/004.png","permalink":"http://localhost:1313/p/hugo-stack-build-03/","title":"å»ºç«™ç»éªŒ[ä¸‰]è¯„è®ºç³»ç»Ÿä¸å…¶å®ƒç»†èŠ‚"},{"content":" è¿™ç¯‡å¸¦é¢†å¤§å®¶é€šè¿‡ä¿®æ”¹é…ç½®æ–‡ä»¶æ¥åšåŸºæœ¬çš„ç¾åŒ–æ“ä½œã€‚\nå·¦ä¾§çŠ¶æ€æ \ré¡¾åæ€ä¹‰ï¼Œå°±æ˜¯å·¦è¾¹çš„å¤´åƒï¼Œç­¾åç­‰è¿˜æœ‰ç›¸å…³é“¾æ¥ï¼Œåƒæˆ‘æ˜¯è¿™æ ·è®¾ç½®çš„ï¼š\nhugo.yamlæ–‡ä»¶ï¼š\n1 2 3 4 5 6 7 8 languages: zh-cn: languageName: ä¸­æ–‡ title: é™Œè¾å’–å•¡é¦† weight: 1 params: sidebar: subtitle: è§‚æˆ‘æ—§å¾€ï¼ŒåŒæˆ‘ä»°æ˜¥ å…³äºæ—è¾¹çš„è¡¨æƒ…ç¬¦å·ï¼Œåœ¨è¿™é‡Œï¼š\n1 2 3 4 5 6 7 sidebar: emoji: ğŸ¥ subtitle: Lorem ipsum dolor sit amet, consectetur adipiscing elit. avatar: enabled: true local: true src: img/222.png å…¶ä¸­ï¼Œsrcè¡¨ç¤ºå¤´åƒçš„å­˜æ”¾è·¯å¾„ï¼Œåœ¨themes/hugo-theme-stack/assets/imgä¸­å­˜æ”¾ã€‚\nå†ä¸‹é¢çš„æ˜¯ä¸ªäººç›¸å…³é“¾æ¥ï¼Œæˆ‘è¿™é‡Œæœ‰bç«™ï¼ŒCSDNå’ŒGithubï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 social: - identifier: github name: GitHub url: https://github.com/Zhuyh1139 weight: 1 params: icon: brand-github - identifier: bilibili name: Bilibili url: https://space.bilibili.com/527591205 weight: 2 params: icon: bilibili - identifier: CSDN name: CSDN url: https://blog.csdn.net/2301_77127818?spm=1010.2135.3001.5421 weight: 3 params: icon: csdn å…¶ä¸­ï¼Œurlå¡«ä½ çš„å¯¹åº”ç½‘å€ï¼Œiconå¡«å›¾æ ‡æ–‡ä»¶åï¼Œè¿™é‡Œçš„å›¾æ ‡æ–‡ä»¶éƒ½æ˜¯svgæ–‡ä»¶ï¼Œä½äºhemes/hugo-theme-stack/assets/iconsä¸‹ï¼Œé‡Œé¢ä¸»é¢˜é»˜è®¤æœ‰ä¸€æ‰¹ï¼Œè‹¥ä½ åƒæˆ‘ä¸€æ ·éœ€è¦åˆ«çš„å¯ä»¥åœ¨è¿™ä¸ªç½‘ç«™æ‰¾ï¼š\niconfont-é˜¿é‡Œå·´å·´çŸ¢é‡å›¾æ ‡åº“\nè¿™æ˜¯å¯ä»¥æŸ¥çœ‹ä¸‹è½½ä¸‹æ¥çš„svgæ–‡ä»¶æºç ï¼Œå¦‚æœæœ‰coloræˆ–è€…fillä¹‹ç±»çš„å±æ€§ï¼Œéœ€è¦æŠŠå€¼ä¿®æ”¹ä½currentColorï¼Œåƒä¸‹é¢è¿™æ ·ï¼Œä¸ç„¶ä¼šå‡ºç°æ·±è‰²æ¨¡å¼æ²¡æœ‰åˆ‡æ¢çš„æƒ…å†µï¼š\nå·¦è¾¹ä¸‹é¢çš„èœå•æ ä¹Ÿå¯ä»¥è¿™æ ·è®¾ç½®ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 menu: main: - identifier: home name: é¦–é¡µ url: / weight: 1 params: icon: home newTab: true - identifier: archives name: å½’æ¡£ url: /archives/ weight: 2 params: icon: archives newTab: true - identifier: about name: å…³äº url: /about/ weight: 3 params: icon: user newTab: true - identifier: search name: æœç´¢ url: /search/ weight: 4 params: icon: search newTab: true è¿™é‡Œçš„iconå’Œä¸Šé¢ä¸€æ ·çš„é“ç†ï¼Œç„¶åä¸åŒurlå¯¹åº”ç½‘å€è¿™é‡Œè¿˜æ²¡æœ‰åšï¼Œæ‰€ä»¥ç°åœ¨æ‰“å¼€åº”è¯¥æ˜¯404not foundï¼Œä¸ç”¨æ‹…å¿ƒï¼Œåé¢è¡¥ä¸Šå°±è¡Œäº†ã€‚\nè¿™æ ·æˆ‘ä»¬å·¦ä¾§çš„çŠ¶æ€æ å°±å·®ä¸å¤šæå®šäº†ï¼\nèƒŒæ™¯å›¾ç‰‡\rå¦‚æœè¦æ’å…¥é™æ€èƒŒæ™¯å›¾ç‰‡ï¼Œéœ€è¦å…ˆå‡†å¤‡ä¸€å¼ èƒŒæ™¯å›¾ï¼ˆåºŸè¯ï¼‰æ”¾åœ¨æ ¹ç›®å½•çš„assets/backgroundä¸‹ï¼Œå¦‚æœä¸å­˜åœ¨å°±è‡ªè¡Œåˆ›å»ºæ–‡ä»¶å¤¹ï¼Œæˆ‘éšä¾¿é€‰äº†ä¸€å¼ ï¼š\nåœ¨ä¸»é¢˜ç›®å½•çš„é¡µè„šæ–‡ä»¶ä¸­ä¿®æ”¹ï¼Œå…·ä½“ç›®å½•ä¸ºlayouts/partials/footer/custom.htmlï¼Œä¸å­˜åœ¨å°±è‡ªå·±åˆ›å»ºï¼Œæ·»åŠ ä¸‹é¢çš„ä»£ç ï¼š\n1 2 3 4 5 6 7 \u0026lt;style\u0026gt; body { background: url({{ (resources.Get \u0026#34;background/èƒŒæ™¯å›¾ç‰‡å\u0026#34;).Permalink }}) no-repeat center top; background-size: cover; background-attachment: fixed; } \u0026lt;/style\u0026gt; ç„¶åå°±åƒè¿™æ ·äº†ï¼š\nä½†æ˜¯è¿™ç§è™½ç„¶å¥½çœ‹ï¼Œä¸è¿‡å¤ªèŠ±äº†æŒºå½±å“è§‚æ„Ÿçš„ï¼Œäºæ˜¯æˆ‘é€‰æ‹©äº†æ¨±èŠ±é£èˆè¿™ä¸ªåŠ¨æ€èƒŒæ™¯ï¼šletere-gzj.github.io/hugo-stack/p/hugo/custom-background/sakura.jsï¼Œç‚¹å¼€åctrl+sä¿å­˜ï¼ŒåŒç†ä¹Ÿæ”¾åœ¨ä¸Šé¢é‚£ä¸ªbackgroundæ–‡ä»¶å¤¹ä¸‹ï¼Œå¹¶åœ¨ä¸Šé¢çš„custom.htmlæ–‡ä»¶ä¸­æ·»åŠ ï¼š\n1 \u0026lt;script src={{ (resources.Get \u0026#34;background/sakura.js\u0026#34;).Permalink }}\u0026gt;\u0026lt;/script\u0026gt; ç„¶åä½ å°±å¯ä»¥å¾—åˆ°å’Œæˆ‘è¿™æ ·ä¸€æ ·çš„æ•ˆæœäº†ã€‚\nlive2då°äºº\rä¸çŸ¥é“ä½ æ³¨æ„åˆ°æ²¡ï¼Œæˆ‘çš„åšå®¢å·¦ä¸‹è§’æœ‰ä¸€ä¸ªå°äººï¼Œè§†çº¿ä¼šè¿½éšç€ä½ çš„é¼ æ ‡ï¼Œè¿™ä¸ªå’Œæ¡Œé¢ä¸Šçš„live2dååˆ†ç›¸ä¼¼ï¼Œä¸‹é¢æ•™ç»™å¤§å®¶ï¼š\næˆ‘ç”¨çš„æ˜¯live2d-widgetçš„è‡ªå¸¦æ¨¡å‹ï¼Œæ²¡æœ‰ç»è¿‡ä»»ä½•ä¿®æ”¹ï¼Œå¦‚æœä½ æƒ³ç”¨åˆ«çš„å¼€æºæ¨¡å‹æˆ–è€…è‡ªå®šä¹‰å…¶å®ƒåŠŸèƒ½ï¼Œå¯ä»¥å¯¹å…¶è¿›è¡Œä¿®æ”¹ï¼Œè¿˜æ˜¯ä¸Šé¢é‚£ä¸ªcustom.htmlæ–‡ä»¶ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 \u0026lt;script\u0026gt; const cdnPath = \u0026#39;https://cdn.jsdelivr.net/gh/letere-gzj/live2d-widget-v3@main\u0026#39;; const config = { // èµ„æºè·¯å¾„ path: { modelPath: cdnPath + \u0026#34;/Resources/\u0026#34;, cssPath: cdnPath + \u0026#34;/waifu.css\u0026#34;, tipsJsonPath: cdnPath + \u0026#34;/waifu-tips.json\u0026#34;, tipsJsPath: cdnPath + \u0026#34;/waifu-tips.js\u0026#34;, live2dCorePath: cdnPath + \u0026#34;/Core/live2dcubismcore.js\u0026#34;, live2dSdkPath: cdnPath + \u0026#34;/live2d-sdk.js\u0026#34; }, // å·¥å…·æ  tools: [\u0026#34;hitokoto\u0026#34;, \u0026#34;asteroids\u0026#34;, \u0026#34;express\u0026#34;, \u0026#34;switch-model\u0026#34;, \u0026#34;switch-texture\u0026#34;, \u0026#34;info\u0026#34;, \u0026#34;quit\u0026#34;], // æ¨¡å‹æ‹–æ‹½ drag: { enable: true, direction: [\u0026#34;x\u0026#34;, \u0026#34;y\u0026#34;] }, // æ¨¡å‹åˆ‡æ¢(order: é¡ºåºåˆ‡æ¢ï¼Œrandom: éšæœºåˆ‡æ¢) switchType: \u0026#34;order\u0026#34; } // åŠ è½½èµ„æºå¹¶åˆå§‹åŒ– if (screen.width \u0026gt;= 768) { Promise.all([ loadExternalResource(config.path.cssPath, \u0026#34;css\u0026#34;), loadExternalResource(config.path.live2dCorePath, \u0026#34;js\u0026#34;), loadExternalResource(config.path.live2dSdkPath, \u0026#34;js\u0026#34;), loadExternalResource(config.path.tipsJsPath, \u0026#34;js\u0026#34;) ]).then(() =\u0026gt; { initWidget({ waifuPath: config.path.tipsJsonPath, cdnPath: config.path.modelPath, tools: config.tools, dragEnable: config.drag.enable, dragDirection: config.drag.direction, switchType: config.switchType }); }); } // å¼‚æ­¥åŠ è½½èµ„æº function loadExternalResource(url, type) { return new Promise((resolve, reject) =\u0026gt; { let tag; if (type === \u0026#34;css\u0026#34;) { tag = document.createElement(\u0026#34;link\u0026#34;); tag.rel = \u0026#34;stylesheet\u0026#34;; tag.href = url; } else if (type === \u0026#34;js\u0026#34;) { tag = document.createElement(\u0026#34;script\u0026#34;); tag.src = url; } if (tag) { tag.onload = () =\u0026gt; resolve(url); tag.onerror = () =\u0026gt; reject(url); document.head.appendChild(tag); } }); } \u0026lt;/script\u0026gt; è¿™æ ·ä½ å°±èƒ½çœ‹åˆ°live2då°äººå‡ºç°åœ¨ä½ çš„ç½‘ç«™ä¸­äº†ï¼\nå­—ä½“ä¸é¼ æ ‡æ ·å¼\rè¿™ä¸¤ä¸ªæˆ‘éƒ½æ²¡å¼„ï¼Œä½†æƒ³è¦æ›´åä¸½çš„ç½‘ç«™çš„æœ‹å‹ä»¬å¯ä»¥å‚è€ƒä¸€ä¸‹ï¼Œé¦–å…ˆæ˜¯å­—ä½“ï¼Œå…ˆä¸‹è½½ä¸€ä¸ªè‡ªå·±å–œæ¬¢çš„å­—ä½“ï¼Œç½‘ç«™ï¼š100font.com - å…è´¹å•†ç”¨å­—ä½“å¤§å…¨ - å…è´¹å­—ä½“ä¸‹è½½ç½‘ç«™\nä¸‹è½½è§£å‹åˆ°æ ¹ç›®å½•ä¸‹assets/fontç›®å½•ä¸‹ï¼Œä¸å­˜åœ¨è‡ªå·±åˆ›å»ºã€‚è¿˜æ˜¯åœ¨ä¸Šé¢ï¼ˆæ¢…å¼€ä¸‰åº¦ï¼‰custom.htmlæ–‡ä»¶ä¸­æ·»åŠ ï¼š\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;style\u0026gt; @font-face { font-family: \u0026#39;å­—ä½“å\u0026#39;; src: url({{ (resources.Get \u0026#34;font/å­—ä½“æ–‡ä»¶å\u0026#34;).Permalink }}) format(\u0026#39;truetype\u0026#39;); } :root { --base-font-family: \u0026#39;å­—ä½“å\u0026#39;; --code-font-family: \u0026#39;å­—ä½“å\u0026#39;; } \u0026lt;/style\u0026gt; ç„¶åå°±æœ‰äº†å¦‚ä¸‹çš„æ•ˆæœï¼ˆè¿™é‡Œæˆ‘ç”¨çš„æ˜¯é¼åˆ—ç æµ·å­—ä½“ï¼‰ï¼š\nä¸‹é¢æ˜¯é¼ æ ‡æŒ‡é’ˆï¼Œé¦–å…ˆéœ€è¦å‡†å¤‡ä½ éœ€è¦çš„ä¸åŒçŠ¶æ€çš„é¼ æ ‡æŒ‡é’ˆå›¾ç‰‡ï¼ˆé»˜è®¤ï¼Œæ–‡æœ¬ï¼ŒæŒ‡é’ˆï¼ŒåŠ è½½ç­‰ï¼‰ï¼Œç„¶åå°†è¿™äº›å›¾ç‰‡æ”¾åœ¨æ ¹ç›®å½•çš„static/mouseæ–‡ä»¶å¤¹ä¸‹ï¼Œè‡ªå·±åˆ›å»ºã€‚\næ¥ä¸‹æ¥ä¿®æ”¹ä¸»é¢˜ç›®å½•ä¸‹çš„assets/scss/custom.scssï¼ˆä¸å­˜åœ¨è‡ªå·±åˆ›å»ºï¼‰ï¼Œå¯ä»¥ä½¿ç”¨ä¸‹é¢è¿™ä¸ªä»£ç ï¼Œé€‚ç”¨äºstackä¸»é¢˜ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // ã€Stackä¸»é¢˜é¼ æ ‡æ ·å¼å†™æ³•ã€‘ // defaultå…‰æ ‡å›¾ç‰‡ body, html, .article-content img { cursor: url(../mouse/é»˜è®¤å…‰æ ‡å›¾ç‰‡å), auto !important; } // pointerå…‰æ ‡å›¾ç‰‡ a:hover, button:hover, .copyCodeButton:hover, #dark-mode-toggle { cursor: url(../mouse/æŒ‡é’ˆå…‰æ ‡å›¾ç‰‡å), auto; } // textå…‰æ ‡å›¾ç‰‡ input:hover, .site-description, .article-subtitle, .article-content span, .article-content li, .article-content p { cursor: url(../mouse/æ–‡æœ¬å…‰æ ‡å›¾ç‰‡å), auto; } è¿™æ ·å°±èƒ½å®ç°æ›´æ”¹é¼ æ ‡æŒ‡é’ˆæ ·å¼äº†ï¼Œç»æµ‹è¯•ï¼Œpng,curæ–‡ä»¶éƒ½æ˜¯å¯ä»¥çš„ã€‚\nå…¶å®ƒå°ç»†èŠ‚\ræ–‡ç« ç›®å½•æŠ˜å \ræœ‰æ—¶å€™ï¼Œæ–‡ç« ç›®å½•éå¸¸åºå¤§ï¼Œæ¯”å¦‚æˆ‘é‚£ç¯‡ç¼–è¯‘åŸç†å¤ä¹ ï¼Œè¿™æ—¶å°±å¯ä»¥é‡‡ç”¨ç›®å½•æŠ˜å ï¼Œåªæœ‰åœ¨åˆ°æŒ‡å®šä½ç½®æ—¶æ‰å±•å¼€ç›®å½•ï¼Œåªéœ€åœ¨custom.htmlï¼ˆæ¢…å¼€å››åº¦ï¼‰ä¸­æ·»åŠ ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 \u0026lt;style\u0026gt; #TableOfContents \u0026gt; ul, ol { ul, ol { display: none; } .open { display: block; } } \u0026lt;/style\u0026gt; \u0026lt;script\u0026gt; function initTocHide() { // åˆ¤æ–­æ˜¯å¦å­˜åœ¨æ–‡ç« ç›®å½• let toc = document.querySelector(\u0026#34;.widget--toc\u0026#34;); if (!toc) { return; } // ç›‘å¬æ»šåŠ¨ window.addEventListener(\u0026#39;scroll\u0026#39;, function() { //æ¸…é™¤classå€¼ let openUl = document.querySelectorAll(\u0026#34;.open\u0026#34;); if (openUl.length \u0026gt; 0) { openUl.forEach((ul) =\u0026gt; { ul.classList.remove(\u0026#34;open\u0026#34;) }) } // è·å–active-class let currentLi = document.querySelector(\u0026#34;.active-class\u0026#34;); if (!currentLi) { return } // å±•ç¤ºå­ul if (currentLi.children.length \u0026gt; 1) { currentLi.children[1].classList.add(\u0026#34;open\u0026#34;) } // å±•ç¤ºçˆ¶ul let ul = currentLi.parentElement; do { ul.classList.add(\u0026#34;open\u0026#34;); ul = ul.parentElement.parentElement } while (ul !== undefined \u0026amp;\u0026amp; (ul.localName === \u0026#39;ul\u0026#39; || ul.localName === \u0026#39;ol\u0026#39;)) }); } initTocHide() \u0026lt;/script\u0026gt; è¿”å›é¡¶éƒ¨æŒ‰é’®\råœ¨ä¸Šé¢çš„å›¾æ ‡ä¸‹è½½ç½‘ç«™ä¸­é€‰æ‹©ä¸€å¼ ä½ å–œæ¬¢çš„è¿”å›é¡¶éƒ¨æŒ‰é’®ï¼Œæ”¾åœ¨assets/iconsä¸­ï¼ˆè‡ªè¡Œåˆ›å»ºï¼‰ï¼Œåœ¨custom.htmlä¸­æ·»åŠ ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 \u0026lt;style\u0026gt; #backTopBtn { display: none; position: fixed; bottom: 30px; z-index: 99; cursor: pointer; width: 30px; height: 30px; background-image: url({{ (resources.Get \u0026#34;icons/å›¾æ ‡åå­—.svg\u0026#34;).Permalink }}); } \u0026lt;/style\u0026gt; \u0026lt;script\u0026gt; /** * æ»šåŠ¨å›é¡¶éƒ¨åˆå§‹åŒ– */ function initScrollTop() { let rightSideBar = document.querySelector(\u0026#34;.right-sidebar\u0026#34;); if (!rightSideBar) { return; } // æ·»åŠ è¿”å›é¡¶éƒ¨æŒ‰é’®åˆ°å³ä¾§è¾¹æ  let btn = document.createElement(\u0026#34;div\u0026#34;); btn.id = \u0026#34;backTopBtn\u0026#34;; btn.onclick = backToTop rightSideBar.appendChild(btn) // æ»šåŠ¨ç›‘å¬ window.onscroll = function() { // å½“ç½‘é¡µå‘ä¸‹æ»‘åŠ¨ 20px å‡ºç°\u0026#34;è¿”å›é¡¶éƒ¨\u0026#34; æŒ‰é’® if (document.body.scrollTop \u0026gt; 20 || document.documentElement.scrollTop \u0026gt; 20) { btn.style.display = \u0026#34;block\u0026#34;; } else { btn.style.display = \u0026#34;none\u0026#34;; } }; } /** * è¿”å›é¡¶éƒ¨ */ function backToTop(){ window.scrollTo({ top: 0, behavior: \u0026#34;smooth\u0026#34; }) } initScrollTop(); \u0026lt;/script\u0026gt; å¼•ç”¨å—æ¨¡ç‰ˆ\ræˆ‘è‡ªå·±å¹³æ—¶å†™mdæ–‡ä»¶ç”¨çš„typoraï¼Œé‡Œé¢æœ‰ä¸åŒçš„è­¦ç¤ºæ¡†ï¼Œç”¨ä¸åŒé¢œè‰²è¡¨ç¤ºï¼Œä½†åœ¨ç½‘é¡µä¸Šæ²¡æœ‰ï¼Œäºæ˜¯è‡ªå·±æ‰‹åŠ¨æ·»åŠ ï¼š\nåˆ›å»ºæ–‡ä»¶layouts/_default/_markup/render-blockquote-alert.htmlï¼Œå¹¶å°†ä»¥ä¸‹ä»£ç å¤åˆ¶è¿›å»ï¼š\n1 2 3 \u0026lt;blockquote class=\u0026#34;alert alert-{{ .AlertType }}\u0026#34;\u0026gt; {{ .Text | safeHTML -}} \u0026lt;/blockquote\u0026gt; å°†ä»¥ä¸‹ä»£ç å¤åˆ¶è¿›assets/scss/custom.scssæ–‡ä»¶ä¸­ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 [data-scheme=\u0026#34;light\u0026#34;] { .alert-note { --card-separator-color: #65bbee; --blockquote-background-color: #e7f2fa; } .alert-tip { --card-separator-color: #55aa55; --blockquote-background-color: #eeffee; } .alert-important { --card-separator-color: #db75f2; --blockquote-background-color: #feeeff; } .alert-warning { --card-separator-color: #ffbb78; --blockquote-background-color: #ffeecc; } .alert-caution { --card-separator-color: #cc3334; --blockquote-background-color: #ffeeef; } } [data-scheme=\u0026#34;dark\u0026#34;] { .alert-note { --card-separator-color: #006699; --blockquote-background-color: #002234; } .alert-tip { --card-separator-color: #336733; --blockquote-background-color: #112310; } .alert-important { --card-separator-color: #7e1f91; --blockquote-background-color: #331111; } .alert-warning { --card-separator-color: #aa5501; --blockquote-background-color: #452300; } .alert-caution { --card-separator-color: #880000; --blockquote-background-color: #450000; } } ç„¶åè¯•ä¸€ä¸‹ï¼š\nè¿™æ˜¯NOTE\nè¿™æ˜¯TIP\nè¿™æ˜¯WARNING\nè¿™æ˜¯IMPORTANT\nè¿™æ˜¯CAUTION\nå¦‚æœä½ è¿˜æƒ³æ·»åŠ åˆ«çš„ï¼ŒåŒç†çš„æ“ä½œæ–¹æ³•åœ¨custom.scssæ–‡ä»¶ä¸­æ·»åŠ å³å¯ã€‚\nä»£ç æŠ˜å \u0026amp;å±•å¼€\rå’Œä¸Šé¢è¿”å›é¡¶éƒ¨ä¸€æ ·çš„æ“ä½œï¼Œå‡†å¤‡ä¸€å¼ å±•å¼€çš„å›¾ç‰‡ï¼Œæ”¾åœ¨iconsæ–‡ä»¶å¤¹ä¸‹ï¼Œåœ¨custom.htmlæ–‡ä»¶ä¸­æ·»åŠ ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 \u0026lt;style\u0026gt; .highlight { /* ä½ å¯ä»¥æ ¹æ®éœ€è¦è°ƒæ•´è¿™ä¸ªé«˜åº¦ */ max-height: 400px; overflow: hidden; } .code-show { max-height: none !important; } .code-more-box { width: 100%; padding-top: 78px; background-image: -webkit-gradient(linear, left top, left bottom, from(rgba(255, 255, 255, 0)), to(#fff)); position: absolute; left: 0; right: 0; bottom: 0; z-index: 1; } .code-more-btn { display: block; margin: auto; width: 44px; height: 22px; background: #f0f0f5; border-top-left-radius: 8px; border-top-right-radius: 8px; padding-top: 6px; cursor: pointer; } .code-more-img { cursor: pointer !important; display: block; margin: auto; width: 22px; height: 16px; } \u0026lt;/style\u0026gt; \u0026lt;script\u0026gt; function initCodeMoreBox() { let codeBlocks = document.querySelectorAll(\u0026#34;.highlight\u0026#34;); if (!codeBlocks) { return; } codeBlocks.forEach(codeBlock =\u0026gt; { // æ ¡éªŒæ˜¯å¦overflow if (codeBlock.scrollHeight \u0026lt;= codeBlock.clientHeight) { return; } // å…ƒç´ åˆå§‹åŒ– // codeMoreBox let codeMoreBox = document.createElement(\u0026#39;div\u0026#39;); codeMoreBox.classList.add(\u0026#39;code-more-box\u0026#39;); // codeMoreBtn let codeMoreBtn = document.createElement(\u0026#39;span\u0026#39;); codeMoreBtn.classList.add(\u0026#39;code-more-btn\u0026#39;); codeMoreBtn.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { codeBlock.classList.add(\u0026#39;code-show\u0026#39;); codeMoreBox.style.display = \u0026#39;none\u0026#39;; }) // img let img = document.createElement(\u0026#39;img\u0026#39;); img.classList.add(\u0026#39;code-more-img\u0026#39;); img.src = {{ (resources.Get \u0026#34;icons/codeMore.png\u0026#34;).Permalink }} // å…ƒç´ æ·»åŠ  codeMoreBtn.appendChild(img); codeMoreBox.appendChild(codeMoreBtn); codeBlock.appendChild(codeMoreBox) }) } initCodeMoreBox(); \u0026lt;/script\u0026gt; æ„Ÿè°¢è±ç‰¹é›·å¤§ä½¬çš„åˆ†äº«ï¼šã€Hugoã€‘Stackä¸»é¢˜è‡ªå®šä¹‰ä¿®æ”¹\n","date":"2025-01-25T14:00:52+08:00","image":"http://localhost:1313/post/003.png","permalink":"http://localhost:1313/p/hugo-stack-build-02/","title":"å»ºç«™ç»éªŒ[äºŒ]stackä¸»é¢˜åŸºæœ¬ç¾åŒ–æ“ä½œ"},{"content":" å†™åœ¨å‰é¢ï¼šåœ¨ä¸€æ¬¡ç¨€æ¾å¹³å¸¸çš„å¤ä¹ å½“ä¸­ï¼Œæˆ‘åœ¨æŸ¥æ‰¾ç›¸å…³èµ„æ–™æ—¶å‘ç°äº†ä¸€ç¯‡åšå®¢ï¼Œä¸åŒäºä¹‹å‰å¸¸è§çš„CSDNï¼ŒçŸ¥ä¹ä¸åšå®¢ç½‘ç­‰ï¼Œé‚£ç¯‡åšå®¢ç•Œé¢ç®€æ´æ¸…æ™°ï¼Œè¿˜ååˆ†ç¾è§‚ï¼Œåé¢æˆ‘åˆå‘ç°äº†åšä¸»æ˜¯è‡ªå·±æ­å»ºçš„å±äºè‡ªå·±çš„åšå®¢ï¼Œç›¸å½“äºä¸ªäººä¸»é¡µåŠ å¾®å‹ç¤¾åŒºäº†ï¼Œæˆ‘å½“æ—¶å°±å¯¹å…¶ååˆ†æ„Ÿå…´è¶£ï¼Œäºæ˜¯åœ¨æœŸæœ«è€ƒè¯•å‘¨ç¡¬ç”Ÿç”Ÿå®Œæˆäº†å»ºç«™çš„åŸºç¡€å·¥ä½œå¹¶å‘å¸ƒäº†ç¬¬ä¸€ç¯‡åšå®¢ï¼Œåç»­ä¹Ÿæ˜¯ä¸æ–­å¯¹å…¶è¿›è¡Œç¾åŒ–ä¸å»ºè®¾ã€‚å¤§å¤šæ•°ä¸ªäººåšå®¢å»ºè®¾è€…å‘å¸ƒçš„ç¬¬ä¸€ç¯‡åšå®¢éƒ½æ˜¯è®°å½•å»ºç«™ç»å†çš„ï¼Œé‚£ä¹ˆç§‰æ‰¿ç€â€œå‰äººæ ½æ ‘ï¼Œåäººä¹˜å‡‰â€çš„åŸåˆ™ï¼Œè¿™é‡Œæˆ‘ä¹Ÿå°†æˆ‘åœ¨ç½‘ä¸Šå­¦ä¹ åˆ°çš„ç»éªŒæ•´åˆåˆ†äº«ç»™å¤§å®¶ï¼Œæ¥å°½å¯èƒ½å°‘èµ°å¼¯è·¯ã€‚\nGithubç›¸å…³\rç”±äºgithubå¯ä»¥å…è´¹æ‰˜ç®¡ç½‘é¡µå¹¶ç”³è¯·åŸŸåï¼Œå› æ­¤ï¼Œæˆ‘ä»¬é€‰æ‹©githubå­˜å‚¨åšå®¢æºä»£ç ï¼ˆä¹Ÿæ˜¯å¤§éƒ¨åˆ†é€‰æ‹©çš„ï¼‰ï¼Œè¿™é‡Œæˆ‘è®¤ä¸ºä½ å·²ç»æœ‰äº†githubè´¦å·ï¼Œä¸ç„¶ä¹Ÿå¾ˆéš¾çœ‹åˆ°è¿™ç¯‡åšå®¢ï¼Œå¦‚æœå®åœ¨æ²¡æœ‰ï¼Œç‚¹å‡»å·¦ä¾§æ ç›®é‡Œçš„é‚£ä¸ªåƒçŒ«ä¸€æ ·çš„å›¾æ ‡ï¼ŒèŠ±å‡ åˆ†é’Ÿæ³¨å†Œä¸€ä¸ªå§ã€‚\nåˆ›å»ºæ–°ä»“åº“ç”¨æ¥å­˜å‚¨åšå®¢æºç ï¼Œä»“åº“åä¸º{githubç”¨æˆ·å}.github.ioï¼Œè¿™æ ·å¯ä»¥é¿å…è®¸å¤šé—®é¢˜ï¼Œæ¯”å¦‚æˆ‘çš„githubç”¨æˆ·åä¸ºZhuyh1139ï¼Œé‚£ä¹ˆå°±åƒä¸‹é¢è¿™æ ·ï¼š\nè¿™é‡Œæ³¨æ„ä»“åº“è¦è®¾ä¸ºå…¬å¼€(public)ï¼Œåˆ†æ”¯ä½¿ç”¨mainã€‚\nå»ºå®Œä¹‹åå°±å¯ä»¥å…ˆä¸ç”¨ç®¡äº†ï¼Œæ¥ä¸‹æ¥æˆ‘ä»¬è¦è¿›è¡Œhugoç›¸å…³çš„å·¥ä½œäº†ã€‚\nHugoç›¸å…³\ré¦–å…ˆéœ€è¦ä¸‹è½½hugoï¼Œè®°å¾—å®‰è£…extendç‰ˆæœ¬çš„ï¼Œä¸ç„¶ä¸æ”¯æŒsass/scssæ‰©å±•ï¼Œå®‰è£…æ–¹æ³•éå¸¸ç®€å•ï¼Œå¦‚æœä½ è·Ÿæˆ‘ä¸€æ ·æ˜¯windowç³»ç»Ÿï¼ˆæˆ‘æ˜¯win11ï¼‰é‚£ä¹ˆå¯ä»¥ç›´æ¥åœ¨ç»ˆç«¯ä¸­è¾“å…¥ï¼š\n1 winget install Hugo.Hugo.Extended å¦‚æœä½ ä¸‹è½½äº†åˆ«çš„ç±»ä¼¼pipç­‰å·¥å…·ï¼Œå¯ä»¥è€ƒè™‘å¦‚ä¸‹å®‰è£…æ–¹æ³•ï¼š\n1 choco install hugo-extended 1 scoop install hugo-extended å¦‚æœä½ æ˜¯ubuntuç³»ç»Ÿç­‰ï¼Œå¯ä»¥æŒ‰ç…§å®˜ç½‘çš„å®‰è£…æ•™ç¨‹ä¸‹è½½ï¼š\nInstallation | Hugo\nä¸‹è½½å®Œæˆä¹‹åè¾“å…¥hugo versionï¼Œå¦‚æœæ˜¾ç¤ºæœ‰extendedå­—æ ·è¯´æ˜å®‰è£…æˆåŠŸå•¦ï¼\næ¥ä¸‹æ¥é€‰æ‹©ä¸€æ¬¾ä½ å–œæ¬¢çš„ä¸»é¢˜æ¥ä½œä¸ºç½‘ç«™åŸºç¡€æ ·å¼ï¼Œè¿™é‡Œæˆ‘é€‰çš„æ˜¯ç½‘ä¸Šè¾ƒå¤šäººç”¨çš„stackï¼Œèµ„æ–™ä¹Ÿç›¸å¯¹å¤šä¸€ç‚¹ã€‚\næˆ‘åœ¨ä¸‹è½½ä¸»é¢˜æ—¶é‡‡ç”¨çš„æ˜¯git cloneä¸€é”®å®‰è£…ï¼Œä½†åç»­æˆ‘å‘ç°äº†é—®é¢˜ï¼Œå°±æ˜¯å¦‚æœæƒ³ä½¿ç”¨è‡ªåŠ¨éƒ¨ç½²hugoç½‘é¡µçš„è¯ï¼ˆä¹Ÿå°±æ˜¯ç”¨githubæ‰˜ç®¡æ•´ä¸ªé¡¹ç›®ï¼Œè‡ªåŠ¨hugoæ›´æ–°ä¸Šé¢github.ioä»“åº“ï¼‰ï¼Œä¼šå› ä¸ºthemeæ–‡ä»¶å¤¹ä¸‹gitçš„æ˜¯stackåˆ›ä½œè€…çš„è¿œç¨‹ä»“åº“ï¼Œå¯¼è‡´æ— æ³•æ­£å¸¸git pushæ›´æ–°ï¼Œå› æ­¤è¿™é‡Œæˆ‘æ¨èç›´æ¥ä¸‹è½½ï¼šCaiJimmy/hugo-theme-stack: Card-style Hugo theme designed for bloggers\nä¸‹å¥½çš„ç›´æ¥è§£å‹åˆ°themeæ–‡ä»¶å¤¹ä¸‹å³å¯ï¼Œç„¶åæŠŠé‡Œé¢çš„hugo.yamlæ–‡ä»¶ç§»åˆ°æ ¹ç›®å½•ä¸‹ï¼Œåƒè¿™æ ·ï¼š\nè¿™ä¸ªhugo.yamlå³æ˜¯æˆ‘ä»¬çš„ç½‘ç«™é…ç½®æ–‡ä»¶ï¼Œåç»­å¤§å¤šç¾åŒ–æ“ä½œéƒ½éœ€è¦æ¶‰åŠè¿™ä¸ªæ–‡ä»¶ã€‚\nå†é¡ºä¾¿ä»‹ç»ä¸‹å…¶å®ƒå‡ ä¸ªå¸¸ç”¨çš„ä½ç½®æ–‡ä»¶å¤¹ï¼š\nassetsï¼šè¿™ä¸ªåœ¨æ ¹ç›®å½•ä¸ä¸»é¢˜æ–‡ä»¶å¤¹ä¸­éƒ½æœ‰ï¼Œå­˜æ”¾èƒŒæ™¯å›¾ç‰‡ï¼Œå¤´åƒç­‰ï¼› contentï¼šå‘å¸ƒçš„åšå®¢ï¼Œä¸€èˆ¬åœ¨ä¸‹é¢åŒæ—¶åˆ›å»ºpostæ–‡ä»¶å¤¹ä½œä¸ºå‘å¸ƒæ–‡ä»¶å¤¹ï¼› staticï¼šæ ¹ç›®å½•ä¸‹ï¼Œå­˜æ”¾mdæ–‡ä»¶ä¸­çš„å›¾ç‰‡ï¼› publicï¼šéœ€ä¸Šä¼ githubçš„æ–‡ä»¶å¤¹ï¼Œéœ€è¦å’Œæˆ‘ä»¬çš„è¿œç¨‹ä»“åº“å…³è”ã€‚ è¿™ä¸ªstaticå­˜æ”¾çš„ä¸œè¥¿ä¼šåŒæ­¥åˆ°publicé‡Œé¢ï¼Œè€Œassetsé‡Œé¢çš„ä¸€èˆ¬éƒ½æ˜¯å’Œä¸»é¢˜ç›¸å…³çš„ã€‚\næ¥ä¸‹æ¥å°±å¯ä»¥ä½¿ç”¨æŒ‡ä»¤ï¼ˆæ ¹ç›®å½•ä¸‹ï¼‰ï¼š\n1 hugo new post/index.md æ¥åˆ›å»ºå±äºè‡ªå·±çš„ç¬¬ä¸€ç¯‡åšå®¢äº†ï¼Œæ­¤æ—¶ä½ ä¼šåœ¨content/postä¸‹é¢çœ‹åˆ°index.mdæ–‡ä»¶ï¼Œè€Œä¸”æ–‡ä»¶å¤´ä¼šæœ‰ï¼š\n1 2 3 4 5 6 --- title:xxx . . . --- è¿™æ ·çš„å­—æ ·ï¼Œè¿™å°±è¡¨æ˜æˆåŠŸäº†ï¼Œç„¶ååœ¨æ ¹ç›®å½•ç»ˆç«¯è¾“å…¥ï¼š\n1 hugo server -D æ¥è¿›è¡Œç½‘é¡µæ¸²æŸ“ï¼Œå®ƒä¼šè¿”å›ä¸€ä¸ªç½‘å€ï¼Œç›´æ¥æ‰“å¼€å³å¯ï¼Œä½ å°±èƒ½çœ‹åˆ°å½“å‰çš„æ•ˆæœäº†ï¼Œè¿™ä¸ªåªè¦ä½ å¯¹ç›®å½•ä¸‹ä»»ä½•ä¸€ä¸ªæ–‡ä»¶ä¿®æ”¹äº†éƒ½ä¼šé‡æ–°æ¸²æŸ“è¾“å‡ºï¼Œå¯¹äºæµ‹è¯•ä»¥åŠç¾åŒ–æ¥è¯´éå¸¸å¥½ç”¨ã€‚\nä¸Šé¢æˆ‘ä»¬è¯´åˆ°äº†publicæ–‡ä»¶å¤¹è¦å…³è”åˆ°è¿œç¨‹ä»“åº“ï¼Œä¸‹é¢æ˜¯å…·ä½“æ­¥éª¤ï¼š\n1 2 3 4 5 6 cd public git init git remote add origin ä»“åº“åœ°å€.git git add . git commit -m \u0026#34;create\u0026#34; git push origin main å…¶ä¸­ï¼Œå…³äºgitçš„æ“ä½œè¿™é‡Œä¸å¤šè¯¦ç»†è®²è§£ï¼Œæ„Ÿå…´è¶£çš„å¯ä»¥è‡ªè¡Œä¸Šç½‘æœç´¢å­¦ä¹ ã€‚\nç„¶åï¼Œç­‰å¾…å‡ åˆ†é’Ÿï¼Œå°±å¯ä»¥é€šè¿‡è®¿é—®{ä½ çš„githubç”¨æˆ·å}.github.ioæ¥çœ‹åˆ°ä½ çš„ä¸ªäººåšå®¢å•¦ã€‚\nè‡³æ­¤ï¼Œå°±å·²ç»å®Œæˆäº†æœ€åŸºç¡€çš„å»ºç«™æ“ä½œäº†ï¼Œåé¢æˆ‘ä¼šå‘å¸ƒç¾åŒ–ä¸å…¶å®ƒåŠŸèƒ½çš„ä»‹ç»ã€‚\n","date":"2025-01-24T20:16:00+08:00","image":"http://localhost:1313/post/002.png","permalink":"http://localhost:1313/p/hugo-stack-build-01/","title":"å»ºç«™ç»éªŒ[ä¸€]åˆ©ç”¨githubåŠ hugoæ­å»ºå±äºè‡ªå·±çš„åšå®¢"},{"content":"æ­¤ä¸ºç¬”è€…ç¼–è¯‘åŸç†å®éªŒæ‰€åšï¼Œä»…ä¾›å­¦ä¹ äº¤æµä½¿ç”¨ã€‚\nç¯å¢ƒï¼šubuntu 22.04\nç›¸å…³é…ç½®: LLVM,Clang,Git,build-essential,Cmake,Flex,Bison,GDB\nä¸Šè¿°ç¯å¢ƒä¸è½¯ä»¶é…ç½®è¿™é‡Œä¸åšè¿‡å¤šä»‹ç»\nå®Œæ•´é¡¹ç›®ï¼šZhuyh1139/Compiler: This is ustc 2024 fall compiler course labs.\nä»£ç è§£é‡Šéƒ½åœ¨æ³¨é‡Šä¸­ï¼Œå°±ä¸è´¹ç¯‡å¹…äº†ã€‚\nè¯æ³•åˆ†æå™¨\rå³ç”¨æ­£åˆ™è¡¨è¾¾å¼çš„å½¢å¼å°†Cminusfè¿›è¡Œåˆ†è¯æ“ä½œï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 %option noyywrap %{ /*****************å£°æ˜å’Œé€‰é¡¹è®¾ç½® begin*****************/ #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026#34;syntax_tree.h\u0026#34; #include \u0026#34;syntax_analyzer.h\u0026#34; int lines=1; int pos_start=1; int pos_end=1; void pass_node(char *text){ yylval.node = new_syntax_tree_node(text); } /*****************å£°æ˜å’Œé€‰é¡¹è®¾ç½® end*****************/ %} %x COMMENT %% /* to do for students */ /* two cases for you, pass_node will send flex\u0026#39;s token to bison */ \\+ {pos_start = pos_end; pos_end += 1; pass_node(yytext); return ADD;} /****è¯·åœ¨æ­¤è¡¥å…¨æ‰€æœ‰flexçš„æ¨¡å¼ä¸åŠ¨ä½œ end******/ \\-\t{pos_start = pos_end; pos_end += 1; pass_node(yytext); return SUB;} \\*\t{pos_start = pos_end; pos_end += 1; pass_node(yytext); return MUL;} \\/\t{pos_start = pos_end; pos_end += 1; pass_node(yytext); return DIV;} \\\u0026lt;\t{pos_start = pos_end; pos_end += 1; pass_node(yytext); return LT;} \\\u0026lt;=\t{pos_start = pos_end; pos_end += 2; pass_node(yytext); return LTE;} \\\u0026gt;\t{pos_start = pos_end; pos_end += 1; pass_node(yytext); return GT;} \\\u0026gt;=\t{pos_start = pos_end; pos_end += 2; pass_node(yytext); return GTE;} ==\t{pos_start = pos_end; pos_end += 2; pass_node(yytext); return EQ;} !=\t{pos_start = pos_end; pos_end += 2; pass_node(yytext); return NEQ;} =\t{pos_start = pos_end; pos_end += 1; pass_node(yytext); return ASSIN;} ;\t{pos_start = pos_end; pos_end += 1; pass_node(yytext); return SEMICOLON;} ,\t{pos_start = pos_end; pos_end += 1; pass_node(yytext); return COMMA;} \\(\t{pos_start = pos_end; pos_end += 1; pass_node(yytext); return LPARENTHESE;} \\)\t{pos_start = pos_end; pos_end += 1; pass_node(yytext); return RPARENTHESE;} \\[\t{pos_start = pos_end; pos_end += 1; pass_node(yytext); return LBRACKET;} \\]\t{pos_start = pos_end; pos_end += 1; pass_node(yytext); return RBRACKET;} \\{\t{pos_start = pos_end; pos_end += 1; pass_node(yytext); return LBRACE;} \\}\t{pos_start = pos_end; pos_end += 1; pass_node(yytext); return RBRACE;} else\t{pos_start = pos_end; pos_end += 4; pass_node(yytext); return ELSE;} if\t{pos_start = pos_end; pos_end += 2; pass_node(yytext); return IF;} int\t{pos_start = pos_end; pos_end += 3; pass_node(yytext); return INT;} float {pos_start = pos_end; pos_end += 5; pass_node(yytext); return FLOAT;} return {pos_start = pos_end; pos_end += 6; pass_node(yytext); return RETURN;} void {pos_start = pos_end; pos_end += 4; pass_node(yytext); return VOID;} while {pos_start = pos_end; pos_end += 5; pass_node(yytext); return WHILE;} [a-zA-Z]+\t{pos_start = pos_end; pos_end += strlen(yytext); pass_node(yytext); return IDENTIFIER;} [0-9]+\t{pos_start = pos_end; pos_end += strlen(yytext); pass_node(yytext); return INTEGER;} [0-9]+\\.[0-9]*|[0-9]*\\.[0-9]+ { pos_start = pos_end; pos_end += strlen(yytext); pass_node(yytext); return FLOATPOINT;} \\n {lines++; pos_start = 1; pos_end = 1;} [ \\t] {pos_start = pos_end; pos_end += 1;} \u0026#34;/*\u0026#34; { pos_start = pos_end; pos_end += 2; BEGIN(COMMENT); } \u0026lt;COMMENT\u0026gt;\u0026#34;*/\u0026#34; { pos_start = pos_end; pos_end += 2; BEGIN(INITIAL); } \u0026lt;COMMENT\u0026gt;. { pos_start = pos_end; pos_start += 1; } \u0026lt;COMMENT\u0026gt;\\n { pos_start = 1; pos_end = 1; lines++; } . { pos_start = pos_end; pos_end++; return ERROR; } %% å…¶ä½œç”¨ä¸ºï¼š\næ–‡æœ¬è¾“å…¥ï¼š\n1 void main(void) { return; } è¾“å‡ºï¼š\n1 2 3 4 5 6 7 8 9 10 Token Text Line Column (Start,End) 282 void 1 (1,5) 284 main 1 (6,10) 272 ( 1 (10,11) 282 void 1 (11,15) 273 ) 1 (15,16) 276 { 1 (17,18) 281 return 1 (19,25) 270 ; 1 (25,26) 277 } 1 (27,28) è¯­æ³•åˆ†æå™¨\rCminusfçš„è¯­æ³•å’ŒCçš„è¯­æ³•å¤§è‡´ç›¸åŒï¼š\nprogramâ†’declaration-listprogramâ†’declaration-list declaration-listâ†’declaration-list declaration âˆ£ declarationdeclaration-listâ†’declaration-list declaration âˆ£ declaration declarationâ†’var-declaration âˆ£ fun-declarationdeclarationâ†’var-declaration âˆ£ fun-declaration var-declaration â†’type-specifier IDâ€¾ ;â€¾ âˆ£ type-specifier IDâ€¾ [â€¾ INTEGERâ€¾ ]â€¾ ;â€¾var-declaration â†’type-specifier ID ; âˆ£ type-specifier ID [ INTEGER ] ; type-specifierâ†’intâ€¾ âˆ£ floatâ€¾ âˆ£ voidâ€¾type-specifierâ†’int âˆ£ float âˆ£ void fun-declarationâ†’type-specifier IDâ€¾ (â€¾ params )â€¾ compound-stmtfun-declarationâ†’type-specifier ID ( params ) compound-stmt paramsâ†’param-list âˆ£ voidâ€¾paramsâ†’param-list âˆ£ void param-listâ†’param-list ,â€¾ param âˆ£ paramparam-listâ†’param-list , param âˆ£ param paramâ†’type-specifier IDâ€¾ âˆ£ type-specifier IDâ€¾ [â€¾ ]â€¾paramâ†’type-specifier ID âˆ£ type-specifier ID [ ] compound-stmtâ†’{â€¾ local-declarations statement-list }â€¾compound-stmtâ†’{ local-declarations statement-list } local-declarationsâ†’local-declarations var-declaration âˆ£ emptylocal-declarationsâ†’local-declarations var-declaration âˆ£ empty statement-listâ†’statement-list statement âˆ£ emptystatement-listâ†’statement-list statement âˆ£ empty statementâ†’ expression-stmtâˆ£ compound-stmtâˆ£ selection-stmtâˆ£ iteration-stmtâˆ£ return-stmtstatementâ†’ expression-stmtâˆ£ compound-stmtâˆ£ selection-stmtâˆ£ iteration-stmtâˆ£ return-stmt expression-stmtâ†’expression ;â€¾ âˆ£ ;â€¾expression-stmtâ†’expression ; âˆ£ ; selection-stmtâ†’ ifâ€¾ (â€¾ expression )â€¾ statementâˆ£ ifâ€¾ (â€¾ expression )â€¾ statement elseâ€¾ statementselection-stmtâ†’ if ( expression ) statementâˆ£ if ( expression ) statement else statement iteration-stmtâ†’whileâ€¾ (â€¾ expression )â€¾ statementiteration-stmtâ†’while ( expression ) statement return-stmtâ†’returnâ€¾ ;â€¾ âˆ£ returnâ€¾ expression ;â€¾return-stmtâ†’return ; âˆ£ return expression ; expressionâ†’var =â€¾ expression âˆ£ simple-expressionexpressionâ†’var = expression âˆ£ simple-expression varâ†’IDâ€¾ âˆ£ IDâ€¾ [â€¾ expression]â€¾varâ†’ID âˆ£ ID [ expression**]** simple-expressionâ†’additive-expression relop additive-expression âˆ£ additive-expressionsimple-expressionâ†’additive-expression relop additive-expression âˆ£ additive-expression relop â†’\u0026lt;=â€¾ âˆ£ \u0026lt;â€¾ âˆ£ \u0026gt;â€¾ âˆ£ \u0026gt;=â€¾ âˆ£ ==â€¾ âˆ£ !=â€¾relop â†’\u0026lt;= âˆ£ \u0026lt; âˆ£ \u0026gt; âˆ£ \u0026gt;= âˆ£ == âˆ£ != additive-expressionâ†’additive-expression addop term âˆ£ termadditive-expressionâ†’additive-expression addop term âˆ£ term addopâ†’+â€¾ âˆ£ -â€¾addopâ†’+ âˆ£ - termâ†’term mulop factor âˆ£ factortermâ†’term mulop factor âˆ£ factor mulopâ†’*â€¾ âˆ£ /â€¾mulopâ†’***** âˆ£ / factorâ†’(â€¾ expression )â€¾ âˆ£ var âˆ£ call âˆ£ integer âˆ£ floatfactorâ†’( expression ) âˆ£ var âˆ£ call âˆ£ integer âˆ£ float integerâ†’INTEGERâ€¾integerâ†’INTEGER floatâ†’FLOATPOINTâ€¾floatâ†’FLOATPOINT callâ†’IDâ€¾ (â€¾ args)â€¾callâ†’ID ( args**)** argsâ†’arg-list âˆ£ emptyargsâ†’arg-list âˆ£ empty arg-listâ†’arg-list ,â€¾ expression âˆ£ expressionarg-listâ†’arg-list , expression âˆ£ expression è¯­æ³•åˆ†æå™¨å¯å®ç°å¦‚ä¸‹åŠŸèƒ½ï¼š\nè¾“å…¥ï¼š\n1 int main(void) { return 0; } è¾“å‡ºè¯­æ³•æ ‘ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 \u0026gt;--+ program | \u0026gt;--+ declaration-list | | \u0026gt;--+ declaration | | | \u0026gt;--+ fun-declaration | | | | \u0026gt;--+ type-specifier | | | | | \u0026gt;--* int | | | | \u0026gt;--* main | | | | \u0026gt;--* ( | | | | \u0026gt;--+ params | | | | | \u0026gt;--* void | | | | \u0026gt;--* ) | | | | \u0026gt;--+ compound-stmt | | | | | \u0026gt;--* { | | | | | \u0026gt;--+ local-declarations | | | | | | \u0026gt;--* epsilon | | | | | \u0026gt;--+ statement-list | | | | | | \u0026gt;--+ statement-list | | | | | | | \u0026gt;--* epsilon | | | | | | \u0026gt;--+ statement | | | | | | | \u0026gt;--+ return-stmt | | | | | | | | \u0026gt;--* return | | | | | | | | \u0026gt;--+ expression | | | | | | | | | \u0026gt;--+ simple-expression | | | | | | | | | | \u0026gt;--+ additive-expression | | | | | | | | | | | \u0026gt;--+ term | | | | | | | | | | | | \u0026gt;--+ factor | | | | | | | | | | | | | \u0026gt;--+ integer | | | | | | | | | | | | | | \u0026gt;--* 0 | | | | | | | | \u0026gt;--* ; | | | | | \u0026gt;--* } å…·ä½“ä»£ç å¦‚ä¸‹ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 %{ #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdarg.h\u0026gt; #include \u0026#34;syntax_tree.h\u0026#34; // external functions from lex extern int yylex(); extern int yyparse(); extern int yyrestart(); extern FILE * yyin; // external variables from lexical_analyzer module extern int lines; extern char * yytext; extern int pos_end; extern int pos_start; // Global syntax tree syntax_tree *gt; // Error reporting void yyerror(const char *s); // Helper functions written for you with love syntax_tree_node *node(const char *node_name, int children_num, ...); %} /* TODO: Complete this definition. */ %union { struct _syntax_tree_node * node; char * name; } /* TODO: Your tokens here. */ %token \u0026lt;node\u0026gt; ERROR %token \u0026lt;node\u0026gt; ADD %token \u0026lt;node\u0026gt; SUB %token \u0026lt;node\u0026gt; MUL %token \u0026lt;node\u0026gt; DIV %token \u0026lt;node\u0026gt; LT %token \u0026lt;node\u0026gt; LTE %token \u0026lt;node\u0026gt; GT %token \u0026lt;node\u0026gt; GTE %token \u0026lt;node\u0026gt; EQ %token \u0026lt;node\u0026gt; NEQ %token \u0026lt;node\u0026gt; ASSIN %token \u0026lt;node\u0026gt; SEMICOLON %token \u0026lt;node\u0026gt; COMMA %token \u0026lt;node\u0026gt; LPARENTHESE %token \u0026lt;node\u0026gt; RPARENTHESE %token \u0026lt;node\u0026gt; LBRACKET %token \u0026lt;node\u0026gt; RBRACKET %token \u0026lt;node\u0026gt; LBRACE %token \u0026lt;node\u0026gt; RBRACE %token \u0026lt;node\u0026gt; ELSE %token \u0026lt;node\u0026gt; IF %token \u0026lt;node\u0026gt; INT %token \u0026lt;node\u0026gt; RETURN %token \u0026lt;node\u0026gt; VOID %token \u0026lt;node\u0026gt; WHILE %token \u0026lt;node\u0026gt; IDENTIFIER %token \u0026lt;node\u0026gt; INTEGER %token \u0026lt;node\u0026gt; FLOAT %token \u0026lt;node\u0026gt; FLOATPOINT\t// è¿™ä¸ªæ˜¯ float ç±»å‹çš„ token //%token \u0026lt;node\u0026gt; EOL //%token \u0026lt;node\u0026gt; BLANK //%token \u0026lt;node\u0026gt; COMMENT %type \u0026lt;node\u0026gt; program declaration-list declaration var-declaration type-specifier fun-declaration params param-list param compound-stmt local-declarations statement-list statement expression-stmt selection-stmt iteration-stmt return-stmt expression var simple-expression relop additive-expression addop term mulop factor integer float call args arg-list /* compulsory starting symbol */ %start program %% /* TODO: Your rules here. */ program : declaration-list {$$ = node( \u0026#34;program\u0026#34;, 1, $1); gt-\u0026gt;root = $$;} ; declaration-list : declaration-list declaration {$$ = node( \u0026#34;declaration-list\u0026#34;, 2, $1, $2);} |\tdeclaration {$$ = node( \u0026#34;declaration-list\u0026#34;, 1, $1);} ; declaration : var-declaration {$$ = node( \u0026#34;declaration\u0026#34;, 1, $1);} | fun-declaration {$$ = node( \u0026#34;declaration\u0026#34;, 1, $1);} ; var-declaration : type-specifier IDENTIFIER SEMICOLON {$$ = node( \u0026#34;var-declaration\u0026#34;, 3, $1, $2, $3);} | type-specifier IDENTIFIER LBRACKET INTEGER RBRACKET SEMICOLON {$$ = node( \u0026#34;var-declaration\u0026#34;, 6, $1, $2, $3, $4, $5, $6);} ; type-specifier : INT {$$ = node( \u0026#34;type-specifier\u0026#34;, 1, $1);} | FLOAT { $$ = node( \u0026#34;type-specifier\u0026#34;, 1, $1); } | VOID {$$ = node( \u0026#34;type-specifier\u0026#34;, 1, $1);} ; fun-declaration : type-specifier IDENTIFIER LPARENTHESE params RPARENTHESE compound-stmt {$$ = node( \u0026#34;fun-declaration\u0026#34;, 6, $1, $2, $3, $4, $5, $6);} ; params : param-list {$$ = node( \u0026#34;params\u0026#34;, 1, $1);} |\tVOID {$$ = node( \u0026#34;params\u0026#34;, 1, $1);} ; param-list : param-list COMMA param {$$ = node( \u0026#34;param-list\u0026#34;, 3, $1, $2, $3);} | param {$$ = node( \u0026#34;param-list\u0026#34;, 1, $1);} ; param : type-specifier IDENTIFIER {$$ = node( \u0026#34;param\u0026#34;, 2, $1, $2);} | type-specifier IDENTIFIER LBRACKET RBRACKET {$$ = node( \u0026#34;param\u0026#34;, 4, $1, $2, $3, $4);} ; compound-stmt : LBRACE local-declarations statement-list RBRACE {$$ = node( \u0026#34;compound-stmt\u0026#34;, 4, $1, $2, $3, $4);} ; local-declarations : local-declarations var-declaration {$$ = node( \u0026#34;local-declarations\u0026#34;, 2, $1, $2);} | {$$ = node( \u0026#34;local-declarations\u0026#34;,0);} ; statement-list : statement-list statement {$$ = node( \u0026#34;statement-list\u0026#34;, 2, $1, $2);} | {$$ = node( \u0026#34;statement-list\u0026#34;,0);} ; statement : expression-stmt {$$ = node( \u0026#34;statement\u0026#34;, 1, $1);} | compound-stmt {$$ = node( \u0026#34;statement\u0026#34;, 1, $1);} | selection-stmt {$$ = node( \u0026#34;statement\u0026#34;, 1, $1);} | iteration-stmt {$$ = node( \u0026#34;statement\u0026#34;, 1, $1);} | return-stmt {$$ = node( \u0026#34;statement\u0026#34;, 1, $1);} ; expression-stmt : expression SEMICOLON {$$ = node( \u0026#34;expression-stmt\u0026#34;, 2, $1, $2);} | SEMICOLON {$$ = node( \u0026#34;expression-stmt\u0026#34;, 1, $1);} ; selection-stmt : IF LPARENTHESE expression RPARENTHESE statement {$$ = node( \u0026#34;selection-stmt\u0026#34;, 5, $1, $2, $3, $4, $5);} | IF LPARENTHESE expression RPARENTHESE statement ELSE statement {$$ = node( \u0026#34;selection-stmt\u0026#34;, 7, $1, $2, $3, $4, $5, $6, $7);} ; iteration-stmt : WHILE LPARENTHESE expression RPARENTHESE statement {$$ = node( \u0026#34;iteration-stmt\u0026#34;, 5, $1, $2, $3, $4, $5);} ; return-stmt : RETURN SEMICOLON {$$ = node( \u0026#34;return-stmt\u0026#34;, 2, $1, $2);} | RETURN expression SEMICOLON {$$ = node( \u0026#34;return-stmt\u0026#34;, 3, $1, $2, $3);} ; expression : var ASSIN expression {$$ = node( \u0026#34;expression\u0026#34;, 3, $1, $2, $3);} | simple-expression {$$ = node( \u0026#34;expression\u0026#34;, 1, $1);} ; var : IDENTIFIER {$$ = node( \u0026#34;var\u0026#34;, 1, $1);} | IDENTIFIER LBRACKET expression RBRACKET {$$ = node( \u0026#34;var\u0026#34;, 4, $1, $2, $3, $4);} ; simple-expression : additive-expression relop additive-expression {$$ = node( \u0026#34;simple-expression\u0026#34;, 3, $1, $2, $3);} | additive-expression {$$ = node( \u0026#34;simple-expression\u0026#34;, 1, $1);} ; relop : LT {$$ = node( \u0026#34;relop\u0026#34;, 1, $1);} | LTE {$$ = node( \u0026#34;relop\u0026#34;, 1, $1);} | GT {$$ = node( \u0026#34;relop\u0026#34;, 1, $1);} | GTE {$$ = node( \u0026#34;relop\u0026#34;, 1, $1);} | EQ {$$ = node( \u0026#34;relop\u0026#34;, 1, $1);} | NEQ {$$ = node( \u0026#34;relop\u0026#34;, 1, $1);} ; additive-expression : additive-expression addop term {$$ = node( \u0026#34;additive-expression\u0026#34;, 3, $1, $2, $3);} | term {$$ = node( \u0026#34;additive-expression\u0026#34;, 1, $1);} ; addop : ADD {$$ = node( \u0026#34;addop\u0026#34;, 1, $1);} |\tSUB {$$ = node( \u0026#34;addop\u0026#34;, 1, $1);} ; term : term mulop factor {$$ = node( \u0026#34;term\u0026#34;, 3, $1, $2, $3);} | factor {$$ = node( \u0026#34;term\u0026#34;, 1, $1);} ; mulop : MUL {$$ = node( \u0026#34;mulop\u0026#34;, 1, $1);} |\tDIV {$$ = node( \u0026#34;mulop\u0026#34;, 1, $1);} ; factor : LPARENTHESE expression RPARENTHESE {$$ = node( \u0026#34;factor\u0026#34;, 3, $1, $2, $3);} |\tvar {$$ = node( \u0026#34;factor\u0026#34;, 1, $1);} |\tcall {$$ = node( \u0026#34;factor\u0026#34;, 1, $1);} |\tinteger {$$ = node( \u0026#34;factor\u0026#34;, 1, $1);} |\tfloat {$$ = node( \u0026#34;factor\u0026#34;, 1, $1);} ; integer : INTEGER {$$ = node( \u0026#34;integer\u0026#34;, 1, $1);} ; float : FLOATPOINT {$$ = node( \u0026#34;float\u0026#34;, 1, $1);} ; call : IDENTIFIER LPARENTHESE args RPARENTHESE {$$ = node( \u0026#34;call\u0026#34;, 4, $1, $2, $3, $4);} ; args : arg-list {$$ = node( \u0026#34;args\u0026#34;, 1, $1);} | {$$ = node( \u0026#34;args\u0026#34;, 0);} ; arg-list : arg-list COMMA expression {$$ = node( \u0026#34;arg-list\u0026#34;, 3, $1, $2, $3);} | expression {$$ = node( \u0026#34;arg-list\u0026#34;, 1, $1);} ; %% /// The error reporting function. void yyerror(const char * s) { // TO STUDENTS: This is just an example. // You can customize it as you like. fprintf(stderr, \u0026#34;error at line %d column %d: %s\\n\u0026#34;, lines, pos_start, s); } /// Parse input from file `input_path`, and prints the parsing results /// to stdout. If input_path is NULL, read from stdin. /// /// This function initializes essential states before running yyparse(). syntax_tree *parse(const char *input_path) { if (input_path != NULL) { if (!(yyin = fopen(input_path, \u0026#34;r\u0026#34;))) { fprintf(stderr, \u0026#34;[ERR] Open input file %s failed.\\n\u0026#34;, input_path); exit(1); } } else { yyin = stdin; } lines = pos_start = pos_end = 1; gt = new_syntax_tree(); yyrestart(yyin); yyparse(); return gt; } /// A helper function to quickly construct a tree node. /// /// e.g. $$ = node(\u0026#34;program\u0026#34;, 1, $1); syntax_tree_node *node(const char *name, int children_num, ...) { syntax_tree_node *p = new_syntax_tree_node(name); syntax_tree_node *child; // è¿™é‡Œè¡¨ç¤º epsilonç»“ç‚¹æ˜¯é€šè¿‡ children_num == 0 æ¥åˆ¤æ–­çš„ if (children_num == 0) { child = new_syntax_tree_node(\u0026#34;epsilon\u0026#34;); syntax_tree_add_child(p, child); } else { va_list ap; va_start(ap, children_num); for (int i = 0; i \u0026lt; children_num; ++i) { child = va_arg(ap, syntax_tree_node *); syntax_tree_add_child(p, child); } va_end(ap); } return p; } è¯­æ³•æ ‘-\u0026gt;ä¸­é—´ä»£ç \r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 #include \u0026#34;cminusf_builder.hpp\u0026#34; #include \u0026#34;BasicBlock.hpp\u0026#34; #include \u0026#34;Constant.hpp\u0026#34; #include \u0026#34;GlobalVariable.hpp\u0026#34; #include \u0026#34;Type.hpp\u0026#34; #include \u0026#34;Value.hpp\u0026#34; #include \u0026#34;ast.hpp\u0026#34; #include \u0026lt;cassert\u0026gt; #include \u0026lt;cstddef\u0026gt; #include \u0026lt;logging.hpp\u0026gt; #define CONST_FP(num) ConstantFP::get((float)num, module.get()) #define CONST_INT(num) ConstantInt::get(num, module.get()) // types Type *VOID_T; Type *INT1_T; Type *INT32_T; Type *INT32PTR_T; Type *FLOAT_T; Type *FLOATPTR_T; /* * use CMinusfBuilder::Scope to construct scopes * scope.enter: enter a new scope * scope.exit: exit current scope * scope.push: add a new binding to current scope * scope.find: find and return the value bound to the name123456 */ Value* CminusfBuilder::visit(ASTProgram \u0026amp;node) { VOID_T = module-\u0026gt;get_void_type(); INT1_T = module-\u0026gt;get_int1_type(); INT32_T = module-\u0026gt;get_int32_type(); INT32PTR_T = module-\u0026gt;get_int32_ptr_type(); FLOAT_T = module-\u0026gt;get_float_type(); FLOATPTR_T = module-\u0026gt;get_float_ptr_type(); Value *ret_val = nullptr; for (auto \u0026amp;decl : node.declarations) { ret_val = decl-\u0026gt;accept(*this);//è°ƒç”¨å¯¹åº”çš„visitå‡½æ•° } return ret_val; } Value* CminusfBuilder::visit(ASTNum \u0026amp;node) { // TODO: This function is empty now. // Add some code here. //å¦‚æœæ˜¯numï¼Œç›´æ¥å°†å€¼å­˜å…¥context.var if(node.type == TYPE_INT) context.var = ConstantInt::get(node.i_val, module.get()); else if(node.type == TYPE_FLOAT) context.var = ConstantFP::get(node.f_val, module.get()); return nullptr; } Value* CminusfBuilder::visit(ASTVarDeclaration \u0026amp;node) { // TODO: This function is empty now. // Add some code here. //vardeclaration-\u0026gt;type_specifier var;|vardeclaration-\u0026gt;type_specifier var[num]; //å…ˆå¤„ç†type_specifier //è¿™ä¸ªnodeåŒ…æ‹¬Id,numå’Œtypeï¼Œidæ˜¯å˜é‡åï¼Œnumæ˜¯æ•°ç»„å¤§å°ï¼Œtypeæ˜¯å˜é‡ç±»å‹ Type *var_type; if(node.type == TYPE_INT) var_type = INT32_T; else if(node.type == TYPE_FLOAT) var_type = FLOAT_T; else var_type = VOID_T; //è¿™é‡Œè·å–node.typeå¾—åˆ°ç±»å‹ if(scope.in_global())//å…¨å±€å˜é‡,ç”¨GlobalVariable { if(node.num == nullptr)//ä¸æ˜¯æ•°ç»„ { auto global_var = GlobalVariable::create(node.id,module.get(),var_type,false,ConstantZero::get(var_type, module.get())); scope.push(node.id, global_var); } else { auto *arrayType = ArrayType::get(var_type, node.num-\u0026gt;i_val);//node.num-\u0026gt;i_valæ˜¯æ•°ç»„å¤§å° auto global_var_array = GlobalVariable::create(node.id,module.get(),arrayType,false,ConstantZero::get(var_type, module.get())); scope.push(node.id, global_var_array); } } else //ä¸æ˜¯å…¨å±€å˜é‡å°±ç”¨builderåˆ†é…å†…å­˜ { if(node.num == nullptr) { auto alloca = builder-\u0026gt;create_alloca(var_type); scope.push(node.id, alloca); } else { auto *arrayType = ArrayType::get(var_type, node.num-\u0026gt;i_val); auto alloca_array = builder-\u0026gt;create_alloca(arrayType); scope.push(node.id, alloca_array); } } return nullptr; } Value* CminusfBuilder::visit(ASTFunDeclaration \u0026amp;node) { //FunDeclaration-\u0026gt;type_specifier id(Params) CompoundStmt //nodeåŒ…æ‹¬type,id,params,compound_stmt,åˆ†åˆ«æ˜¯è¿”å›å€¼ç±»å‹ï¼Œå‡½æ•°åï¼Œå‚æ•°ï¼Œå‡½æ•°ä½“ FunctionType *fun_type; Type *ret_type; std::vector\u0026lt;Type *\u0026gt; param_types; if (node.type == TYPE_INT) ret_type = INT32_T; else if (node.type == TYPE_FLOAT) ret_type = FLOAT_T; else ret_type = VOID_T; //ä¸Šé¢å¤„ç†è¿”å›å€¼ç±»å‹ï¼Œä¸‹é¢å¤„ç†å‚æ•°ç±»å‹ for (auto \u0026amp;param : node.params) { //è¿™é‡Œè·å¾—æ¯ä¸ªå‚æ•°ï¼Œè¿›è¡Œå¤„ç† //param-\u0026gt;type,param-\u0026gt;idï¼Œç±»å‹å’Œåç§° // TODO: Please accomplish param_types. if(param-\u0026gt;isarray)//æ•°ç»„ { if(param-\u0026gt;type == TYPE_INT) { param_types.push_back(INT32PTR_T);//è¿™é‡Œç”¨ptrçš„ç±»å‹å­˜å…¥å‘é‡ } else if(param-\u0026gt;type == TYPE_FLOAT) { param_types.push_back(FLOATPTR_T); } } else { if(param-\u0026gt;type == TYPE_INT) { param_types.push_back(INT32_T); } else if(param-\u0026gt;type == TYPE_FLOAT) { param_types.push_back(FLOAT_T); } } } //ä¸Šé¢å·²ç»æŠŠå‚æ•°ç±»å‹å­˜å…¥äº†param_typesä¸­ï¼Œä¸‹é¢åˆ›å»ºå‡½æ•° fun_type = FunctionType::get(ret_type, param_types); auto func = Function::create(fun_type, node.id, module.get()); scope.push(node.id, func);//å°†å‡½æ•°åå’Œå‡½æ•°ç»‘å®š context.func = func;//å­˜å…¥context auto funBB = BasicBlock::create(module.get(), \u0026#34;entry\u0026#34;, func); builder-\u0026gt;set_insert_point(funBB);//è®¾ç½®æ’å…¥ç‚¹ scope.enter();//è¿›å…¥å‡½æ•°ä½œç”¨åŸŸ std::vector\u0026lt;Value *\u0026gt; args; for (auto \u0026amp;arg : func-\u0026gt;get_args()) { args.push_back(\u0026amp;arg);//å°†å‚æ•°å­˜å…¥args } for (unsigned int i = 0; i \u0026lt; node.params.size(); ++i) {//å¤„ç†å‚æ•° // TODO: You need to deal with params and store them in the scope. //ç”±äºparam_typesä¸­å­˜å…¥äº†å‚æ•°ç±»å‹ï¼Œæ‰€ä»¥è¿™é‡Œåªéœ€è¦ç”¨å¯¹åº”å‚æ•°åå³å¯ //è¿™é‡Œå¤„ç†å‚æ•°ï¼Œå°†å‚æ•°å­˜å…¥allocaä¸­ auto alloca = builder-\u0026gt;create_alloca(param_types[i]); builder-\u0026gt;create_store(args[i], alloca); scope.push(node.params[i]-\u0026gt;id, alloca);//å°†å˜é‡å­˜å…¥ä½œç”¨åŸŸï¼Œç¡®ä¿åœ¨å‡½æ•°å†…éƒ¨å¯ä»¥è®¿é—®ï¼ŒåŒæ—¶åœ¨å‡½æ•°å¤–éƒ¨ä¸å¯è®¿é—®ï¼ŒåŠæ—¶æ¸…ç†é¿å…å˜é‡å†²çªå’Œå†…å­˜æ³„æ¼ } node.compound_stmt-\u0026gt;accept(*this);//è®¿é—®è€…æ¨¡å¼ï¼Œå¤„ç†å‡½æ•°ä½“ if (!(builder-\u0026gt;get_insert_block()-\u0026gt;is_terminated())) //å¦‚æœæ²¡æœ‰è¿”å›å€¼,åˆ™è¿”å›0 { if (context.func-\u0026gt;get_return_type()-\u0026gt;is_void_type()) builder-\u0026gt;create_void_ret();//voidç±»å‹ else if (context.func-\u0026gt;get_return_type()-\u0026gt;is_float_type()) builder-\u0026gt;create_ret(CONST_FP(0.));//floatç±»å‹ else builder-\u0026gt;create_ret(CONST_INT(0));//intç±»å‹ } scope.exit(); return nullptr; } Value* CminusfBuilder::visit(ASTParam \u0026amp;node) { // TODO: This function is empty now. // Add some code here. //ä¸Šé¢å·²ç»å¤„ç†äº†å‚æ•° return nullptr; } Value* CminusfBuilder::visit(ASTCompoundStmt \u0026amp;node) { // TODO: This function is not complete. // You may need to add some code here // to deal with complex statements. //compoundstmt-\u0026gt;{local_declarations statement_list} scope.enter(); //è¿›å…¥ä½œç”¨åŸŸï¼Œç¡®ä¿å±€éƒ¨å˜é‡ä¸ä¼šå’Œå…¨å±€å˜é‡å†²çª for (auto \u0026amp;decl : node.local_declarations) { decl-\u0026gt;accept(*this);//å¤„ç†å±€éƒ¨å˜é‡ } for (auto \u0026amp;stmt : node.statement_list) { stmt-\u0026gt;accept(*this);//å¤„ç†è¯­å¥ if (builder-\u0026gt;get_insert_block()-\u0026gt;is_terminated()) break;//å¦‚æœæ²¡æœ‰è¿”å›å€¼ï¼Œç›´æ¥é€€å‡º } scope.exit();//å¤„ç†å®Œå‡½æ•°ä½“ï¼Œé€€å‡ºä½œç”¨åŸŸ return nullptr; } Value* CminusfBuilder::visit(ASTExpressionStmt \u0026amp;node) { // TODO: This function is empty now. // Add some code here. //expressionstmt-\u0026gt;expressionstmt;|; if(node.expression != nullptr) node.expression-\u0026gt;accept(*this); return nullptr; } Value* CminusfBuilder::visit(ASTSelectionStmt \u0026amp;node) { // TODO: This function is empty now. // Add some code here. auto trueBB = BasicBlock::create(module.get(), \u0026#34;\u0026#34;, context.func); auto falseBB = BasicBlock::create(module.get(), \u0026#34;\u0026#34;, context.func); auto contBB = BasicBlock::create(module.get(), \u0026#34;\u0026#34;, context.func); Value * cond; node.expression-\u0026gt;accept(*this); if(context.var-\u0026gt;get_type()-\u0026gt;is_integer_type()) { cond = builder-\u0026gt;create_icmp_gt(context.var, CONST_INT(0)); } else { cond = builder-\u0026gt;create_fcmp_gt(context.var, CONST_FP(0.0)); } //ä¸Šé¢åˆ›å»ºäº†å’Œ0æ¯”è¾ƒçš„æŒ‡ä»¤ï¼Œä¸‹é¢åˆ›å»ºæ¡ä»¶è·³è½¬ if(node.else_statement == nullptr) { builder-\u0026gt;create_cond_br(cond, trueBB, contBB); } else { builder-\u0026gt;create_cond_br(cond, trueBB, falseBB); } //å¦‚æœæœ‰elseè¯­å¥ï¼Œåˆ›å»ºæ¡ä»¶è·³è½¬ï¼Œæ²¡æœ‰å°±è·³è½¬æ¥ä¸‹æ¥çš„è¯­å¥ï¼ˆcontBBï¼‰ builder-\u0026gt;set_insert_point(trueBB);//è®¾ç½®æ’å…¥ç‚¹ï¼ŒæŒ‡å®šä¸‹é¢çš„è¯­å¥åœ¨trueBBä¸­ node.if_statement-\u0026gt;accept(*this); if(!builder-\u0026gt;get_insert_block()-\u0026gt;is_terminated())//å¦‚æœæ²¡æœ‰è¿”å›å€¼ï¼Œåˆ›å»ºä¸€ä¸ªè·³è½¬ï¼Œé¿å…å‡ºç°å¤šä¸ªè¿”å›å€¼ { builder-\u0026gt;create_br(contBB); } if(node.else_statement == nullptr) { falseBB-\u0026gt;erase_from_parent();//ä¸å­˜åœ¨elseåˆ é™¤falseBB } else { builder-\u0026gt;set_insert_point(falseBB); node.else_statement-\u0026gt;accept(*this); if(!builder-\u0026gt;get_insert_block()-\u0026gt;is_terminated()) { builder-\u0026gt;create_br(contBB); } } builder-\u0026gt;set_insert_point(contBB); return nullptr; } Value* CminusfBuilder::visit(ASTIterationStmt \u0026amp;node) { // TODO: This function is empty now. // Add some code here. //iterationstmt-\u0026gt;while(expression)statement auto condBB = BasicBlock::create(module.get(), \u0026#34;\u0026#34;, context.func); auto bodyBB = BasicBlock::create(module.get(), \u0026#34;\u0026#34;, context.func); auto afterBB = BasicBlock::create(module.get(), \u0026#34;\u0026#34;, context.func); //ä¸Šé¢ä¸‰ä¸ªåŸºæœ¬å—ï¼Œåˆ†åˆ«æ˜¯æ¡ä»¶åˆ¤æ–­ï¼Œå¾ªç¯ä½“ï¼Œå¾ªç¯ç»“æŸ Value * cond; if(!builder-\u0026gt;get_insert_block()-\u0026gt;is_terminated())//å¦‚æœæ²¡ç»ˆç»“ï¼Œåˆ›å»ºä¸€ä¸ªè·³è½¬ { builder-\u0026gt;create_br(condBB); } builder-\u0026gt;set_insert_point(condBB); node.expression-\u0026gt;accept(*this);//è¿™é‡Œå¤„ç†æ¡ä»¶ï¼Œcontext.varå­˜å‚¨äº†è¡¨è¾¾å¼çš„å€¼ï¼Œä¸‹é¢å’Œ0æ¯”è¾ƒ if(context.var-\u0026gt;get_type()-\u0026gt;is_integer_type()) { cond = builder-\u0026gt;create_icmp_gt(context.var, CONST_INT(0)); } else { cond = builder-\u0026gt;create_fcmp_gt(context.var, CONST_FP(0.0)); } builder-\u0026gt;create_cond_br(cond, bodyBB, afterBB); builder-\u0026gt;set_insert_point(bodyBB); node.statement-\u0026gt;accept(*this);//å¤„ç†å¾ªç¯ä½“ if(!builder-\u0026gt;get_insert_block()-\u0026gt;is_terminated()) { builder-\u0026gt;create_br(condBB);//å¦‚æœæ²¡æœ‰è¿”å›å€¼ï¼Œåˆ›å»ºä¸€ä¸ªè·³è½¬ } builder-\u0026gt;set_insert_point(afterBB); return nullptr; } Value* CminusfBuilder::visit(ASTReturnStmt \u0026amp;node) { //returnstmt-\u0026gt;return;|return expression; if (node.expression == nullptr) {//æ²¡æœ‰è¿”å›å€¼ï¼Œç½®ä¸ºvoid builder-\u0026gt;create_void_ret(); return nullptr; } else { // TODO: The given code is incomplete. // You need to solve other return cases (e.g. return an integer). node.expression-\u0026gt;accept(*this); //è¿™å¥å¤„ç†å®Œï¼Œcontext.varå­˜å‚¨äº†è¿”å›å€¼ï¼Œcontext.funcå­˜å‚¨äº†ä¹‹å‰å‡½æ•°çš„ä¿¡æ¯ // auto fun = builder-\u0026gt;get_insert_block()-\u0026gt;get_parent(); auto ret_type = context.func-\u0026gt;get_return_type(); //ä¸‹é¢å¤„ç†ä¸ä¸€è‡´çš„æƒ…å†µ if(ret_type-\u0026gt;is_float_type()) { if(context.var-\u0026gt;get_type()-\u0026gt;is_integer_type()) { context.var = builder-\u0026gt;create_sitofp(context.var, FLOAT_T); } builder-\u0026gt;create_ret(context.var); } else if(ret_type-\u0026gt;is_integer_type()) { if(context.var-\u0026gt;get_type()-\u0026gt;is_float_type()) { context.var = builder-\u0026gt;create_fptosi(context.var, INT32_T); } builder-\u0026gt;create_ret(context.var); } else if(ret_type-\u0026gt;is_void_type()) { builder-\u0026gt;create_void_ret(); } } return nullptr; } Value* CminusfBuilder::visit(ASTVar \u0026amp;node) { if(node.expression == nullptr)//ä¸æ˜¯æ•°ç»„ { auto var = scope.find(node.id);//åœ¨å½“å‰ä½œç”¨åŸŸä¸­æŸ¥æ‰¾å˜é‡ assert(var!=nullptr); if(var-\u0026gt;get_type()-\u0026gt;is_pointer_type()) { if(var-\u0026gt;get_type()-\u0026gt;get_pointer_element_type()-\u0026gt;is_array_type()) { var = builder-\u0026gt;create_gep(var, {CONST_INT(0), CONST_INT(0)}); } else { // LOG(DEBUG)\u0026lt;\u0026lt;\u0026#34;var type is\u0026#34;\u0026lt;\u0026lt;var-\u0026gt;get_type()-\u0026gt;print(); if(builder-\u0026gt;create_load(var)-\u0026gt;get_type()-\u0026gt;is_pointer_type()) { var = builder-\u0026gt;create_load(var); } var = builder-\u0026gt;create_gep(var, {CONST_INT(0)}); // var = builder-\u0026gt;create_load(var); } //å¦‚æœæ˜¯æŒ‡é’ˆï¼Œåˆ™è¿”å›ç¬¬ä¸€ä¸ªå…ƒç´ åœ°å€ï¼Œæ•°ç»„å°±æ˜¯[0][0],æ™®é€šå˜é‡å°±æ˜¯[0] } context.var_location = var;//æŠŠåœ°å€å­˜å…¥context.var_location context.var = builder-\u0026gt;create_load(context.var_location);//åŠ è½½å˜é‡ } else { node.expression-\u0026gt;accept(*this);//å¤„ç†æ•°ç»„ç´¢å¼• // auto fun = builder-\u0026gt;get_insert_block()-\u0026gt;get_parent(); Value* index; if(context.var-\u0026gt;get_type()-\u0026gt;is_float_type())//å¦‚æœæ˜¯æµ®ç‚¹æ•°ï¼Œè½¬æ¢ä¸ºæ•´æ•° { index = builder-\u0026gt;create_fptosi(context.var, INT32_T); } else { index = context.var; } //ä¸‹é¢å¤„ç†è´Ÿæ•°ç´¢å¼• auto index_check = builder-\u0026gt;create_icmp_lt(index, CONST_INT(0)); //index_checkæ˜¯ä¸€ä¸ªæ¯”è¾ƒæŒ‡ä»¤ï¼Œåˆ¤æ–­indexæ˜¯å¦å°äº0 auto excpetBB = BasicBlock::create(module.get(), \u0026#34;\u0026#34;, context.func); //åˆ›å»ºå¼‚å¸¸åŸºæœ¬å—ï¼Œè°ƒç”¨neg_idx_except auto normalBB = BasicBlock::create(module.get(), \u0026#34;\u0026#34;, context.func); builder-\u0026gt;create_cond_br(index_check, excpetBB, normalBB); builder-\u0026gt;set_insert_point(excpetBB); auto except = scope.find(\u0026#34;neg_idx_except\u0026#34;); builder-\u0026gt;create_call(except, {}); builder-\u0026gt;create_br(normalBB);//å¼‚å¸¸å¤„ç†å®Œï¼Œè·³è½¬åˆ°normalBB builder-\u0026gt;set_insert_point(normalBB); auto var_array = scope.find(node.id); Value* var_array_gep; if(var_array-\u0026gt;get_type()-\u0026gt;get_pointer_element_type()-\u0026gt;is_array_type()) { var_array_gep = builder-\u0026gt;create_gep(var_array, {CONST_INT(0), index}); } else { // LOG(DEBUG)\u0026lt;\u0026lt;\u0026#34;var_array type is\u0026#34;\u0026lt;\u0026lt;var_array-\u0026gt;get_type()-\u0026gt;print(); auto var_load= builder-\u0026gt;create_load(var_array); var_array_gep = builder-\u0026gt;create_gep(var_load, {index}); } context.var_location = var_array_gep; context.var = builder-\u0026gt;create_load(var_array_gep); } return nullptr; } Value* CminusfBuilder::visit(ASTAssignExpression \u0026amp;node) { // TODO: This function is empty now. // Add some code here. //assignexpression-\u0026gt;var=expression Value* var;//å­˜å‚¨å˜é‡åœ°å€ï¼Œç”¨äºåŠ è½½å‡ºcontext.var Value* num;//å­˜å‚¨varçš„å€¼ node.var-\u0026gt;accept(*this); var = context.var_location; num = context.var; node.expression-\u0026gt;accept(*this); //è¿™æ­¥å¤„ç†å®Œåcontext.varå­˜å‚¨äº†è¡¨è¾¾å¼çš„å€¼ if(num-\u0026gt;get_type() != context.var-\u0026gt;get_type()) { if(num-\u0026gt;get_type()-\u0026gt;is_integer_type()) { context.var = builder-\u0026gt;create_fptosi(context.var, INT32_T); } else if(num-\u0026gt;get_type()-\u0026gt;is_float_type()) { context.var = builder-\u0026gt;create_sitofp(context.var, FLOAT_T); } } //å¼ºåˆ¶ç±»å‹è½¬æ¢ï¼Œè½¬æ¢ä¸ºvarçš„ç±»å‹ builder-\u0026gt;create_store(context.var, var); return nullptr; } Value* CminusfBuilder::visit(ASTSimpleExpression \u0026amp;node) { // TODO: This function is empty now. // Add some code here. //simpleexpression-\u0026gt;additive_expression relop additive_expression node.additive_expression_l-\u0026gt;accept(*this); if(node.additive_expression_r != nullptr) { Value* lhs = context.var;//å‰é¢å¤„ç†è¿‡å·¦è¾¹çš„è¡¨è¾¾å¼ï¼Œcontext.varå­˜å‚¨äº†å·¦è¾¹çš„å€¼ node.additive_expression_r-\u0026gt;accept(*this); Value* rhs = context.var; if((lhs-\u0026gt;get_type()-\u0026gt;is_integer_type())\u0026amp;\u0026amp;(rhs-\u0026gt;get_type()-\u0026gt;is_integer_type())) //å¦‚æœéƒ½æ˜¯æ•´å‹ { switch(node.op) { case OP_EQ : context.var = builder-\u0026gt;create_icmp_eq(lhs,rhs); break; case OP_GE : context.var = builder-\u0026gt;create_icmp_ge(lhs, rhs); break; case OP_GT : context.var = builder-\u0026gt;create_icmp_gt(lhs, rhs); break; case OP_LE : context.var = builder-\u0026gt;create_icmp_le(lhs, rhs); break; case OP_LT : context.var = builder-\u0026gt;create_icmp_lt(lhs, rhs); break; case OP_NEQ : context.var = builder-\u0026gt;create_icmp_ne(lhs, rhs); break; } } else { if(lhs-\u0026gt;get_type()-\u0026gt;is_integer_type()) { lhs = builder-\u0026gt;create_sitofp(lhs, FLOAT_T); } else if(rhs-\u0026gt;get_type()-\u0026gt;is_integer_type()) { rhs = builder-\u0026gt;create_sitofp(rhs, FLOAT_T); }//å¦‚æœæœ‰ä¸€ä¸ªæ˜¯æ•´å‹ï¼Œè½¬æ¢ä¸ºæµ®ç‚¹å‹ switch(node.op) { case OP_EQ : context.var = builder-\u0026gt;create_fcmp_eq(lhs,rhs); break; case OP_GE : context.var = builder-\u0026gt;create_fcmp_ge(lhs, rhs); break; case OP_GT : context.var = builder-\u0026gt;create_fcmp_gt(lhs, rhs); break; case OP_LE : context.var = builder-\u0026gt;create_fcmp_le(lhs, rhs); break; case OP_LT : context.var = builder-\u0026gt;create_fcmp_lt(lhs, rhs); break; case OP_NEQ : context.var = builder-\u0026gt;create_fcmp_ne(lhs, rhs); break; } } context.var = builder-\u0026gt;create_zext(context.var, INT32_T);//è½¬æ¢ä¸ºæ•´å‹ } return nullptr; } Value* CminusfBuilder::visit(ASTAdditiveExpression \u0026amp;node) { // TODO: This function is empty now. // Add some code here. //additiveexpression-\u0026gt;additive_expression addop term|term if(node.additive_expression == nullptr) { node.term-\u0026gt;accept(*this); } else { node.additive_expression-\u0026gt;accept(*this); Value* lhs = context.var;//lhså­˜å‚¨å·¦è¾¹additive_expressionçš„å€¼ node.term-\u0026gt;accept(*this); Value* rhs = context.var;//rhså­˜å‚¨termçš„å€¼ if((lhs-\u0026gt;get_type()-\u0026gt;is_integer_type())\u0026amp;\u0026amp;(rhs-\u0026gt;get_type()-\u0026gt;is_integer_type())) { switch(node.op) { case OP_PLUS : context.var = builder-\u0026gt;create_iadd(lhs, rhs); break; case OP_MINUS: context.var = builder-\u0026gt;create_isub(lhs, rhs); break; } } else { if(lhs-\u0026gt;get_type()-\u0026gt;is_integer_type()) { lhs = builder-\u0026gt;create_sitofp(lhs, FLOAT_T); } else if(rhs-\u0026gt;get_type()-\u0026gt;is_integer_type()) { rhs = builder-\u0026gt;create_sitofp(rhs, FLOAT_T); } switch(node.op) { case OP_PLUS : context.var = builder-\u0026gt;create_fadd(lhs, rhs); break; case OP_MINUS: context.var = builder-\u0026gt;create_fsub(lhs, rhs); break; } } } return nullptr; } Value* CminusfBuilder::visit(ASTTerm \u0026amp;node) { // TODO: This function is empty now. // Add some code here. //term-\u0026gt;term mulop factor|factor if(node.term == nullptr) { node.factor-\u0026gt;accept(*this); } else//å’Œå‰é¢ç±»ä¼¼ { node.term-\u0026gt;accept(*this); Value* lhs = context.var; node.factor-\u0026gt;accept(*this); Value* rhs = context.var; if((lhs-\u0026gt;get_type()-\u0026gt;is_integer_type())\u0026amp;\u0026amp;(rhs-\u0026gt;get_type()-\u0026gt;is_integer_type())) { switch(node.op) { case OP_MUL : context.var = builder-\u0026gt;create_imul(lhs, rhs); break; case OP_DIV : context.var = builder-\u0026gt;create_isdiv(lhs, rhs); break; } } else { if(lhs-\u0026gt;get_type()-\u0026gt;is_integer_type()) { lhs = builder-\u0026gt;create_sitofp(lhs, FLOAT_T); } else if(rhs-\u0026gt;get_type()-\u0026gt;is_integer_type()) { rhs = builder-\u0026gt;create_sitofp(rhs, FLOAT_T); } switch(node.op) { case OP_MUL : context.var = builder-\u0026gt;create_fmul(lhs, rhs); break; case OP_DIV : context.var = builder-\u0026gt;create_fdiv(lhs, rhs); break; } } } return nullptr; } Value* CminusfBuilder::visit(ASTCall \u0026amp;node) { // TODO: This function is empty now. // Add some code here. //call-\u0026gt;id(args) auto func = static_cast\u0026lt;Function*\u0026gt;(scope.find(node.id)); std::vector\u0026lt;Value*\u0026gt; args; auto param_type = func-\u0026gt;get_function_type()-\u0026gt;param_begin(); for(auto \u0026amp;arg : node.args) { arg-\u0026gt;accept(*this); if((*param_type)-\u0026gt;is_pointer_type()) { args.push_back(context.var_location); } else { if((*param_type)-\u0026gt;is_integer_type() \u0026amp;\u0026amp; context.var-\u0026gt;get_type()-\u0026gt;is_float_type()) { context.var = builder-\u0026gt;create_fptosi(context.var, INT32_T); args.push_back(context.var); } else if((*param_type)-\u0026gt;is_float_type() \u0026amp;\u0026amp; context.var-\u0026gt;get_type()-\u0026gt;is_integer_type()) { context.var = builder-\u0026gt;create_sitofp(context.var, FLOAT_T); args.push_back(context.var); } else { args.push_back(context.var); } } param_type++; } if (func-\u0026gt;get_function_type()-\u0026gt;get_num_of_args() != args.size()) { std::cerr \u0026lt;\u0026lt; \u0026#34;Error: Wrong number of arguments for function \u0026#34; \u0026lt;\u0026lt; node.id \u0026lt;\u0026lt; std::endl; return nullptr; } context.var = builder-\u0026gt;create_call(func, args); return nullptr; } ä¸­é—´ä»£ç -\u0026gt;é¾™èŠ¯æ±‡ç¼–\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 #include \u0026#34;CodeGen.hpp\u0026#34; #include \u0026#34;ASMInstruction.hpp\u0026#34; #include \u0026#34;CodeGenUtil.hpp\u0026#34; #include \u0026#34;Instruction.hpp\u0026#34; #include \u0026#34;Register.hpp\u0026#34; #include \u0026lt;cassert\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;logging.hpp\u0026gt; void CodeGen::allocate() { // å¤‡ä»½ $ra $fp unsigned offset = PROLOGUE_OFFSET_BASE; // ä¸ºæ¯ä¸ªå‚æ•°åˆ†é…æ ˆç©ºé—´ for (auto \u0026amp;arg : context.func-\u0026gt;get_args()) { auto size = arg.get_type()-\u0026gt;get_size(); offset = offset + size; context.offset_map[\u0026amp;arg] = -static_cast\u0026lt;int\u0026gt;(offset); } // ä¸ºæŒ‡ä»¤ç»“æœåˆ†é…æ ˆç©ºé—´ for (auto \u0026amp;bb : context.func-\u0026gt;get_basic_blocks()) { for (auto \u0026amp;instr : bb.get_instructions()) { // æ¯ä¸ªé void çš„å®šå€¼éƒ½åˆ†é…æ ˆç©ºé—´ if (not instr.is_void()) { auto size = instr.get_type()-\u0026gt;get_size(); offset = offset + size; context.offset_map[\u0026amp;instr] = -static_cast\u0026lt;int\u0026gt;(offset); } // alloca çš„å‰¯ä½œç”¨ï¼šåˆ†é…é¢å¤–ç©ºé—´ if (instr.is_alloca()) { auto *alloca_inst = static_cast\u0026lt;AllocaInst *\u0026gt;(\u0026amp;instr); auto alloc_size = alloca_inst-\u0026gt;get_alloca_type()-\u0026gt;get_size(); offset += alloc_size; } } } // åˆ†é…æ ˆç©ºé—´ï¼Œéœ€è¦æ˜¯ 16 çš„æ•´æ•°å€ context.frame_size = ALIGN(offset, PROLOGUE_ALIGN); } void CodeGen::copy_stmt() { for (auto \u0026amp;succ : context.bb-\u0026gt;get_succ_basic_blocks()) { for (auto \u0026amp;inst : succ-\u0026gt;get_instructions()) { if (inst.is_phi()) { // éå†åç»§å—ä¸­ phi çš„å®šå€¼ bb for (unsigned i = 1; i \u0026lt; inst.get_operands().size(); i += 2) { // phi çš„å®šå€¼ bb æ˜¯å½“å‰ç¿»è¯‘å— if (inst.get_operand(i) == context.bb) { auto *lvalue = inst.get_operand(i - 1); if (lvalue-\u0026gt;get_type()-\u0026gt;is_float_type()) { load_to_freg(lvalue, FReg::fa(0)); store_from_freg(\u0026amp;inst, FReg::fa(0)); } else { load_to_greg(lvalue, Reg::a(0)); store_from_greg(\u0026amp;inst, Reg::a(0)); } break; } // å¦‚æœæ²¡æœ‰æ‰¾åˆ°å½“å‰ç¿»è¯‘å—ï¼Œè¯´æ˜æ˜¯ undefï¼Œæ— äº‹å¯åš } } else { break; } } } } void CodeGen::load_to_greg(Value *val, const Reg \u0026amp;reg) { assert(val-\u0026gt;get_type()-\u0026gt;is_integer_type() || val-\u0026gt;get_type()-\u0026gt;is_pointer_type()); if (auto *constant = dynamic_cast\u0026lt;ConstantInt *\u0026gt;(val)) { int32_t val = constant-\u0026gt;get_value(); if (IS_IMM_12(val)) { append_inst(ADDI WORD, {reg.print(), \u0026#34;$zero\u0026#34;, std::to_string(val)}); } else { load_large_int32(val, reg); } } else if (auto *global = dynamic_cast\u0026lt;GlobalVariable *\u0026gt;(val)) { append_inst(LOAD_ADDR, {reg.print(), global-\u0026gt;get_name()}); } else { load_from_stack_to_greg(val, reg); } } void CodeGen::load_large_int32(int32_t val, const Reg \u0026amp;reg) { int32_t high_20 = val \u0026gt;\u0026gt; 12; // si20 uint32_t low_12 = val \u0026amp; LOW_12_MASK; append_inst(LU12I_W, {reg.print(), std::to_string(high_20)}); append_inst(ORI, {reg.print(), reg.print(), std::to_string(low_12)}); } void CodeGen::load_large_int64(int64_t val, const Reg \u0026amp;reg) { auto low_32 = static_cast\u0026lt;int32_t\u0026gt;(val \u0026amp; LOW_32_MASK); load_large_int32(low_32, reg); auto high_32 = static_cast\u0026lt;int32_t\u0026gt;(val \u0026gt;\u0026gt; 32); int32_t high_32_low_20 = (high_32 \u0026lt;\u0026lt; 12) \u0026gt;\u0026gt; 12; // si20 int32_t high_32_high_12 = high_32 \u0026gt;\u0026gt; 20; // si12 append_inst(LU32I_D, {reg.print(), std::to_string(high_32_low_20)}); append_inst(LU52I_D, {reg.print(), reg.print(), std::to_string(high_32_high_12)}); } void CodeGen::load_from_stack_to_greg(Value *val, const Reg \u0026amp;reg) { auto offset = context.offset_map.at(val); auto offset_str = std::to_string(offset); auto *type = val-\u0026gt;get_type(); if (IS_IMM_12(offset)) { if (type-\u0026gt;is_int1_type()) { append_inst(LOAD BYTE, {reg.print(), \u0026#34;$fp\u0026#34;, offset_str}); } else if (type-\u0026gt;is_int32_type()) { append_inst(LOAD WORD, {reg.print(), \u0026#34;$fp\u0026#34;, offset_str}); } else { // Pointer append_inst(LOAD DOUBLE, {reg.print(), \u0026#34;$fp\u0026#34;, offset_str}); } } else { load_large_int64(offset, reg); append_inst(ADD DOUBLE, {reg.print(), \u0026#34;$fp\u0026#34;, reg.print()}); if (type-\u0026gt;is_int1_type()) { append_inst(LOAD BYTE, {reg.print(), reg.print(), \u0026#34;0\u0026#34;}); } else if (type-\u0026gt;is_int32_type()) { append_inst(LOAD WORD, {reg.print(), reg.print(), \u0026#34;0\u0026#34;}); } else { // Pointer append_inst(LOAD DOUBLE, {reg.print(), reg.print(), \u0026#34;0\u0026#34;}); } } } void CodeGen::store_from_greg(Value *val, const Reg \u0026amp;reg) { auto offset = context.offset_map.at(val); auto offset_str = std::to_string(offset); auto *type = val-\u0026gt;get_type(); if (IS_IMM_12(offset)) { if (type-\u0026gt;is_int1_type()) { append_inst(STORE BYTE, {reg.print(), \u0026#34;$fp\u0026#34;, offset_str}); } else if (type-\u0026gt;is_int32_type()) { append_inst(STORE WORD, {reg.print(), \u0026#34;$fp\u0026#34;, offset_str}); } else { // Pointer append_inst(STORE DOUBLE, {reg.print(), \u0026#34;$fp\u0026#34;, offset_str}); } } else { auto addr = Reg::t(8); load_large_int64(offset, addr); append_inst(ADD DOUBLE, {addr.print(), \u0026#34;$fp\u0026#34;, addr.print()}); if (type-\u0026gt;is_int1_type()) { append_inst(STORE BYTE, {reg.print(), addr.print(), \u0026#34;0\u0026#34;}); } else if (type-\u0026gt;is_int32_type()) { append_inst(STORE WORD, {reg.print(), addr.print(), \u0026#34;0\u0026#34;}); } else { // Pointer append_inst(STORE DOUBLE, {reg.print(), addr.print(), \u0026#34;0\u0026#34;}); } } } void CodeGen::load_to_freg(Value *val, const FReg \u0026amp;freg) { assert(val-\u0026gt;get_type()-\u0026gt;is_float_type()); if (auto *constant = dynamic_cast\u0026lt;ConstantFP *\u0026gt;(val)) { float val = constant-\u0026gt;get_value(); load_float_imm(val, freg); } else { auto offset = context.offset_map.at(val); auto offset_str = std::to_string(offset); if (IS_IMM_12(offset)) { append_inst(FLOAD SINGLE, {freg.print(), \u0026#34;$fp\u0026#34;, offset_str}); } else { auto addr = Reg::t(8); load_large_int64(offset, addr); append_inst(ADD DOUBLE, {addr.print(), \u0026#34;$fp\u0026#34;, addr.print()}); append_inst(FLOAD SINGLE, {freg.print(), addr.print(), \u0026#34;0\u0026#34;}); } } } void CodeGen::load_float_imm(float val, const FReg \u0026amp;r) { int32_t bytes = *reinterpret_cast\u0026lt;int32_t *\u0026gt;(\u0026amp;val); load_large_int32(bytes, Reg::t(8)); append_inst(GR2FR WORD, {r.print(), Reg::t(8).print()}); } void CodeGen::store_from_freg(Value *val, const FReg \u0026amp;r) { auto offset = context.offset_map.at(val); if (IS_IMM_12(offset)) { auto offset_str = std::to_string(offset); append_inst(FSTORE SINGLE, {r.print(), \u0026#34;$fp\u0026#34;, offset_str}); } else { auto addr = Reg::t(8); load_large_int64(offset, addr); append_inst(ADD DOUBLE, {addr.print(), \u0026#34;$fp\u0026#34;, addr.print()}); append_inst(FSTORE SINGLE, {r.print(), addr.print(), \u0026#34;0\u0026#34;}); } } void CodeGen::gen_prologue() { //è¯¥å‡½æ•°ç”¨æ¥æ’å…¥å‡½æ•°çš„åºè¨€ if (IS_IMM_12(-static_cast\u0026lt;int\u0026gt;(context.frame_size))) //ä¸Šé¢è¿™ä¸ªç”¨æ¥åˆ¤æ–­å½“å‰æ ˆå¸§å¤§å°æ˜¯å¦åœ¨12ä½ç«‹å³æ•°èŒƒå›´å†… { append_inst(\u0026#34;st.d $ra, $sp, -8\u0026#34;); append_inst(\u0026#34;st.d $fp, $sp, -16\u0026#34;); append_inst(\u0026#34;addi.d $fp, $sp, 0\u0026#34;); append_inst(\u0026#34;addi.d $sp, $sp, \u0026#34; + std::to_string(-static_cast\u0026lt;int\u0026gt;(context.frame_size))); } else { load_large_int64(context.frame_size, Reg::t(0)); append_inst(\u0026#34;st.d $ra, $sp, -8\u0026#34;); append_inst(\u0026#34;st.d $fp, $sp, -16\u0026#34;); append_inst(\u0026#34;sub.d $sp, $sp, $t0\u0026#34;); append_inst(\u0026#34;add.d $fp, $sp, $t0\u0026#34;); } int garg_cnt = 0; int farg_cnt = 0; //åˆå§‹åŒ–ä¸¤ä¸ªè®¡æ•°å™¨ï¼Œåˆ†åˆ«ç”¨äºæ•´æ•°/æŒ‡é’ˆç±»å‹å‚æ•°å’Œæµ®ç‚¹ç±»å‹å‚æ•°çš„å¯„å­˜å™¨ç´¢å¼• for (auto \u0026amp;arg : context.func-\u0026gt;get_args()) { //éå†å½“å‰å‡½æ•°æ‰€æœ‰å‚æ•°ï¼Œå¦‚æœæ˜¯mainä¼ çš„ä¸ºvoidå°±æ²¡æœ‰å‚æ•° if (arg.get_type()-\u0026gt;is_float_type()) { store_from_freg(\u0026amp;arg, FReg::fa(farg_cnt++)); } else { // int or pointer store_from_greg(\u0026amp;arg, Reg::a(garg_cnt++)); } } //å…ˆå°†å‚æ•°ä¼ å…¥æ ˆå¸§ä¸­ï¼Œä»¥ä¾¿åœ¨å‡½æ•°ä½“å†…éƒ¨å¯ä»¥æ­£ç¡®è®¿é—®è¿™äº›å‚æ•° } void CodeGen::gen_epilogue() { // TODO æ ¹æ®ä½ çš„ç†è§£è®¾å®šå‡½æ•°çš„ epilogue // throw not_implemented_error{__FUNCTION__}; append_inst(func_exit_label_name(context.func),ASMInstruction::Label); if(IS_IMM_12(context.frame_size)) { append_inst(\u0026#34;addi.d $sp, $sp, \u0026#34; + std::to_string(context.frame_size)); append_inst(\u0026#34;ld.d $ra, $sp, -8\u0026#34;); append_inst(\u0026#34;ld.d $fp, $sp, -16\u0026#34;); append_inst(\u0026#34;jr $ra\u0026#34;); } else { load_large_int64(context.frame_size, Reg::t(0)); append_inst(\u0026#34;addi.d $sp, $sp, $t0\u0026#34;); append_inst(\u0026#34;ld.d $ra, $sp, -8\u0026#34;); append_inst(\u0026#34;ld.d $fp, $sp, -16\u0026#34;); append_inst(\u0026#34;jr $ra\u0026#34;); } } void CodeGen::gen_ret() { // TODO å‡½æ•°è¿”å›ï¼Œæ€è€ƒå¦‚ä½•å¤„ç†è¿”å›å€¼ã€å¯„å­˜å™¨å¤‡ä»½ï¼Œå¦‚ä½•è¿”å›è°ƒç”¨è€…åœ°å€ // throw not_implemented_error{__FUNCTION__}; //ReturnInst(Value *val, BasicBlock *bb); auto *retInst = static_cast\u0026lt;ReturnInst *\u0026gt;(context.inst); if(retInst-\u0026gt;is_void_ret()) { // gen_epilogue(); append_inst(\u0026#34;addi.w\u0026#34;,{\u0026#34;$a0\u0026#34;, \u0026#34;$zero\u0026#34;, \u0026#34;0\u0026#34;}); append_inst(\u0026#34;b \u0026#34; + func_exit_label_name(context.func)); } else { auto *retValue = retInst-\u0026gt;get_operand(0); if(retValue-\u0026gt;get_type()-\u0026gt;is_float_type()) { load_to_freg(retValue, FReg::fa(0)); } else if(retValue-\u0026gt;get_type()-\u0026gt;is_integer_type()) { load_to_greg(retValue, Reg::a(0)); } else { assert(false); } append_inst(\u0026#34;b \u0026#34; + func_exit_label_name(context.func)); // gen_epilogue(); } } void CodeGen::gen_br() { //BranchInst(Value *cond, BasicBlock *if_true, BasicBlock *if_false,BasicBlock *bb); auto *branchInst = static_cast\u0026lt;BranchInst *\u0026gt;(context.inst); if (branchInst-\u0026gt;is_cond_br()) { // TODO è¡¥å…¨æ¡ä»¶è·³è½¬çš„æƒ…å†µ // throw not_implemented_error{__FUNCTION__}; auto *truebb = static_cast\u0026lt;BasicBlock *\u0026gt;(branchInst-\u0026gt;get_operand(1)); auto *falsebb = static_cast\u0026lt;BasicBlock *\u0026gt;(branchInst-\u0026gt;get_operand(2)); auto *cond = branchInst-\u0026gt;get_condition(); if (cond-\u0026gt;get_type()-\u0026gt;is_float_type()) { load_to_freg(cond, FReg::ft(0)); load_float_imm(0.0, FReg::ft(1)); append_inst(\u0026#34;fcmp.seq.s $fcc0, $ft0, $ft1\u0026#34;); //è¿™å¥æ¯”è¾ƒå¦‚æœcond == 0,åˆ™fcc0 = 1,cond == 1,åˆ™fcc0 = 0 append_inst(\u0026#34;bceqz $fcc0, \u0026#34; + label_name(truebb)); //åˆ¤æ–­fcc0æ˜¯å¦ä¸º0ï¼Œä¸º0åˆ™è·³è½¬åˆ°truebb append_inst(\u0026#34;b \u0026#34; + label_name(falsebb)); } else { load_to_greg(cond, Reg::t(1)); append_inst(\u0026#34;beq $t1, $zero, \u0026#34; + label_name(falsebb)); append_inst(\u0026#34;b \u0026#34; + label_name(truebb)); } } else { auto *branchbb = static_cast\u0026lt;BasicBlock *\u0026gt;(branchInst-\u0026gt;get_operand(0)); append_inst(\u0026#34;b \u0026#34; + label_name(branchbb)); } } void CodeGen::gen_binary() { //Instruction(Type *ty, OpID id, BasicBlock *parent = nullptr); //IBinaryInst(OpID id, Value *v1, Value *v2, BasicBlock *bb); load_to_greg(context.inst-\u0026gt;get_operand(0), Reg::t(0)); load_to_greg(context.inst-\u0026gt;get_operand(1), Reg::t(1)); switch (context.inst-\u0026gt;get_instr_type()) { case Instruction::add: output.emplace_back(\u0026#34;add.w $t2, $t0, $t1\u0026#34;); break; case Instruction::sub: output.emplace_back(\u0026#34;sub.w $t2, $t0, $t1\u0026#34;); break; case Instruction::mul: output.emplace_back(\u0026#34;mul.w $t2, $t0, $t1\u0026#34;); break; case Instruction::sdiv: output.emplace_back(\u0026#34;div.w $t2, $t0, $t1\u0026#34;); break; default: assert(false); } store_from_greg(context.inst, Reg::t(2)); } void CodeGen::gen_float_binary() { // TODO æµ®ç‚¹ç±»å‹çš„äºŒå…ƒæŒ‡ä»¤ // throw not_implemented_error{__FUNCTION__}; load_to_freg(context.inst-\u0026gt;get_operand(0), FReg::ft(0)); load_to_freg(context.inst-\u0026gt;get_operand(1), FReg::ft(1)); switch (context.inst-\u0026gt;get_instr_type()) { case Instruction::fadd: output.emplace_back(\u0026#34;fadd.s $ft2, $ft0, $ft1\u0026#34;); break; case Instruction::fsub: output.emplace_back(\u0026#34;fsub.s $ft2, $ft0, $ft1\u0026#34;); break; case Instruction::fmul: output.emplace_back(\u0026#34;fmul.s $ft2, $ft0, $ft1\u0026#34;); break; case Instruction::fdiv: output.emplace_back(\u0026#34;fdiv.s $ft2, $ft0, $ft1\u0026#34;); break; default: assert(false); } store_from_freg(context.inst, FReg::ft(2)); } void CodeGen::gen_alloca() { /* æˆ‘ä»¬å·²ç»ä¸º alloca çš„å†…å®¹åˆ†é…ç©ºé—´ï¼Œåœ¨æ­¤æˆ‘ä»¬è¿˜éœ€ä¿å­˜ alloca * æŒ‡ä»¤è‡ªèº«äº§ç”Ÿçš„å®šå€¼ï¼Œå³æŒ‡å‘ alloca ç©ºé—´èµ·å§‹åœ°å€çš„æŒ‡é’ˆ */ // TODO å°† alloca å‡ºç©ºé—´çš„èµ·å§‹åœ°å€ä¿å­˜åœ¨æ ˆå¸§ä¸Š // throw not_implemented_error{__FUNCTION__}; //AllocaInst(Type *ty, BasicBlock *bb); auto *allocaInst = static_cast\u0026lt;AllocaInst *\u0026gt;(context.inst); auto *allocaType = allocaInst-\u0026gt;get_alloca_type(); auto offset = context.offset_map.at(allocaInst); LOG(DEBUG) \u0026lt;\u0026lt; \u0026#34;alloca offset: \u0026#34; \u0026lt;\u0026lt; allocaType-\u0026gt;get_size(); auto new_offset_sub = int(allocaType-\u0026gt;get_size()); auto new_offset = offset - new_offset_sub; if (IS_IMM_12(new_offset)) { append_inst(\u0026#34;addi.d\u0026#34;, {Reg::t(0).print(), \u0026#34;$fp\u0026#34;, std::to_string(new_offset)}); //ç”¨t0å­˜å‚¨allocaåçš„åœ°å€ } else { load_large_int64(new_offset, Reg::t(0)); append_inst(\u0026#34;add.d\u0026#34;, {Reg::t(0).print(), \u0026#34;$fp\u0026#34;, Reg::t(0).print()}); } append_inst(\u0026#34;st.d\u0026#34;, {Reg::t(0).print(), \u0026#34;$fp\u0026#34;, std::to_string(offset)}); //å°†allocaåçš„åœ°å€å­˜å‚¨åˆ°æ ˆå¸§ä¸Š } void CodeGen::gen_load() { /* %op2 = load i32, i32* %op1 */ //get_operandå‡½æ•°åªæœ‰0ï¼Œè¿”å›valueç±»å‹çš„*%op1 // auto *ptr = context.inst-\u0026gt;get_operand(0); //ptræ˜¯è¦åŠ è½½çš„åœ°å€ auto *type = context.inst-\u0026gt;get_type(); //ä¸Šé¢çš„ä¾‹å­ä¸­æ˜¯i32 load_to_greg(context.inst-\u0026gt;get_operand(0), Reg::t(0)); //å°†ptrçš„å€¼åŠ è½½åˆ°t0ä¸­ï¼Œä¹Ÿå°±æ˜¯t0å­˜å‚¨äº†è¦åŠ è½½çš„åœ°å€ if (type-\u0026gt;is_float_type()) { append_inst(\u0026#34;fld.s $ft0, $t0, 0\u0026#34;); //ä»t0æŒ‡å‘çš„åœ°å€ä¸­å–å€¼åŠ è½½åˆ°ft0ä¸­ store_from_freg(context.inst, FReg::ft(0)); //å°†ft0çš„å€¼å­˜å‚¨åˆ°context.instä¸­ï¼Œå…¶å®ä¹Ÿå°±æ˜¯èµ‹ç»™äº†å·¦å€¼ } else { // TODO load æ•´æ•°ç±»å‹çš„æ•°æ® // throw not_implemented_error{__FUNCTION__}; if (type-\u0026gt;is_int1_type()) { append_inst(\u0026#34;ld.b\u0026#34;, {Reg::t(0).print(), Reg::t(0).print(), \u0026#34;0\u0026#34;}); } else if (type-\u0026gt;is_int32_type()) { append_inst(\u0026#34;ld.w\u0026#34;, {Reg::t(0).print(), Reg::t(0).print(), \u0026#34;0\u0026#34;}); } else { append_inst(\u0026#34;ld.d\u0026#34;, {Reg::t(0).print(), Reg::t(0).print(), \u0026#34;0\u0026#34;}); } store_from_greg(context.inst, Reg::t(0)); } } void CodeGen::gen_store() { // TODO ç¿»è¯‘ store æŒ‡ä»¤ // throw not_implemented_error{__FUNCTION__}; /* store float 0x40091eb860000000, float* %op0 */ // auto *ptr = context.inst-\u0026gt;get_operand(1); //StoreInst(Value *val, Value *ptr, BasicBlock *bb); auto *type = context.inst-\u0026gt;get_operand(0)-\u0026gt;get_type(); //å’Œloadæ˜¯åçš„ï¼Œ0æ˜¯è¦å­˜å‚¨çš„å€¼ï¼Œ1æ˜¯åœ°å€ load_to_greg(context.inst-\u0026gt;get_operand(1), Reg::t(0)); if (type-\u0026gt;is_float_type()) { load_to_freg(context.inst-\u0026gt;get_operand(0), FReg::ft(0)); //æŠŠè¦å­˜å‚¨çš„å€¼åŠ è½½åˆ°ft0ä¸­ append_inst(\u0026#34;fst.s $ft0, $t0, 0\u0026#34;); //å°†ft0ä¸­çš„å€¼å†™å…¥å†…å­˜t0æŒ‡å‘çš„åœ°å€ } else { load_to_greg(context.inst-\u0026gt;get_operand(0), Reg::t(1)); if (type-\u0026gt;is_int1_type()) { append_inst(\u0026#34;st.b\u0026#34;, {Reg::t(1).print(), Reg::t(0).print(), \u0026#34;0\u0026#34;}); } else if (type-\u0026gt;is_int32_type()) { append_inst(\u0026#34;st.w\u0026#34;, {Reg::t(1).print(), Reg::t(0).print(), \u0026#34;0\u0026#34;}); } else { append_inst(\u0026#34;st.d\u0026#34;, {Reg::t(1).print(), Reg::t(0).print(), \u0026#34;0\u0026#34;}); } } } void CodeGen::gen_icmp() { // TODO å¤„ç†å„ç§æ•´æ•°æ¯”è¾ƒçš„æƒ…å†µ // throw not_implemented_error{__FUNCTION__}; /* %op0 = icmp sgt i32 5, 1 */ auto *icmpInst = static_cast\u0026lt;ICmpInst *\u0026gt;(context.inst); //ICmpInst(OpID id, Value *lhs, Value *rhs, BasicBlock *bb); // auto *op1 = icmpInst-\u0026gt;get_operand(0); //è·å¾—ç¬¬ä¸€ä¸ªvalueç±»å‹çš„lhs // auto *op2 = icmpInst-\u0026gt;get_operand(1); //è·å¾—ç¬¬äºŒä¸ªvalueç±»å‹çš„rhs load_to_greg(icmpInst-\u0026gt;get_operand(0), Reg::t(0)); load_to_greg(icmpInst-\u0026gt;get_operand(1), Reg::t(1)); switch (icmpInst-\u0026gt;get_instr_type()) { case ICmpInst::lt: //åˆ¤æ–­t0æ˜¯å¦å°äºt1 output.emplace_back(\u0026#34;slt $t2, $t0, $t1\u0026#34;); break; case ICmpInst::eq: //åˆ¤æ–­t0å’Œt1æ˜¯å¦ç›¸ç­‰ append_inst(\u0026#34;xor\u0026#34;, {\u0026#34;$t2\u0026#34;, \u0026#34;$t0\u0026#34;, \u0026#34;$t1\u0026#34;}); append_inst(\u0026#34;sltu\u0026#34;, {\u0026#34;$t2\u0026#34;, \u0026#34;$zero\u0026#34;, \u0026#34;$t2\u0026#34;}); append_inst(\u0026#34;xori\u0026#34;, {\u0026#34;$t2\u0026#34;, \u0026#34;$t2\u0026#34;, \u0026#34;1\u0026#34;}); // å…ˆå¼‚æˆ–ï¼Œå¦‚æœ t0 å’Œ t1 ç›¸ç­‰ï¼Œç»“æœä¸º 0ï¼Œå¦åˆ™ä¸ºéé›¶ // ç„¶åä½¿ç”¨ sltu åˆ¤æ–­ç»“æœæ˜¯å¦ä¸ºé›¶ï¼Œæœ€åå–å break; case ICmpInst::ne: append_inst(\u0026#34;xor\u0026#34;, {\u0026#34;$t2\u0026#34;, \u0026#34;$t0\u0026#34;, \u0026#34;$t1\u0026#34;}); append_inst(\u0026#34;sltu\u0026#34;, {\u0026#34;$t2\u0026#34;, \u0026#34;$zero\u0026#34;, \u0026#34;$t2\u0026#34;}); //åˆ¤æ–­t0å’Œt1æ˜¯å¦ä¸ç›¸ç­‰ï¼Œå…ˆå¼‚æˆ–ï¼Œå†åˆ¤æ–­æ˜¯å¦å¤§äº0ï¼Œç”¨æ— ç¬¦å·æ•°æ¯”è¾ƒï¼Œ //å¦‚æœt0å’Œt1ä¸ç›¸ç­‰ï¼Œé‚£ä¹ˆt2ä¼šæ˜¯ä¸€ä¸ªæ­£æ•°ï¼Œæ­¤æ—¶ä¸€å®šæ¯”0å¤§ï¼Œæ‰€ä»¥sltåä¸º1 break; case ICmpInst::le: append_inst(\u0026#34;slt\u0026#34;, {\u0026#34;$t2\u0026#34;, \u0026#34;$t1\u0026#34;, \u0026#34;$t0\u0026#34;}); append_inst(\u0026#34;xori\u0026#34;, {\u0026#34;$t2\u0026#34;, \u0026#34;$t2\u0026#34;, \u0026#34;1\u0026#34;}); //åˆ¤æ–­t0æ˜¯å¦å°äºç­‰äºt1ï¼Œå…ˆåˆ¤æ–­t1æ˜¯å¦å°äºt0ï¼Œå¦‚æœæ˜¯ï¼Œé‚£ä¹ˆt2ä¸º1ï¼Œå¦åˆ™ä¸º0 //ç„¶åå°†t2å–åï¼Œå¦‚æœt0å°äºç­‰äºt1ï¼Œé‚£ä¹ˆt2ä¸º1ï¼Œå¦åˆ™ä¸º0 break; case ICmpInst::gt: output.emplace_back(\u0026#34;slt $t2, $t1, $t0\u0026#34;); break; case ICmpInst::ge: output.emplace_back(\u0026#34;slt $t2, $t0, $t1\u0026#34;); output.emplace_back(\u0026#34;xori $t2, $t2, 1\u0026#34;); break; default: assert(false); } store_from_greg(context.inst, Reg::t(2)); //å°†æ¯”è¾ƒçš„ç»“æœå­˜å‚¨åˆ°context.instä¸­ï¼Œå³èµ‹ç»™å·¦å€¼ } void CodeGen::gen_fcmp() { // TODO å¤„ç†å„ç§æµ®ç‚¹æ•°æ¯”è¾ƒçš„æƒ…å†µ // throw not_implemented_error{__FUNCTION__}; //FCmpInst(OpID id, Value *lhs, Value *rhs, BasicBlock *bb); auto *fcmpInst = static_cast\u0026lt;FCmpInst *\u0026gt;(context.inst); // auto *op1 = fcmpInst-\u0026gt;get_operand(0); // auto *op2 = fcmpInst-\u0026gt;get_operand(1); load_to_freg(fcmpInst-\u0026gt;get_operand(0), FReg::ft(0)); load_to_freg(fcmpInst-\u0026gt;get_operand(1), FReg::ft(1)); switch (fcmpInst-\u0026gt;get_instr_type()) { case FCmpInst::feq: output.emplace_back(\u0026#34;fcmp.seq.s $fcc0, $ft0, $ft1\u0026#34;); break; case FCmpInst::fne: output.emplace_back(\u0026#34;fcmp.sne.s $fcc0, $ft0, $ft1\u0026#34;); break; case FCmpInst::flt: output.emplace_back(\u0026#34;fcmp.slt.s $fcc0, $ft0, $ft1\u0026#34;); break; case FCmpInst::fle: output.emplace_back(\u0026#34;fcmp.sle.s $fcc0, $ft0, $ft1\u0026#34;); break; case FCmpInst::fgt: output.emplace_back(\u0026#34;fcmp.sgt.s $fcc0, $ft0, $ft1\u0026#34;); break; case FCmpInst::fge: output.emplace_back(\u0026#34;fcmp.sge.s $fcc0, $ft0, $ft1\u0026#34;); break; default: assert(false); } append_inst(\u0026#34;bcnez\u0026#34;,{\u0026#34;$fcc0\u0026#34;,fcmp_label_name(context.bb, context.fcmp_cnt)}); //å¦‚æœfcc0ä¸º0ï¼Œè·³è½¬å­˜0,å¦åˆ™ä¸è·³è½¬å­˜1 load_float_imm(1.0,FReg::ft(2)); store_from_freg(context.inst,FReg::ft(2)); append_inst(\u0026#34;b\u0026#34;, {fcmp_label_name(context.bb, context.fcmp_cnt + 1)}); append_inst(fcmp_label_name(context.bb, context.fcmp_cnt),ASMInstruction::Label); load_float_imm(0.0, FReg::ft(2)); store_from_freg(context.inst, FReg::ft(2)); append_inst(fcmp_label_name(context.bb, context.fcmp_cnt + 1),ASMInstruction::Label); context.fcmp_cnt += 2; } void CodeGen::gen_zext() { // TODO å°†çª„ä½å®½çš„æ•´æ•°æ•°æ®è¿›è¡Œé›¶æ‰©å±• // throw not_implemented_error{__FUNCTION__}; //ZextInst(Value *val, Type *ty, BasicBlock *bb); /* %op1 = zext i1 %op0 to i32 */ auto zextInst = static_cast\u0026lt;ZextInst *\u0026gt;(context.inst); auto *val = zextInst-\u0026gt;get_operand(0); load_to_greg(val, Reg::t(0)); //å°†valçš„å€¼åŠ è½½åˆ°t0ä¸­ store_from_greg(context.inst, Reg::t(0)); } void CodeGen::gen_call() { // TODO å‡½æ•°è°ƒç”¨ï¼Œæ³¨æ„æˆ‘ä»¬åªéœ€è¦é€šè¿‡å¯„å­˜å™¨ä¼ é€’å‚æ•°ï¼Œå³ä¸éœ€è€ƒè™‘æ ˆä¸Šä¼ å‚çš„æƒ…å†µ // throw not_implemented_error{__FUNCTION__}; //CallInst(Function *func, std::vector\u0026lt;Value *\u0026gt; args, BasicBlock *bb); /* %op0 = call i32 @callee(i32 110) */ auto *callInst = static_cast\u0026lt;CallInst *\u0026gt;(context.inst); int garg_cnt = 0; int farg_cnt = 0; for(auto \u0026amp;arg : callInst-\u0026gt;get_operands()) { LOG(DEBUG)\u0026lt;\u0026lt;\u0026#34;arg type is \u0026#34;\u0026lt;\u0026lt;arg-\u0026gt;get_type()-\u0026gt;print(); if(arg-\u0026gt;get_type()-\u0026gt;is_float_type()) { load_to_freg(arg, FReg::fa(farg_cnt)); farg_cnt++; } else if(arg-\u0026gt;get_type()-\u0026gt;is_integer_type()) { LOG(DEBUG)\u0026lt;\u0026lt;\u0026#34;here is integer type\u0026#34;; load_to_greg(arg, Reg::a(garg_cnt)); garg_cnt++; } else if(arg-\u0026gt;get_type()-\u0026gt;is_pointer_type()) { load_to_greg(arg, Reg::a(garg_cnt)); garg_cnt++; } else if(arg-\u0026gt;get_type()-\u0026gt;is_void_type()){ break; } // else { // assert(false); // } } //å°†å‚æ•°ä¼ å…¥å¯„å­˜å™¨ assert(context.func \u0026amp;\u0026amp; \u0026#34;context.func is null\u0026#34;); auto *current_func = static_cast\u0026lt;Function*\u0026gt;(callInst-\u0026gt;get_operand(0)); // context.func = current_func; append_inst(\u0026#34;bl\u0026#34;,{current_func-\u0026gt;get_name()}); //è°ƒç”¨å‡½æ•° // std::cout\u0026lt;\u0026lt;\u0026#34;call function_type \u0026#34;\u0026lt;\u0026lt;callInst-\u0026gt;get_function_type()\u0026lt;\u0026lt;std::endl; if(current_func-\u0026gt;get_return_type()-\u0026gt;is_float_type()) { store_from_freg(context.inst, FReg::fa(0)); } else if(current_func-\u0026gt;get_return_type()-\u0026gt;is_int32_type() || current_func-\u0026gt;get_return_type()-\u0026gt;is_int1_type()) { store_from_greg(context.inst, Reg::a(0)); } // if(!current_func-\u0026gt;get_return_type()-\u0026gt;is_void_type()) // { // gen_epilogue(); // } //å°†å‡½æ•°è¿”å›å€¼å­˜å‚¨åˆ°context.instä¸­ // append_inst(\u0026#34;b \u0026#34; + func_exit_label_name(context.func)); //è·³è½¬åˆ°å‡½æ•°é€€å‡ºçš„åœ°æ–¹ } /* * %op = getelementptr [10 x i32], [10 x i32]* %op, i32 0, i32 %op * %op = getelementptr i32, i32* %op, i32 %op * * Memory layout * - ^ * +-----------+ | Smaller address * | arg ptr |---+ | * +-----------+ | | * | | | | * +-----------+ / | * | |\u0026lt;-- | * | | \\ | * | | | | * | Array | | | * | | | | * | | | | * | | | | * +-----------+ | | * | Pointer |---+ | * +-----------+ | * | | | * +-----------+ | * | | | * +-----------+ | * | | | * +-----------+ | Larger address * + */ void CodeGen::gen_gep() { // TODO è®¡ç®—å†…å­˜åœ°å€ // throw not_implemented_error{__FUNCTION__}; //GetElementPtrInst(Value *ptr, std::vector\u0026lt;Value *\u0026gt; idxs, BasicBlock *bb); /* %op1 = getelementptr [10 x i32], [10 x i32]* %op0, i32 0, i32 0 */ //* %op = getelementptr i32, i32* %op, i32 %op auto *gepInst = static_cast\u0026lt;GetElementPtrInst *\u0026gt;(context.inst); auto *ptr = gepInst-\u0026gt;get_operand(0); load_to_greg(ptr, Reg::t(3)); // if() // { // } int i = 0; for(auto \u0026amp;idx : gepInst-\u0026gt;get_operands()) { if(i == 2||i == 1) { load_to_greg(idx, Reg::t(1)); append_inst(\u0026#34;addi.w\u0026#34;,{\u0026#34;$t4\u0026#34;, \u0026#34;$zero\u0026#34;, \u0026#34;4\u0026#34;}); append_inst(\u0026#34;mul.w\u0026#34;,{\u0026#34;$t2\u0026#34;, \u0026#34;$t1\u0026#34;, \u0026#34;$t4\u0026#34;}); //å°†idxçš„å€¼ä¹˜ä»¥4 append_inst(\u0026#34;add.d\u0026#34;, {\u0026#34;$t3\u0026#34;, \u0026#34;$t2\u0026#34;, \u0026#34;$t3\u0026#34;}); //å°†ptrçš„å€¼åŠ ä¸Šidxçš„å€¼ï¼Œæ­¤æ—¶t3ä¸­å­˜å‚¨çš„æ˜¯ptr+idxçš„å€¼ } else { i++; } } store_from_greg(context.inst, Reg::t(3)); } void CodeGen::gen_sitofp() { // TODO æ•´æ•°è½¬å‘æµ®ç‚¹æ•° // throw not_implemented_error{__FUNCTION__}; //SiToFpInst(Value *val, Type *ty, BasicBlock *bb); auto sitofpInst = static_cast\u0026lt;SiToFpInst *\u0026gt;(context.inst); // auto *val = sitofpInst-\u0026gt;get_operand(0); load_to_greg(sitofpInst-\u0026gt;get_operand(0), Reg::t(0)); append_inst(\u0026#34;movgr2fr.w\u0026#34;,{FReg::ft(0).print(), Reg::t(0).print()}); append_inst(\u0026#34;ffint.s.w\u0026#34;,{FReg::ft(1).print(), FReg::ft(0).print()}); store_from_freg(context.inst, FReg::ft(1)); } void CodeGen::gen_fptosi() { // TODO æµ®ç‚¹æ•°è½¬å‘æ•´æ•°ï¼Œæ³¨æ„å‘ä¸‹å–æ•´(round to zero) // throw not_implemented_error{__FUNCTION__}; //%op2 = fptosi float %op1 to i32 //FpToSiInst(Value *val, Type *ty, BasicBlock *bb); auto fptosiInst = static_cast\u0026lt;FpToSiInst *\u0026gt;(context.inst); // auto *val = fptosiInst-\u0026gt;get_operand(0); load_to_freg(fptosiInst-\u0026gt;get_operand(0), FReg::ft(0)); append_inst(\u0026#34;ftintrz.w.s\u0026#34;,{FReg::ft(1).print(), FReg::ft(0).print()}); append_inst(\u0026#34;movfr2gr.s\u0026#34;,{Reg::t(0).print(), FReg::ft(1).print()}); store_from_greg(context.inst, Reg::t(0)); } void CodeGen::run() { // ç¡®ä¿æ¯ä¸ªå‡½æ•°ä¸­åŸºæœ¬å—çš„åå­—éƒ½è¢«è®¾ç½®å¥½ m-\u0026gt;set_print_name(); /* ä½¿ç”¨ GNU ä¼ªæŒ‡ä»¤ä¸ºå…¨å±€å˜é‡åˆ†é…ç©ºé—´ * ä½ å¯ä»¥ä½¿ç”¨ `la.local` æŒ‡ä»¤å°†æ ‡ç­¾ (å…¨å±€å˜é‡) çš„åœ°å€è½½å…¥å¯„å­˜å™¨ä¸­, æ¯”å¦‚ * è¦å°† `a` çš„åœ°å€è½½å…¥ $t0, åªéœ€è¦ `la.local $t0, a` */ if (!m-\u0026gt;get_global_variable().empty()) { append_inst(\u0026#34;Global variables\u0026#34;, ASMInstruction::Comment); /* è™½ç„¶ä¸‹é¢ä¸¤æ¡ä¼ªæŒ‡ä»¤å¯ä»¥ç®€åŒ–ä¸ºä¸€æ¡ `.bss` ä¼ªæŒ‡ä»¤, ä½†æ˜¯æˆ‘ä»¬è¿˜æ˜¯é€‰æ‹©ä½¿ç”¨ * `.section` å°†å…¨å±€å˜é‡æ”¾åˆ°å¯æ‰§è¡Œæ–‡ä»¶çš„ BSS æ®µ, åŸå› å¦‚ä¸‹: * - å°½å¯èƒ½å¯¹é½äº¤å‰ç¼–è¯‘å™¨ loongarch64-unknown-linux-gnu-gcc çš„è¡Œä¸º * - æ”¯æŒæ›´æ—§ç‰ˆæœ¬çš„ GNU æ±‡ç¼–å™¨, å› ä¸º `.bss` ä¼ªæŒ‡ä»¤æ˜¯åº”è¯¥ç›¸å¯¹è¾ƒæ–°çš„æŒ‡ä»¤, * GNU æ±‡ç¼–å™¨åœ¨ 2023 å¹´ 2 æœˆçš„ 2.37 ç‰ˆæœ¬æ‰å°†å…¶å¼•å…¥ */ append_inst(\u0026#34;.text\u0026#34;, ASMInstruction::Atrribute); append_inst(\u0026#34;.section\u0026#34;, {\u0026#34;.bss\u0026#34;, \u0026#34;\\\u0026#34;aw\\\u0026#34;\u0026#34;, \u0026#34;@nobits\u0026#34;}, ASMInstruction::Atrribute); for (auto \u0026amp;global : m-\u0026gt;get_global_variable()) { auto size = global.get_type()-\u0026gt;get_pointer_element_type()-\u0026gt;get_size(); append_inst(\u0026#34;.globl\u0026#34;, {global.get_name()}, ASMInstruction::Atrribute); append_inst(\u0026#34;.type\u0026#34;, {global.get_name(), \u0026#34;@object\u0026#34;}, ASMInstruction::Atrribute); append_inst(\u0026#34;.size\u0026#34;, {global.get_name(), std::to_string(size)}, ASMInstruction::Atrribute); append_inst(global.get_name(), ASMInstruction::Label); append_inst(\u0026#34;.space\u0026#34;, {std::to_string(size)}, ASMInstruction::Atrribute); } } // å‡½æ•°ä»£ç æ®µ output.emplace_back(\u0026#34;.text\u0026#34;, ASMInstruction::Atrribute); for (auto \u0026amp;func : m-\u0026gt;get_functions()) { if (not func.is_declaration()) { // æ›´æ–° context context.clear(); context.func = \u0026amp;func; // å‡½æ•°ä¿¡æ¯ append_inst(\u0026#34;.globl\u0026#34;, {func.get_name()}, ASMInstruction::Atrribute); append_inst(\u0026#34;.type\u0026#34;, {func.get_name(), \u0026#34;@function\u0026#34;}, ASMInstruction::Atrribute); append_inst(func.get_name(), ASMInstruction::Label); // åˆ†é…å‡½æ•°æ ˆå¸§ allocate(); // ç”Ÿæˆ prologue gen_prologue(); for (auto \u0026amp;bb : func.get_basic_blocks()) { context.bb = \u0026amp;bb; append_inst(label_name(context.bb), ASMInstruction::Label); for (auto \u0026amp;instr : bb.get_instructions()) { // For debug append_inst(instr.print(), ASMInstruction::Comment); context.inst = \u0026amp;instr; // æ›´æ–° context switch (instr.get_instr_type()) { case Instruction::ret: gen_ret(); break; case Instruction::br: copy_stmt(); gen_br(); break; case Instruction::add: case Instruction::sub: case Instruction::mul: case Instruction::sdiv: gen_binary(); break; case Instruction::fadd: case Instruction::fsub: case Instruction::fmul: case Instruction::fdiv: gen_float_binary(); break; case Instruction::alloca: /* å¯¹äº alloca æŒ‡ä»¤ï¼Œæˆ‘ä»¬å·²ç»ä¸º alloca * çš„å†…å®¹åˆ†é…ç©ºé—´ï¼Œåœ¨æ­¤æˆ‘ä»¬è¿˜éœ€ä¿å­˜ alloca * æŒ‡ä»¤è‡ªèº«äº§ç”Ÿçš„å®šå€¼ï¼Œå³æŒ‡å‘ alloca ç©ºé—´èµ·å§‹åœ°å€çš„æŒ‡é’ˆ */ gen_alloca(); break; case Instruction::load: gen_load(); break; case Instruction::store: gen_store(); break; case Instruction::ge: case Instruction::gt: case Instruction::le: case Instruction::lt: case Instruction::eq: case Instruction::ne: gen_icmp(); break; case Instruction::fge: case Instruction::fgt: case Instruction::fle: case Instruction::flt: case Instruction::feq: case Instruction::fne: gen_fcmp(); break; case Instruction::phi: /* for phi, just convert to a series of * copy-stmts */ /* we can collect all phi and deal them at * the end */ break; case Instruction::call: gen_call(); break; case Instruction::getelementptr: gen_gep(); break; case Instruction::zext: gen_zext(); break; case Instruction::fptosi: gen_fptosi(); break; case Instruction::sitofp: gen_sitofp(); break; } } } // ç”Ÿæˆ epilogue gen_epilogue(); } } } std::string CodeGen::print() const { std::string result; for (const auto \u0026amp;inst : output) { result += inst.format(); } return result; } ä¼˜åŒ–å¤„ç†\rMEM2REG\råˆ›å»ºæ”¯é…æ ‘ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 #include \u0026#34;Dominators.hpp\u0026#34; #include \u0026#34;Function.hpp\u0026#34; #include \u0026lt;fstream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026#34;BasicBlock.hpp\u0026#34; #include \u0026#34;logging.hpp\u0026#34; /** * @brief æ”¯é…å™¨åˆ†æçš„å…¥å£å‡½æ•° * * éå†æ¨¡å—ä¸­çš„æ‰€æœ‰å‡½æ•°ï¼Œå¯¹æ¯ä¸ªéå£°æ˜çš„å‡½æ•°æ‰§è¡Œæ”¯é…å…³ç³»åˆ†æã€‚ */ void Dominators::run() { for(auto \u0026amp;f1 : m_-\u0026gt;get_functions()) { auto f = \u0026amp;f1; if(f-\u0026gt;is_declaration()) continue; run_on_func(f); } } /** * @brief å¯¹å•ä¸ªå‡½æ•°æ‰§è¡Œæ”¯é…å…³ç³»åˆ†æ * @param f è¦åˆ†æçš„å‡½æ•° * * è¯¥å‡½æ•°æ‰§è¡Œå®Œæ•´çš„æ”¯é…å…³ç³»åˆ†ææµç¨‹ï¼š * 1. åˆå§‹åŒ–æ•°æ®ç»“æ„ * 2. åˆ›å»ºåå‘ååºéå†åºåˆ— * 3. è®¡ç®—ç›´æ¥æ”¯é…è€…(idom) * 4. è®¡ç®—æ”¯é…è¾¹ç•Œ * 5. æ„å»ºæ”¯é…æ ‘çš„åç»§å…³ç³» * 6. åˆ›å»ºæ”¯é…æ ‘çš„DFSåº */ void Dominators::run_on_func(Function *f) { dom_post_order_.clear(); dom_dfs_order_.clear(); for(auto \u0026amp;bb1 : f-\u0026gt;get_basic_blocks()) { auto bb = \u0026amp;bb1; idom_.insert({bb, nullptr}); dom_frontier_.insert({bb, {}}); dom_tree_succ_blocks_.insert({bb, {}}); } create_reverse_post_order(f); create_idom(f); create_dominance_frontier(f); create_dom_tree_succ(f); create_dom_dfs_order(f); // LOG(INFO)\u0026lt;\u0026lt;m_-\u0026gt;print(); // dump_dominator_tree(f); // dump_cfg(f); } /** * @brief è®¡ç®—ä¸¤ä¸ªåŸºæœ¬å—çš„æ”¯é…å…³ç³»äº¤é›† * @param b1 ç¬¬ä¸€ä¸ªåŸºæœ¬å— * @param b2 ç¬¬äºŒä¸ªåŸºæœ¬å— * @return è¿”å›åœ¨æ”¯é…æ ‘ä¸Šæœ€æ·±çš„åŒæ—¶æ”¯é…b1å’Œb2çš„èŠ‚ç‚¹ * * è¯¥å‡½æ•°ä½¿ç”¨ååºå·æ¥æŸ¥æ‰¾ä¸¤ä¸ªèŠ‚ç‚¹çš„æœ€è¿‘å…¬å…±æ”¯é…è€…ã€‚ * é€šè¿‡åœ¨æ”¯é…æ ‘ä¸Šå‘ä¸Šéå†ç›´åˆ°æ‰¾åˆ°äº¤ç‚¹ã€‚ */ BasicBlock *Dominators::intersect(BasicBlock *b1, BasicBlock *b2) { while (b1 != b2) { while (get_post_order(b1) \u0026lt; get_post_order(b2)) { b1 = get_idom(b1); } while (get_post_order(b2) \u0026lt; get_post_order(b1)) { b2 = get_idom(b2); } } return b1; } /** * @brief åˆ›å»ºå‡½æ•°çš„åå‘ååºéå†åºåˆ— * @param f è¦å¤„ç†çš„å‡½æ•° * * é€šè¿‡DFSéå†CFGæ¥æ„å»ºåŸºæœ¬å—çš„ååºéå†åºåˆ—ã€‚ * è¿™ä¸ªåºåˆ—ç”¨äºåç»­çš„æ”¯é…å…³ç³»åˆ†æã€‚ */ void Dominators::create_reverse_post_order(Function *f) { BBSet visited; dfs(f-\u0026gt;get_entry_block(), visited); } /** * @brief æ·±åº¦ä¼˜å…ˆæœç´¢è¾…åŠ©å‡½æ•° * @param bb å½“å‰éå†çš„åŸºæœ¬å— * @param visited å·²è®¿é—®çš„åŸºæœ¬å—é›†åˆ * * æ‰§è¡ŒDFSéå†ï¼Œç»´æŠ¤ååºéå†åºåˆ—å’Œæ¯ä¸ªåŸºæœ¬å—çš„ååºå·ã€‚ */ void Dominators::dfs(BasicBlock *bb, std::set\u0026lt;BasicBlock *\u0026gt; \u0026amp;visited) { visited.insert(bb); for (auto \u0026amp;succ : bb-\u0026gt;get_succ_basic_blocks()) { if (visited.find(succ) == visited.end()) { dfs(succ, visited); } } post_order_vec_.push_back(bb); post_order_.insert({bb, post_order_.size()}); } /** * @brief è®¡ç®—æ‰€æœ‰åŸºæœ¬å—çš„ç›´æ¥æ”¯é…è€…(immediate dominator) * @param f è¦åˆ†æçš„å‡½æ•° * * ä½¿ç”¨è¿­ä»£ç®—æ³•è®¡ç®—æ¯ä¸ªåŸºæœ¬å—çš„ç›´æ¥æ”¯é…è€…ï¼š * 1. å°†å…¥å£å—çš„ç›´æ¥æ”¯é…è€…è®¾ç½®ä¸ºè‡ªèº« * 2. é‡å¤éå†æ‰€æœ‰åŸºæœ¬å—ï¼Œæ›´æ–°å®ƒä»¬çš„ç›´æ¥æ”¯é…è€… * 3. å½“æ²¡æœ‰å˜åŒ–æ—¶ç®—æ³•ç»ˆæ­¢ */ void Dominators::create_idom(Function *f) { BasicBlock *entry = f-\u0026gt;get_entry_block(); idom_[entry] = entry; // LOG(INFO)\u0026lt;\u0026lt;\u0026#34;idom_[entry]:\u0026#34;\u0026lt;\u0026lt;idom_[entry]-\u0026gt;get_name(); bool changed = true; while (changed) { changed = false; for (auto rev_it = post_order_vec_.rbegin(); rev_it != post_order_vec_.rend(); ++rev_it) { auto bb = *rev_it; if(bb == entry || bb == nullptr) { continue; } auto pre_blocks = bb-\u0026gt;get_pre_basic_blocks(); if(pre_blocks.size() == 0) { continue; } auto new_idom = *pre_blocks.begin(); for (auto pred : bb-\u0026gt;get_pre_basic_blocks()) { if (idom_[pred] != nullptr \u0026amp;\u0026amp; idom_.find(pred) != idom_.end()) { new_idom = intersect(new_idom, pred); } } if (idom_[bb] != new_idom) { idom_[bb] = new_idom; changed = true; } } } } /** * @brief è®¡ç®—æ‰€æœ‰åŸºæœ¬å—çš„æ”¯é…è¾¹ç•Œ(dominance frontier) * @param f è¦åˆ†æçš„å‡½æ•° * * å¯¹äºæ¯ä¸ªæœ‰å¤šä¸ªå‰é©±çš„åŸºæœ¬å—Bï¼š * ä»æ¯ä¸ªå‰é©±På¼€å§‹ï¼Œæ²¿ç€æ”¯é…æ ‘å‘ä¸Šéå†ç›´åˆ°é‡åˆ°Bçš„ç›´æ¥æ”¯é…è€…ï¼Œ * å°†BåŠ å…¥è·¯å¾„ä¸Šæ‰€æœ‰èŠ‚ç‚¹çš„æ”¯é…è¾¹ç•Œä¸­ã€‚ */ void Dominators::create_dominance_frontier(Function *f) { for(auto \u0026amp;block : f-\u0026gt;get_basic_blocks()) { if(block.get_pre_basic_blocks().size() \u0026gt;= 2) { for(auto pred : block.get_pre_basic_blocks()) { auto runner = pred; while(runner != get_idom(\u0026amp;block) \u0026amp;\u0026amp; runner != nullptr) { dom_frontier_[runner].insert(\u0026amp;block); runner = get_idom(runner); } } } } } /** * @brief æ„å»ºæ”¯é…æ ‘çš„åç»§å…³ç³» * @param f è¦å¤„ç†çš„å‡½æ•° * * åŸºäºå·²è®¡ç®—çš„ç›´æ¥æ”¯é…è€…å…³ç³»ï¼Œæ„å»ºæ”¯é…æ ‘çš„å­èŠ‚ç‚¹å…³ç³»ã€‚ * å¦‚æœAæ˜¯Bçš„ç›´æ¥æ”¯é…è€…ï¼Œåˆ™Bæ˜¯Aåœ¨æ”¯é…æ ‘ä¸Šçš„åç»§ã€‚ */ void Dominators::create_dom_tree_succ(Function *f) { // éå†æ‰€æœ‰åŸºæœ¬å— for (auto \u0026amp;block : f-\u0026gt;get_basic_blocks()) { auto idom = get_idom(\u0026amp;block); if (idom != nullptr \u0026amp;\u0026amp; idom_.find(idom) != idom_.end() \u0026amp;\u0026amp; idom_.at(\u0026amp;block) != \u0026amp;block) { // æ£€æŸ¥ç›´æ¥æ”¯é…è€…æ˜¯å¦å·²ç»åœ¨ dom_tree_succ_blocks_ ä¸­ if (dom_tree_succ_blocks_.find(idom) != dom_tree_succ_blocks_.end()) { dom_tree_succ_blocks_[idom].insert(\u0026amp;block); } else { dom_tree_succ_blocks_[idom] = {\u0026amp;block}; } } } } /** * @brief ä¸ºæ”¯é…æ ‘åˆ›å»ºæ·±åº¦ä¼˜å…ˆæœç´¢åº * @param f è¦å¤„ç†çš„å‡½æ•° * * è¯¥å‡½æ•°é€šè¿‡æ·±åº¦ä¼˜å…ˆæœç´¢éå†æ”¯é…æ ‘ï¼Œä¸ºæ¯ä¸ªåŸºæœ¬å—åˆ†é…ä¸¤ä¸ªåºå·ï¼š * 1. dom_tree_L_ï¼šè®°å½•DFSé¦–æ¬¡è®¿é—®è¯¥èŠ‚ç‚¹çš„æ—¶é—´æˆ³ * 2. dom_tree_R_ï¼šè®°å½•DFSå®Œæˆè®¿é—®è¯¥èŠ‚ç‚¹å­æ ‘çš„æ—¶é—´æˆ³ * * åŒæ—¶ç»´æŠ¤ï¼š * - dom_dfs_order_ï¼šæŒ‰DFSè®¿é—®é¡ºåºè®°å½•åŸºæœ¬å— * - dom_post_order_ï¼šdom_dfs_order_çš„é€†åº * * è¿™äº›åºå·å’Œé¡ºåºå¯ç”¨äºå¿«é€Ÿåˆ¤æ–­æ”¯é…å…³ç³»ï¼š * å¦‚æœèŠ‚ç‚¹Aæ”¯é…èŠ‚ç‚¹Bï¼Œåˆ™Açš„Lå€¼å°äºBçš„Lå€¼ï¼Œä¸”Açš„Rå€¼å¤§äºBçš„Rå€¼ */ void Dominators::create_dom_dfs_order(Function *f) { // åˆ†æå¾—åˆ° f ä¸­å„ä¸ªåŸºæœ¬å—çš„æ”¯é…æ ‘ä¸Šçš„dfsåºL,R unsigned int order = 0; std::function\u0026lt;void(BasicBlock *)\u0026gt; dfs = [\u0026amp;](BasicBlock *bb) { dom_tree_L_[bb] = ++ order; dom_dfs_order_.push_back(bb); for (auto \u0026amp;succ : dom_tree_succ_blocks_[bb]) { dfs(succ); } dom_tree_R_[bb] = order; }; dfs(f-\u0026gt;get_entry_block()); dom_post_order_ = std::vector(dom_dfs_order_.rbegin(), dom_dfs_order_.rend()); } /** * @brief æ‰“å°å‡½æ•°çš„ç›´æ¥æ”¯é…å…³ç³» * @param f è¦æ‰“å°çš„å‡½æ•° * * è¯¥å‡½æ•°ä»¥å¯è¯»æ ¼å¼æ‰“å°å‡½æ•°ä¸­æ‰€æœ‰åŸºæœ¬å—çš„ç›´æ¥æ”¯é…è€…(immediate dominator)ã€‚ * è¾“å‡ºæ ¼å¼ä¸ºï¼š * åŸºæœ¬å—å: å…¶ç›´æ¥æ”¯é…è€…å * å¦‚æœåŸºæœ¬å—æ²¡æœ‰ç›´æ¥æ”¯é…è€…(å¦‚å…¥å£å—)ï¼Œåˆ™æ˜¾ç¤º\u0026#34;null\u0026#34;ã€‚ */ void Dominators::print_idom(Function *f) { f-\u0026gt;get_parent()-\u0026gt;set_print_name(); int counter = 0; std::map\u0026lt;BasicBlock *, std::string\u0026gt; bb_id; for (auto \u0026amp;bb1 : f-\u0026gt;get_basic_blocks()) { auto bb = \u0026amp;bb1; if (bb-\u0026gt;get_name().empty()) bb_id[bb] = \u0026#34;bb\u0026#34; + std::to_string(counter); else bb_id[bb] = bb-\u0026gt;get_name(); counter++; } printf(\u0026#34;Immediate dominance of function %s:\\n\u0026#34;, f-\u0026gt;get_name().c_str()); for (auto \u0026amp;bb1 : f-\u0026gt;get_basic_blocks()) { auto bb = \u0026amp;bb1; std::string output; output = bb_id[bb] + \u0026#34;: \u0026#34;; if (get_idom(bb)) { output += bb_id[get_idom(bb)]; } else { output += \u0026#34;null\u0026#34;; } printf(\u0026#34;%s\\n\u0026#34;, output.c_str()); } } /** * @brief æ‰“å°å‡½æ•°çš„æ”¯é…è¾¹ç•Œä¿¡æ¯ * @param f è¦æ‰“å°çš„å‡½æ•° * * è¯¥å‡½æ•°ä»¥å¯è¯»æ ¼å¼æ‰“å°å‡½æ•°ä¸­æ‰€æœ‰åŸºæœ¬å—çš„æ”¯é…è¾¹ç•Œ(dominance frontier)ã€‚ * è¾“å‡ºæ ¼å¼ä¸ºï¼š * åŸºæœ¬å—å: æ”¯é…è¾¹ç•Œä¸­çš„åŸºæœ¬å—åˆ—è¡¨ * å¦‚æœåŸºæœ¬å—æ²¡æœ‰æ”¯é…è¾¹ç•Œï¼Œåˆ™æ˜¾ç¤º\u0026#34;null\u0026#34;ã€‚ */ void Dominators::print_dominance_frontier(Function *f) { f-\u0026gt;get_parent()-\u0026gt;set_print_name(); int counter = 0; std::map\u0026lt;BasicBlock *, std::string\u0026gt; bb_id; for (auto \u0026amp;bb1 : f-\u0026gt;get_basic_blocks()) { auto bb = \u0026amp;bb1; if (bb-\u0026gt;get_name().empty()) bb_id[bb] = \u0026#34;bb\u0026#34; + std::to_string(counter); else bb_id[bb] = bb-\u0026gt;get_name(); counter++; } printf(\u0026#34;Dominance Frontier of function %s:\\n\u0026#34;, f-\u0026gt;get_name().c_str()); for (auto \u0026amp;bb1 : f-\u0026gt;get_basic_blocks()) { auto bb = \u0026amp;bb1; std::string output; output = bb_id[bb] + \u0026#34;: \u0026#34;; if (get_dominance_frontier(bb).empty()) { output += \u0026#34;null\u0026#34;; } else { bool first = true; for (auto df : get_dominance_frontier(bb)) { if (first) { first = false; } else { output += \u0026#34;, \u0026#34;; } output += bb_id[df]; } } printf(\u0026#34;%s\\n\u0026#34;, output.c_str()); } } /** * @brief å°†å‡½æ•°çš„æ§åˆ¶æµå›¾(CFG)å¯¼å‡ºä¸ºå›¾å½¢æ–‡ä»¶ * @param f è¦å¯¼å‡ºçš„å‡½æ•° * * è¯¥å‡½æ•°ç”Ÿæˆå‡½æ•°çš„æ§åˆ¶æµå›¾çš„DOTæ ¼å¼æè¿°ï¼Œå¹¶ä½¿ç”¨graphvizå°†å…¶è½¬æ¢ä¸ºPNGå›¾åƒã€‚ * ç”Ÿæˆä¸¤ä¸ªæ–‡ä»¶ï¼š * - {å‡½æ•°å}_cfg.dotï¼šDOTæ ¼å¼çš„å›¾å½¢æè¿° * - {å‡½æ•°å}_cfg.pngï¼šå¯è§†åŒ–çš„æ§åˆ¶æµå›¾ */ void Dominators::dump_cfg(Function *f) { f-\u0026gt;get_parent()-\u0026gt;set_print_name(); if(f-\u0026gt;is_declaration()) return; std::vector\u0026lt;std::string\u0026gt; edge_set; bool has_edges = false; for (auto \u0026amp;bb : f-\u0026gt;get_basic_blocks()) { auto succ_blocks = bb.get_succ_basic_blocks(); if(!succ_blocks.empty()) has_edges = true; for (auto succ : succ_blocks) { edge_set.push_back(\u0026#39;\\t\u0026#39; + bb.get_name() + \u0026#34;-\u0026gt;\u0026#34; + succ-\u0026gt;get_name() + \u0026#34;;\\n\u0026#34;); } } std::string digraph = \u0026#34;digraph G {\\n\u0026#34;; if (!has_edges \u0026amp;\u0026amp; !f-\u0026gt;get_basic_blocks().empty()) { // å¦‚æœæ²¡æœ‰è¾¹ä¸”è‡³å°‘æœ‰ä¸€ä¸ªåŸºæœ¬å—ï¼Œæ·»åŠ ä¸€ä¸ªè‡ªç¯ä»¥æ˜¾ç¤ºå”¯ä¸€çš„åŸºæœ¬å— auto \u0026amp;bb = f-\u0026gt;get_basic_blocks().front(); digraph += \u0026#39;\\t\u0026#39; + bb.get_name() + \u0026#34;;\\n\u0026#34;; } else { for (auto \u0026amp;edge : edge_set) { digraph += edge; } } digraph += \u0026#34;}\\n\u0026#34;; std::ofstream file_output; file_output.open(f-\u0026gt;get_name() + \u0026#34;_cfg.dot\u0026#34;, std::ios::out); file_output \u0026lt;\u0026lt; digraph; file_output.close(); std::string dot_cmd = \u0026#34;dot -Tpng \u0026#34; + f-\u0026gt;get_name() + \u0026#34;_cfg.dot\u0026#34; + \u0026#34; -o \u0026#34; + f-\u0026gt;get_name() + \u0026#34;_cfg.png\u0026#34;; std::system(dot_cmd.c_str()); } /** * @brief å°†å‡½æ•°çš„æ”¯é…æ ‘å¯¼å‡ºä¸ºå›¾å½¢æ–‡ä»¶ * @param f è¦å¯¼å‡ºçš„å‡½æ•° * * è¯¥å‡½æ•°ç”Ÿæˆå‡½æ•°çš„æ”¯é…æ ‘çš„DOTæ ¼å¼æè¿°ï¼Œå¹¶ä½¿ç”¨graphvizå°†å…¶è½¬æ¢ä¸ºPNGå›¾åƒã€‚ * ç”Ÿæˆä¸¤ä¸ªæ–‡ä»¶ï¼š * - {å‡½æ•°å}_dom_tree.dotï¼šDOTæ ¼å¼çš„å›¾å½¢æè¿° * - {å‡½æ•°å}_dom_tree.pngï¼šå¯è§†åŒ–çš„æ”¯é…æ ‘ */ void Dominators::dump_dominator_tree(Function *f) { f-\u0026gt;get_parent()-\u0026gt;set_print_name(); if(f-\u0026gt;is_declaration()) return; std::vector\u0026lt;std::string\u0026gt; edge_set; bool has_edges = false; // ç”¨äºæ£€æŸ¥æ˜¯å¦æœ‰è¾¹å­˜åœ¨ for (auto \u0026amp;b : f-\u0026gt;get_basic_blocks()) { if (idom_.find(\u0026amp;b) != idom_.end() \u0026amp;\u0026amp; idom_[\u0026amp;b] != \u0026amp;b) { edge_set.push_back(\u0026#39;\\t\u0026#39; + idom_[\u0026amp;b]-\u0026gt;get_name() + \u0026#34;-\u0026gt;\u0026#34; + b.get_name() + \u0026#34;;\\n\u0026#34;); has_edges = true; // å¦‚æœå­˜åœ¨æ”¯é…è¾¹ï¼Œæ ‡è®°ä¸º true } } std::string digraph = \u0026#34;digraph G {\\n\u0026#34;; if (!has_edges \u0026amp;\u0026amp; !f-\u0026gt;get_basic_blocks().empty()) { // å¦‚æœæ²¡æœ‰è¾¹ä¸”è‡³å°‘æœ‰ä¸€ä¸ªåŸºæœ¬å—ï¼Œç›´æ¥æ·»åŠ è¯¥å—ä»¥æ˜¾ç¤ºå®ƒ auto \u0026amp;b = f-\u0026gt;get_basic_blocks().front(); digraph += \u0026#39;\\t\u0026#39; + b.get_name() + \u0026#34;;\\n\u0026#34;; } else { for (auto \u0026amp;edge : edge_set) { digraph += edge; } } digraph += \u0026#34;}\\n\u0026#34;; std::ofstream file_output; file_output.open(f-\u0026gt;get_name() + \u0026#34;_dom_tree.dot\u0026#34;, std::ios::out); file_output \u0026lt;\u0026lt; digraph; file_output.close(); std::string dot_cmd = \u0026#34;dot -Tpng \u0026#34; + f-\u0026gt;get_name() + \u0026#34;_dom_tree.dot\u0026#34; + \u0026#34; -o \u0026#34; + f-\u0026gt;get_name() + \u0026#34;_dom_tree.png\u0026#34;; std::system(dot_cmd.c_str()); } MEM2REGï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 #include \u0026#34;Mem2Reg.hpp\u0026#34; #include \u0026#34;IRBuilder.hpp\u0026#34; #include \u0026#34;Instruction.hpp\u0026#34; #include \u0026#34;Value.hpp\u0026#34; #include \u0026lt;memory\u0026gt; #include \u0026lt;vector\u0026gt; /** * @brief Mem2Reg Passçš„ä¸»å…¥å£å‡½æ•° * * è¯¥å‡½æ•°æ‰§è¡Œå†…å­˜åˆ°å¯„å­˜å™¨çš„æå‡è¿‡ç¨‹ï¼Œå°†æ ˆä¸Šçš„å±€éƒ¨å˜é‡æå‡åˆ°SSAæ ¼å¼ã€‚ * ä¸»è¦æ­¥éª¤ï¼š * 1. åˆ›å»ºå¹¶è¿è¡Œæ”¯é…æ ‘åˆ†æ * 2. å¯¹æ¯ä¸ªéå£°æ˜å‡½æ•°ï¼š * - æ¸…ç©ºç›¸å…³æ•°æ®ç»“æ„ * - æ’å…¥å¿…è¦çš„phiæŒ‡ä»¤ * - æ‰§è¡Œå˜é‡é‡å‘½å * * æ³¨æ„ï¼šå‡½æ•°æ‰§è¡Œåï¼Œå†—ä½™çš„å±€éƒ¨å˜é‡åˆ†é…æŒ‡ä»¤å°†ç”±åç»­çš„æ­»ä»£ç åˆ é™¤Passå¤„ç† */ void Mem2Reg::run() { // åˆ›å»ºæ”¯é…æ ‘åˆ†æ Pass çš„å®ä¾‹ dominators_ = std::make_unique\u0026lt;Dominators\u0026gt;(m_); // å»ºç«‹æ”¯é…æ ‘ dominators_-\u0026gt;run(); // ä»¥å‡½æ•°ä¸ºå•å…ƒéå†å®ç° Mem2Reg ç®—æ³• for (auto \u0026amp;f : m_-\u0026gt;get_functions()) { if (f.is_declaration()) continue; func_ = \u0026amp;f; var_val_stack.clear(); phi_lval.clear(); if (func_-\u0026gt;get_basic_blocks().size() \u0026gt;= 1) { // å¯¹åº”ä¼ªä»£ç ä¸­ phi æŒ‡ä»¤æ’å…¥çš„é˜¶æ®µ generate_phi(); // å¯¹åº”ä¼ªä»£ç ä¸­é‡å‘½åé˜¶æ®µ rename(func_-\u0026gt;get_entry_block()); } // åç»­ DeadCode å°†ç§»é™¤å†—ä½™çš„å±€éƒ¨å˜é‡çš„åˆ†é…ç©ºé—´ } } /** * @brief åœ¨å¿…è¦çš„ä½ç½®æ’å…¥phiæŒ‡ä»¤ * * è¯¥å‡½æ•°å®ç°äº†ç»å…¸çš„phièŠ‚ç‚¹æ’å…¥ç®—æ³•ï¼š * 1. æ”¶é›†å…¨å±€æ´»è·ƒå˜é‡ï¼š * - æ‰«ææ‰€æœ‰storeæŒ‡ä»¤ * - è¯†åˆ«åœ¨å¤šä¸ªåŸºæœ¬å—ä¸­è¢«èµ‹å€¼çš„å˜é‡ * * 2. æ’å…¥phiæŒ‡ä»¤ï¼š * - å¯¹æ¯ä¸ªå…¨å±€æ´»è·ƒå˜é‡ * - åœ¨å…¶å®šå€¼ç‚¹çš„æ”¯é…è¾¹ç•Œå¤„æ’å…¥phiæŒ‡ä»¤ * - ä½¿ç”¨å·¥ä½œè¡¨æ³•å¤„ç†è¿­ä»£å¼çš„phiæ’å…¥ * * phiæŒ‡ä»¤çš„æ’å…¥éµå¾ªæœ€å°åŒ–åŸåˆ™ï¼Œåªåœ¨å¿…è¦çš„ä½ç½®æ’å…¥phièŠ‚ç‚¹ */ void Mem2Reg::generate_phi() { // global_live_var_name æ˜¯å…¨å±€åå­—é›†åˆï¼Œä»¥ alloca å‡ºçš„å±€éƒ¨å˜é‡æ¥ç»Ÿè®¡ã€‚ // æ­¥éª¤ä¸€ï¼šæ‰¾åˆ°æ´»è·ƒåœ¨å¤šä¸ª block çš„å…¨å±€åå­—é›†åˆï¼Œä»¥åŠå®ƒä»¬æ‰€å±çš„ bb å— std::set\u0026lt;Value *\u0026gt; global_live_var_name; std::map\u0026lt;Value *, std::set\u0026lt;BasicBlock *\u0026gt;\u0026gt; live_var_2blocks; for (auto \u0026amp;bb : func_-\u0026gt;get_basic_blocks()) { std::set\u0026lt;Value *\u0026gt; var_is_killed; for (auto \u0026amp;instr : bb.get_instructions()) { if (instr.is_store()) { // store i32 a, i32 *b // a is r_val, b is l_val auto l_val = static_cast\u0026lt;StoreInst *\u0026gt;(\u0026amp;instr)-\u0026gt;get_lval(); if (is_valid_ptr(l_val)) { global_live_var_name.insert(l_val); live_var_2blocks[l_val].insert(\u0026amp;bb); } } } } // æ­¥éª¤äºŒï¼šä»æ”¯é…æ ‘è·å–æ”¯é…è¾¹ç•Œä¿¡æ¯ï¼Œå¹¶åœ¨å¯¹åº”ä½ç½®æ’å…¥ phi æŒ‡ä»¤ std::map\u0026lt;std::pair\u0026lt;BasicBlock *, Value *\u0026gt;, bool\u0026gt; bb_has_var_phi; // bb has phi for var for (auto var : global_live_var_name) { std::vector\u0026lt;BasicBlock *\u0026gt; work_list; work_list.assign(live_var_2blocks[var].begin(), live_var_2blocks[var].end()); for (unsigned i = 0; i \u0026lt; work_list.size(); i++) { auto bb = work_list[i]; for (auto bb_dominance_frontier_bb : dominators_-\u0026gt;get_dominance_frontier(bb)) { if (bb_has_var_phi.find({bb_dominance_frontier_bb, var}) == bb_has_var_phi.end()) { // generate phi for bb_dominance_frontier_bb \u0026amp; add // bb_dominance_frontier_bb to work list auto phi = PhiInst::create_phi( var-\u0026gt;get_type()-\u0026gt;get_pointer_element_type(), bb_dominance_frontier_bb); phi_lval.emplace(phi, var); bb_dominance_frontier_bb-\u0026gt;add_instr_begin(phi); work_list.push_back(bb_dominance_frontier_bb); bb_has_var_phi[{bb_dominance_frontier_bb, var}] = true; } } } } } void Mem2Reg::rename(BasicBlock *bb) { std::vector\u0026lt;Instruction *\u0026gt; wait_delete; // æ­¥éª¤ä¸€ï¼šå°† phi æŒ‡ä»¤ä½œä¸º lval çš„æœ€æ–°å®šå€¼ï¼Œlval å³æ˜¯ä¸ºå±€éƒ¨å˜é‡ alloca å‡ºçš„åœ°å€ç©ºé—´ for (auto \u0026amp;inst : bb-\u0026gt;get_instructions()) { if (inst.get_instr_type() == Instruction::phi) { auto phi_inst = static_cast\u0026lt;PhiInst *\u0026gt;(\u0026amp;inst); auto it = phi_lval.find(phi_inst); if (it != phi_lval.end()) { auto lval = it-\u0026gt;second; if (is_valid_ptr(lval)) { var_val_stack[lval].push_back(static_cast\u0026lt;Value*\u0026gt;(\u0026amp;inst)); } } } if (inst.get_instr_type() == Instruction::load) { auto loadinst = static_cast\u0026lt;LoadInst *\u0026gt;(\u0026amp;inst); auto lval = loadinst-\u0026gt;get_lval(); if (is_valid_ptr(lval) \u0026amp;\u0026amp; var_val_stack.find(lval) != var_val_stack.end() \u0026amp;\u0026amp; !var_val_stack[lval].empty()) { Value* rval = var_val_stack[lval].back(); loadinst-\u0026gt;replace_all_use_with(rval); wait_delete.push_back(loadinst); } } if (inst.get_instr_type() == Instruction::store) { auto storeinst = static_cast\u0026lt;StoreInst *\u0026gt;(\u0026amp;inst); auto lval = storeinst-\u0026gt;get_lval(); auto rval = storeinst-\u0026gt;get_rval(); if (is_valid_ptr(lval)) { var_val_stack[lval].push_back(rval); wait_delete.push_back(storeinst); } } } // æ­¥éª¤äºŒï¼šç”¨ lval æœ€æ–°çš„å®šå€¼æ›¿ä»£å¯¹åº”çš„loadæŒ‡ä»¤ // æ­¥éª¤ä¸‰ï¼šå°† store æŒ‡ä»¤çš„ rvalï¼Œä¹Ÿå³è¢«å­˜å…¥å†…å­˜çš„å€¼ï¼Œä½œä¸º lval çš„æœ€æ–°å®šå€¼ // æ­¥éª¤å››ï¼šä¸º lval å¯¹åº”çš„ phi æŒ‡ä»¤å‚æ•°è¡¥å……å®Œæ•´ for (auto succ : bb-\u0026gt;get_succ_basic_blocks()) { for (auto \u0026amp;inst : succ-\u0026gt;get_instructions()) { if (inst.get_instr_type() == Instruction::phi) { auto phi = static_cast\u0026lt;PhiInst *\u0026gt;(\u0026amp;inst); auto it = phi_lval.find(phi); if (it != phi_lval.end()) { auto lval = it-\u0026gt;second; if (is_valid_ptr(lval) \u0026amp;\u0026amp; !var_val_stack[lval].empty()) { Value *rval = var_val_stack[lval].back(); phi-\u0026gt;add_phi_pair_operand(rval, bb); } } } } } // æ­¥éª¤äº”ï¼šå¯¹ bb åœ¨æ”¯é…æ ‘ä¸Šçš„æ‰€æœ‰åç»§èŠ‚ç‚¹ï¼Œé€’å½’æ‰§è¡Œ rename æ“ä½œ auto dom_succ_blocks = dominators_-\u0026gt;get_dom_tree_succ_blocks(bb); if (!dom_succ_blocks.empty()) { for (auto succ : dom_succ_blocks) { rename(succ); } } // æ­¥éª¤å…­ï¼špopå‡º lval çš„æœ€æ–°å®šå€¼ for (auto \u0026amp;inst : bb-\u0026gt;get_instructions()) { if (inst.get_instr_type() == Instruction::store) { auto storeinst = static_cast\u0026lt;StoreInst *\u0026gt;(\u0026amp;inst); auto lval = storeinst-\u0026gt;get_lval(); if (is_valid_ptr(lval) \u0026amp;\u0026amp; var_val_stack.find(lval) != var_val_stack.end() \u0026amp;\u0026amp; !var_val_stack[lval].empty()) { var_val_stack[lval].pop_back(); } } if (inst.get_instr_type() == Instruction::phi) { auto phiinst = static_cast\u0026lt;PhiInst *\u0026gt;(\u0026amp;inst); auto it = phi_lval.find(phiinst); if (it != phi_lval.end()) { auto lval = it-\u0026gt;second; if (is_valid_ptr(lval) \u0026amp;\u0026amp; var_val_stack.find(lval) != var_val_stack.end() \u0026amp;\u0026amp; !var_val_stack[lval].empty()) { var_val_stack[lval].pop_back(); } } } } for (auto instr : wait_delete) { bb-\u0026gt;erase_instr(instr); } } å¾ªç¯ä¸å˜é‡å¤–æ\rå¾ªç¯æ£€æµ‹ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 #include \u0026#34;LoopDetection.hpp\u0026#34; #include \u0026#34;Dominators.hpp\u0026#34; #include \u0026lt;cstddef\u0026gt; #include \u0026lt;memory\u0026gt; /** * @brief å¾ªç¯æ£€æµ‹Passçš„ä¸»å…¥å£å‡½æ•° * * è¯¥å‡½æ•°æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š * 1. åˆ›å»ºæ”¯é…æ ‘åˆ†æå®ä¾‹ * 2. éå†æ¨¡å—ä¸­çš„æ‰€æœ‰å‡½æ•° * 3. å¯¹æ¯ä¸ªéå£°æ˜å‡½æ•°æ‰§è¡Œå¾ªç¯æ£€æµ‹ * 4. æœ€åæ‰“å°æ£€æµ‹ç»“æœ */ void LoopDetection::run() { dominators_ = std::make_unique\u0026lt;Dominators\u0026gt;(m_); for (auto \u0026amp;f1 : m_-\u0026gt;get_functions()) { auto f = \u0026amp;f1; if (f-\u0026gt;is_declaration()) continue; func_ = f; run_on_func(f); } print(); } /** * @brief å‘ç°å¾ªç¯åŠå…¶å­å¾ªç¯ * @param bb å¾ªç¯çš„headerå— * @param latches å¾ªç¯çš„å›è¾¹ç»ˆç‚¹(latch)é›†åˆ * @param loop å½“å‰æ­£åœ¨å¤„ç†çš„å¾ªç¯å¯¹è±¡ */ void LoopDetection::discover_loop_and_sub_loops(BasicBlock *bb, BBset \u0026amp;latches, std::shared_ptr\u0026lt;Loop\u0026gt; loop) { // TODO List: // 1. åˆå§‹åŒ–å·¥ä½œè¡¨ï¼Œå°†æ‰€æœ‰latchå—åŠ å…¥ // 2. å®ç°ä¸»å¾ªç¯é€»è¾‘ // 3. å¤„ç†æœªåˆ†é…ç»™ä»»ä½•å¾ªç¯çš„èŠ‚ç‚¹ // 4. å¤„ç†å·²å±äºå…¶ä»–å¾ªç¯çš„èŠ‚ç‚¹ // 5. å»ºç«‹æ­£ç¡®çš„å¾ªç¯åµŒå¥—å…³ç³» BBvec work_list = {latches.begin(), latches.end()}; // åˆå§‹åŒ–å·¥ä½œè¡¨ while (!work_list.empty()) { // å½“å·¥ä½œè¡¨éç©ºæ—¶ç»§ç»­å¤„ç† auto bb = work_list.back(); work_list.pop_back(); // TODO-1: å¤„ç†æœªåˆ†é…ç»™ä»»ä½•å¾ªç¯çš„èŠ‚ç‚¹ if (bb_to_loop_.find(bb) == bb_to_loop_.end()) { /* åœ¨æ­¤æ·»åŠ ä»£ç ï¼š * 1. ä½¿ç”¨loop-\u0026gt;add_blockå°†bbåŠ å…¥å½“å‰å¾ªç¯ * 2. æ›´æ–°bb_to_loop_æ˜ å°„ * 3. å°†bbçš„æ‰€æœ‰å‰é©±åŠ å…¥å·¥ä½œè¡¨ */ loop-\u0026gt;add_block(bb); bb_to_loop_[bb] = loop; for (auto pred : bb-\u0026gt;get_pre_basic_blocks()) { work_list.push_back(pred); } // throw std::runtime_error(\u0026#34;Lab4: ä½ æœ‰ä¸€ä¸ªTODOéœ€è¦å®Œæˆï¼\u0026#34;); } // TODO-2: å¤„ç†å·²å±äºå…¶ä»–å¾ªç¯çš„èŠ‚ç‚¹ else if (bb_to_loop_[bb] != loop) { /* åœ¨æ­¤æ·»åŠ ä»£ç ï¼š * 1. è·å–bbå½“å‰æ‰€å±çš„å¾ªç¯sub_loop * 2. æ‰¾åˆ°sub_loopçš„æœ€é¡¶å±‚çˆ¶å¾ªç¯ * 3. æ£€æŸ¥æ˜¯å¦éœ€è¦ç»§ç»­å¤„ç† * 4. å»ºç«‹å¾ªç¯åµŒå¥—å…³ç³»ï¼š * - è®¾ç½®çˆ¶å¾ªç¯ * - æ·»åŠ å­å¾ªç¯ * 5. å°†å­å¾ªç¯çš„æ‰€æœ‰åŸºæœ¬å¿«åŠ å…¥åˆ°çˆ¶å¾ªç¯ä¸­ * 6. å°†å­å¾ªç¯headerçš„å‰é©±åŠ å…¥å·¥ä½œè¡¨ */ auto sub_loop = bb_to_loop_[bb]; auto parent_loop = sub_loop-\u0026gt;get_parent(); // æ‰¾åˆ°æœ€é¡¶å±‚çš„çˆ¶å¾ªç¯ while (parent_loop != nullptr \u0026amp;\u0026amp; parent_loop != loop) { sub_loop = parent_loop; parent_loop = sub_loop-\u0026gt;get_parent(); } // å¦‚æœå½“å‰å¾ªç¯ä¸æ˜¯æœ€é¡¶å±‚çˆ¶å¾ªç¯ï¼Œåˆ™å»ºç«‹åµŒå¥—å…³ç³» if (parent_loop == nullptr) { sub_loop-\u0026gt;set_parent(loop); loop-\u0026gt;add_sub_loop(sub_loop); for (auto block : sub_loop-\u0026gt;get_blocks()) { loop-\u0026gt;add_block(block); } work_list.push_back(sub_loop-\u0026gt;get_header()); } // throw std::runtime_error(\u0026#34;Lab4: ä½ æœ‰ä¸€ä¸ªTODOéœ€è¦å®Œæˆï¼\u0026#34;); } } } /** * @brief å¯¹å•ä¸ªå‡½æ•°æ‰§è¡Œå¾ªç¯æ£€æµ‹ * @param f è¦åˆ†æçš„å‡½æ•° * * è¯¥å‡½æ•°é€šè¿‡ä»¥ä¸‹æ­¥éª¤æ£€æµ‹å¾ªç¯ï¼š * 1. è¿è¡Œæ”¯é…æ ‘åˆ†æ * 2. æŒ‰æ”¯é…æ ‘ååºéå†æ‰€æœ‰åŸºæœ¬å— * 3. å¯¹æ¯ä¸ªå—ï¼Œæ£€æŸ¥å…¶å‰é©±æ˜¯å¦å­˜åœ¨å›è¾¹ * 4. å¦‚æœå­˜åœ¨å›è¾¹ï¼Œåˆ›å»ºæ–°çš„å¾ªç¯å¹¶ï¼š * - è®¾ç½®å¾ªç¯header * - æ·»åŠ latchèŠ‚ç‚¹ * - å‘ç°å¾ªç¯ä½“å’Œå­å¾ªç¯ */ void LoopDetection::run_on_func(Function *f) { dominators_-\u0026gt;run_on_func(f); for (auto \u0026amp;bb1 : dominators_-\u0026gt;get_dom_post_order()) { auto bb = bb1; BBset latches; for (auto \u0026amp;pred : bb-\u0026gt;get_pre_basic_blocks()) { if (dominators_-\u0026gt;is_dominate(bb, pred)) { // pred is a back edge // pred -\u0026gt; bb , pred is the latch node latches.insert(pred); } } if (latches.empty()) { continue; } // create loop auto loop = std::make_shared\u0026lt;Loop\u0026gt;(bb); bb_to_loop_[bb] = loop; // add latch nodes for (auto \u0026amp;latch : latches) { loop-\u0026gt;add_latch(latch); } loops_.push_back(loop); discover_loop_and_sub_loops(bb, latches, loop); } } /** * @brief æ‰“å°å¾ªç¯æ£€æµ‹çš„ç»“æœ * * ä¸ºæ¯ä¸ªæ£€æµ‹åˆ°çš„å¾ªç¯æ‰“å°ï¼š * 1. å¾ªç¯çš„headerå— * 2. å¾ªç¯åŒ…å«çš„æ‰€æœ‰åŸºæœ¬å— * 3. å¾ªç¯çš„æ‰€æœ‰å­å¾ªç¯ */ void LoopDetection::print() { m_-\u0026gt;set_print_name(); std::cerr \u0026lt;\u0026lt; \u0026#34;Loop Detection Result:\u0026#34; \u0026lt;\u0026lt; std::endl; for (auto \u0026amp;loop : loops_) { std::cerr \u0026lt;\u0026lt; \u0026#34;Loop header: \u0026#34; \u0026lt;\u0026lt; loop-\u0026gt;get_header()-\u0026gt;get_name() \u0026lt;\u0026lt; std::endl; std::cerr \u0026lt;\u0026lt; \u0026#34;Loop blocks: \u0026#34;; for (auto \u0026amp;bb : loop-\u0026gt;get_blocks()) { std::cerr \u0026lt;\u0026lt; bb-\u0026gt;get_name() \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } std::cerr \u0026lt;\u0026lt; std::endl; std::cerr \u0026lt;\u0026lt; \u0026#34;Sub loops: \u0026#34;; for (auto \u0026amp;sub_loop : loop-\u0026gt;get_sub_loops()) { std::cerr \u0026lt;\u0026lt; sub_loop-\u0026gt;get_header()-\u0026gt;get_name() \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } std::cerr \u0026lt;\u0026lt; std::endl; } } å¤–æå¾ªç¯ä¸å˜é‡ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 #include \u0026#34;BasicBlock.hpp\u0026#34; #include \u0026#34;Constant.hpp\u0026#34; #include \u0026#34;FuncInfo.hpp\u0026#34; #include \u0026#34;Function.hpp\u0026#34; #include \u0026#34;GlobalVariable.hpp\u0026#34; #include \u0026#34;Instruction.hpp\u0026#34; #include \u0026#34;LICM.hpp\u0026#34; #include \u0026#34;PassManager.hpp\u0026#34; #include \u0026lt;cstddef\u0026gt; #include \u0026lt;memory\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026#34;logging.hpp\u0026#34; /** * @brief å¾ªç¯ä¸å˜å¼å¤–æPassçš„ä¸»å…¥å£å‡½æ•° * */ int label_num = 0; void LoopInvariantCodeMotion::run() { loop_detection_ = std::make_unique\u0026lt;LoopDetection\u0026gt;(m_); loop_detection_-\u0026gt;run(); func_info_ = std::make_unique\u0026lt;FuncInfo\u0026gt;(m_); func_info_-\u0026gt;run(); for (auto \u0026amp;loop : loop_detection_-\u0026gt;get_loops()) { is_loop_done_[loop] = false; } for (auto \u0026amp;loop : loop_detection_-\u0026gt;get_loops()) { traverse_loop(loop); } } /** * @brief éå†å¾ªç¯åŠå…¶å­å¾ªç¯ * @param loop å½“å‰è¦å¤„ç†çš„å¾ªç¯ * */ void LoopInvariantCodeMotion::traverse_loop(std::shared_ptr\u0026lt;Loop\u0026gt; loop) { if (is_loop_done_[loop]) { return; } is_loop_done_[loop] = true; for (auto \u0026amp;sub_loop : loop-\u0026gt;get_sub_loops()) { traverse_loop(sub_loop); } run_on_loop(loop); } // TODO: å®ç°collect_loop_infoå‡½æ•° // 1. éå†å½“å‰å¾ªç¯åŠå…¶å­å¾ªç¯çš„æ‰€æœ‰æŒ‡ä»¤ // 2. æ”¶é›†æ‰€æœ‰æŒ‡ä»¤åˆ°loop_instructionsä¸­ // 3. æ£€æŸ¥storeæŒ‡ä»¤æ˜¯å¦ä¿®æ”¹äº†å…¨å±€å˜é‡ï¼Œå¦‚æœæ˜¯åˆ™æ·»åŠ åˆ°updated_globalä¸­ // 4. æ£€æŸ¥æ˜¯å¦åŒ…å«éçº¯å‡½æ•°è°ƒç”¨ï¼Œå¦‚æœæœ‰åˆ™è®¾ç½®contains_impure_callä¸ºtrue void LoopInvariantCodeMotion::collect_loop_info( std::shared_ptr\u0026lt;Loop\u0026gt; loop, std::set\u0026lt;Value *\u0026gt; \u0026amp;loop_instructions, std::set\u0026lt;Value *\u0026gt; \u0026amp;updated_global, bool \u0026amp;contains_impure_call) { auto sub_loops = loop-\u0026gt;get_sub_loops(); for (auto \u0026amp;bb : loop-\u0026gt;get_blocks()) { for (auto \u0026amp;inst : bb-\u0026gt;get_instructions()) { loop_instructions.insert(\u0026amp;inst); if (inst.get_instr_type() == Instruction::store) { LOG(DEBUG) \u0026lt;\u0026lt; \u0026#34;store_inst: \u0026#34; \u0026lt;\u0026lt; inst.print(); auto store_inst = dynamic_cast\u0026lt;StoreInst *\u0026gt;(\u0026amp;inst); //å·¦å€¼æ˜¯åœ°å€ï¼Œå³å€¼æ˜¯å€¼ auto rval = store_inst-\u0026gt;get_rval(); if (dynamic_cast\u0026lt;GlobalVariable *\u0026gt;(rval) != nullptr) { LOG(DEBUG) \u0026lt;\u0026lt; \u0026#34;add gloabl\u0026#34;; updated_global.insert(rval); } } if (inst.get_instr_type() == Instruction::call) { auto func = static_cast\u0026lt;Function*\u0026gt;(inst.get_operand(0)); if(func_info_-\u0026gt;is_pure_function(func)) { LOG(DEBUG) \u0026lt;\u0026lt; \u0026#34;contains_pure_call\u0026#34;; contains_impure_call = false; } else { LOG(DEBUG) \u0026lt;\u0026lt; \u0026#34;contains_impure_call\u0026#34;; contains_impure_call = true; } } } } for (auto sub_loop : sub_loops) { for (auto \u0026amp;bb : sub_loop-\u0026gt;get_blocks()) { for (auto \u0026amp;inst : bb-\u0026gt;get_instructions()) { loop_instructions.insert(\u0026amp;inst); if (inst.get_instr_type() == Instruction::store) { LOG(DEBUG) \u0026lt;\u0026lt; \u0026#34;store_inst: \u0026#34; \u0026lt;\u0026lt; inst.print(); auto store_inst = dynamic_cast\u0026lt;StoreInst *\u0026gt;(\u0026amp;inst); //å·¦å€¼æ˜¯åœ°å€ï¼Œå³å€¼æ˜¯å€¼ auto rval = store_inst-\u0026gt;get_rval(); if (dynamic_cast\u0026lt;GlobalVariable *\u0026gt;(rval) != nullptr) { LOG(DEBUG) \u0026lt;\u0026lt; \u0026#34;add gloabl\u0026#34;; updated_global.insert(rval); } } if (inst.get_instr_type() == Instruction::call) { auto func = static_cast\u0026lt;Function*\u0026gt;(inst.get_operand(0)); if(func_info_-\u0026gt;is_pure_function(func)) { contains_impure_call = false; } else { contains_impure_call = true; } } } } } } /** * @brief å¯¹å•ä¸ªå¾ªç¯æ‰§è¡Œä¸å˜å¼å¤–æä¼˜åŒ– * @param loop è¦ä¼˜åŒ–çš„å¾ªç¯ * */ void LoopInvariantCodeMotion::run_on_loop(std::shared_ptr\u0026lt;Loop\u0026gt; loop) { std::set\u0026lt;Value *\u0026gt; loop_instructions; std::set\u0026lt;Value *\u0026gt; updated_global; bool contains_impure_call = false; collect_loop_info(loop, loop_instructions, updated_global, contains_impure_call); for (auto global : updated_global) { LOG(DEBUG) \u0026lt;\u0026lt; \u0026#34;updated_global: \u0026#34; \u0026lt;\u0026lt; global-\u0026gt;get_name(); } std::vector\u0026lt;Value *\u0026gt; loop_invariant; // TODO: è¯†åˆ«å¾ªç¯ä¸å˜å¼æŒ‡ä»¤ // // - å¦‚æœæŒ‡ä»¤å·²è¢«æ ‡è®°ä¸ºä¸å˜å¼åˆ™è·³è¿‡ // - è·³è¿‡ storeã€retã€brã€phi ç­‰æŒ‡ä»¤ä¸éçº¯å‡½æ•°è°ƒç”¨ // - ç‰¹æ®Šå¤„ç†å…¨å±€å˜é‡çš„ load æŒ‡ä»¤ // - æ£€æŸ¥æŒ‡ä»¤çš„æ‰€æœ‰æ“ä½œæ•°æ˜¯å¦éƒ½æ˜¯å¾ªç¯ä¸å˜çš„ // - å¦‚æœæœ‰æ–°çš„ä¸å˜å¼è¢«æ·»åŠ åˆ™æ³¨æ„æ›´æ–° changed æ ‡å¿—ï¼Œç»§ç»­è¿­ä»£ bool changed; do { changed = false; for (auto inst : loop_instructions) { auto it = std::find(loop_invariant.begin(), loop_invariant.end(), inst); if (it != loop_invariant.end()) { continue; } auto instr = dynamic_cast\u0026lt;Instruction *\u0026gt;(inst); if (instr == nullptr) { continue; } if (instr-\u0026gt;get_instr_type() == Instruction::store || instr-\u0026gt;get_instr_type() == Instruction::ret || instr-\u0026gt;get_instr_type() == Instruction::br || instr-\u0026gt;get_instr_type() == Instruction::phi) { continue; } if (instr-\u0026gt;get_instr_type() == Instruction::call) { if (contains_impure_call) { continue; } } //ç‰¹æ®Šå¤„ç†å…¨å±€å˜é‡çš„loadæŒ‡ä»¤ï¼Œå¦‚æœæ˜¯å…¨å±€å˜é‡çš„loadæŒ‡ä»¤ï¼Œä¸”æ²¡æœ‰è¢«æ›´æ–°è¿‡ï¼Œåˆ™åŠ å…¥å¾ªç¯ä¸å˜å¼ if (instr-\u0026gt;get_instr_type() == Instruction::load) { auto load_inst = dynamic_cast\u0026lt;LoadInst *\u0026gt;(instr); auto lval = load_inst-\u0026gt;get_lval(); if (dynamic_cast\u0026lt;GlobalVariable *\u0026gt;(lval) != nullptr) { LOG(DEBUG) \u0026lt;\u0026lt; \u0026#34;global_lval: \u0026#34; \u0026lt;\u0026lt; lval-\u0026gt;get_name(); if (updated_global.find(lval) == updated_global.end()) { LOG(DEBUG) \u0026lt;\u0026lt; \u0026#34;insert global inval \u0026#34; ; loop_invariant.push_back(instr); changed = true; continue; } else { continue; } } } //ä¸‹é¢å¯¹å…¶ä»–çš„æŒ‡ä»¤è¿›è¡Œåˆ¤æ–­ï¼Œå¦‚æœä¸åœ¨å¾ªç¯ä¸­åˆ™åŠ å…¥å¾ªç¯ä¸å˜å¼ //è·å¾—æ“ä½œæ•°ï¼Œé€ä¸ªæ£€æŸ¥æ˜¯ä¸æ˜¯å¸¸æ•°ï¼Œæ˜¯ä¸æ˜¯å¾ªç¯ä¸å˜å¼ï¼Œåœ¨å½“å‰å¾ªç¯ä¸­æ˜¯å¦å­˜åœ¨ï¼Œå½“å‰å¾ªç¯æ‰¾ä¸åˆ°çš„è¯å°±æ˜¯å¾ªç¯ä¸å˜å¼ bool operands_are_invariant = true; for(auto operand : instr-\u0026gt;get_operands()) { if (loop_instructions.find(operand) != loop_instructions.end()) { if (std::find(loop_invariant.begin(), loop_invariant.end(), operand) == loop_invariant.end()) { //å¦‚æœæ“ä½œæ•°éƒ½æ˜¯å¾ªç¯ä¸å˜å¼ //å¦‚æœæœ‰ä¸€ä¸ªä¸æ˜¯å¾ªç¯ä¸å˜å¼ operands_are_invariant = false; break; } } } if (operands_are_invariant) { loop_invariant.push_back(instr); changed = true; } //ç”±äºæ˜¯é€’å½’åˆ†æ //ä¸èƒ½ç”¨ä¸‹é¢çš„æ–¹æ³•ï¼Œå› ä¸ºè¿™æ ·ä¼šå¯¼è‡´å¾ªç¯ä¸å˜å¼çš„å¢åŠ ï¼Œä½†æ˜¯å®é™…ä¸Šè¿™ä¸ªå¾ªç¯ä¸å˜å¼å¹¶ä¸æ˜¯å¾ªç¯ä¸å˜å¼ // bool is_invariant = true; // for (auto operand : instr-\u0026gt;get_operands()) { // auto it = std::find(loop_invariant.begin(), loop_invariant.end(), operand); // if (it == loop_invariant.end()) { // is_invariant = false; // break; // } // } // if (is_invariant) { // loop_invariant.push_back(inst); // changed = true; // } } // throw std::runtime_error(\u0026#34;Lab4: ä½ æœ‰ä¸€ä¸ªTODOéœ€è¦å®Œæˆï¼\u0026#34;); // LOG(DEBUG) \u0026lt;\u0026lt; \u0026#34;Loop invariant not done\u0026#34;; } while (changed); // LOG(DEBUG) \u0026lt;\u0026lt; \u0026#34;Loop invariant done\u0026#34;; if (loop-\u0026gt;get_preheader() == nullptr) { //å¦‚æœæ²¡æœ‰å‰ç½®å—ï¼Œåˆ™åˆ›å»ºä¸€ä¸ª auto name = \u0026#34;preheader\u0026#34; + std::to_string(label_num++); loop-\u0026gt;set_preheader( BasicBlock::create(m_, \u0026#34;\u0026#34;, loop-\u0026gt;get_header()-\u0026gt;get_parent())); } if (loop_invariant.empty()) return; // insert preheader auto preheader = loop-\u0026gt;get_preheader(); for (auto \u0026amp;phi_inst_ : loop-\u0026gt;get_header()-\u0026gt;get_instructions()) { //éå†å¾ªç¯å¤´éƒ¨çš„phiæŒ‡ä»¤,å¦‚æœé‡åˆ°äº†éphiæŒ‡ä»¤åˆ™é€€å‡º if (phi_inst_.get_instr_type() != Instruction::phi) break; // LOG(DEBUG) \u0026lt;\u0026lt; \u0026#34;phi_inst_:\u0026#34; \u0026lt;\u0026lt; phi_inst_.print(); //æ£€æŸ¥phiæŒ‡ä»¤ä¸­æ‰€æœ‰élatchçš„å‰é©±ï¼Œæ”¹ä¸ºpreheader auto phi_inst = dynamic_cast\u0026lt;PhiInst *\u0026gt;(\u0026amp;phi_inst_); if (phi_inst == nullptr) { continue; } // auto num = static_cast\u0026lt;int\u0026gt;(phi_inst-\u0026gt;get_num_operand()); if (!preheader-\u0026gt;empty()) { //å¦‚æœæœ‰bræŒ‡ä»¤ï¼Œéœ€è¦åˆ é™¤,å› ä¸ºåé¢ä¼šé‡æ–°æ’å…¥ if (preheader-\u0026gt;is_terminated()) { auto \u0026amp;inst = preheader-\u0026gt;get_instructions().back(); if (inst.get_instr_type() == Instruction::br) { preheader-\u0026gt;remove_instr(\u0026amp;inst); } } continue; } else { //å¦‚æœåŸæœ¬ä¸å­˜åœ¨preheaderï¼Œå³æ˜¯åˆ›å»ºçš„ç©ºçš„preheader,æ­¤æ—¶éœ€è¦åœ¨preheaderå¤„æ’å…¥ä¸€ä¸ªæ–°çš„phiæŒ‡ä»¤ç”¨äºæ›¿æ¢ï¼ŒåŒæ—¶å°†åŸphiæŒ‡ä»¤çš„å‰é©±æ”¹ä¸ºpreheader // preheader-\u0026gt;add_instruction(phi_inst); auto new_phi = PhiInst::create_phi(phi_inst-\u0026gt;get_type(), preheader); preheader-\u0026gt;add_instruction(new_phi); // LOG(INFO) \u0026lt;\u0026lt; \u0026#34;preheader\u0026#34; \u0026lt;\u0026lt; preheader-\u0026gt;print(); auto val_bbs = phi_inst-\u0026gt;get_phi_pairs(); phi_inst-\u0026gt;remove_all_operands(); // LOG(INFO) \u0026lt;\u0026lt; \u0026#34;BEFORE phiâ€”â€”new: \u0026#34; \u0026lt;\u0026lt; new_phi-\u0026gt;print(); // LOG(INFO) \u0026lt;\u0026lt; \u0026#34;BEFORE phi: \u0026#34; \u0026lt;\u0026lt; phi_inst-\u0026gt;print(); for (auto val_bb : val_bbs) { auto val = val_bb.first; int flag = 0; auto val_new = static_cast\u0026lt;Instruction*\u0026gt;(val); if(!val-\u0026gt;get_name().empty()) { flag = 1; } auto bb = val_bb.second; // LOG(INFO) \u0026lt;\u0026lt; \u0026#34;bb: \u0026#34; \u0026lt;\u0026lt; bb-\u0026gt;print(); if (std::find(loop-\u0026gt;get_latches().begin(), loop-\u0026gt;get_latches().end(), bb) != loop-\u0026gt;get_latches().end()) { phi_inst-\u0026gt;add_phi_pair_operand(val, bb); continue; } if (flag == 1) { new_phi-\u0026gt;add_phi_pair_operand(val_new, bb); phi_inst-\u0026gt;add_phi_pair_operand(val_new, preheader); } else { new_phi-\u0026gt;add_phi_pair_operand(val, bb); phi_inst-\u0026gt;add_phi_pair_operand(val, preheader); } } } } // TODO: ç”¨è·³è½¬æŒ‡ä»¤é‡æ„æ§åˆ¶æµå›¾ // å°†æ‰€æœ‰é latch çš„ header å‰é©±å—çš„è·³è½¬æŒ‡å‘ preheader // å¹¶å°† preheader çš„è·³è½¬æŒ‡å‘ header // æ³¨æ„è¿™é‡Œéœ€è¦æ›´æ–°å‰é©±å—çš„åç»§å’Œåç»§çš„å‰é©± std::vector\u0026lt;BasicBlock *\u0026gt; pred_to_remove; auto latches_1 = loop-\u0026gt;get_latches(); auto header = loop-\u0026gt;get_header(); auto preds = header-\u0026gt;get_pre_basic_blocks(); for (auto pred : preds) { if (pred == preheader) { continue; } if (pred == nullptr) { std::cerr \u0026lt;\u0026lt; \u0026#34;Error: pred is nullptr\u0026#34; \u0026lt;\u0026lt; std::endl; continue; } if (!latches_1.empty() \u0026amp;\u0026amp; std::find(latches_1.begin(), latches_1.end(), pred) != latches_1.end()) { continue; } //åˆ›å»ºè·³è½¬æŒ‡ä»¤é‡æ„æ§åˆ¶æµå›¾ if (pred-\u0026gt;is_terminated()) { // LOG(INFO) \u0026lt;\u0026lt; \u0026#34;chongjian\u0026#34;; auto \u0026amp;br_before = pred-\u0026gt;get_instructions().back(); if (br_before.get_instr_type() != Instruction::br) { continue; } else { auto br_11 = dynamic_cast\u0026lt;BranchInst *\u0026gt;(\u0026amp;br_before); // LOG(INFO) \u0026lt;\u0026lt; \u0026#34;br_11\u0026#34; \u0026lt;\u0026lt; br_11-\u0026gt;print(); pred-\u0026gt;remove_instr(\u0026amp;br_before); // LOG(DEBUG) \u0026lt;\u0026lt; \u0026#34;remove_instr_2: \u0026#34; \u0026lt;\u0026lt; br_before.print(); if (br_11-\u0026gt;is_cond_br()) { auto br_cond = br_11-\u0026gt;get_condition(); auto false_bb = static_cast\u0026lt;BasicBlock*\u0026gt;(br_11-\u0026gt;get_operand(2)); BranchInst::create_cond_br(br_cond, preheader, false_bb, pred); } else { BranchInst::create_br(preheader, pred); } } } pred_to_remove.push_back(pred); } header-\u0026gt;add_pre_basic_block(preheader); preheader-\u0026gt;add_succ_basic_block(header); for (auto \u0026amp;pred : pred_to_remove) { loop-\u0026gt;get_header()-\u0026gt;remove_pre_basic_block(pred); } // TODO: å¤–æå¾ªç¯ä¸å˜æŒ‡ä»¤ // throw std::runtime_error(\u0026#34;Lab4: ä½ æœ‰ä¸€ä¸ªTODOéœ€è¦å®Œæˆï¼\u0026#34;); for (auto inst : loop_invariant) { LOG(INFO) \u0026lt;\u0026lt; \u0026#34;loop_invariant: \u0026#34; \u0026lt;\u0026lt; inst-\u0026gt;print(); auto instr = dynamic_cast\u0026lt;Instruction *\u0026gt;(inst); if (instr == nullptr) { continue; } if (preheader-\u0026gt;is_terminated()) { continue; } //éå†åŸºæœ¬å—ï¼Œæ‰¾åˆ°instræ‰€åœ¨çš„åŸºæœ¬å—,å¹¶å°†insträ»åŸåŸºæœ¬å—ä¸­åˆ é™¤ for (auto bb : loop-\u0026gt;get_blocks()) { if (instr-\u0026gt;get_parent() == bb) { bb-\u0026gt;remove_instr(instr); LOG(DEBUG) \u0026lt;\u0026lt; \u0026#34;remove_instr_1: \u0026#34; \u0026lt;\u0026lt; instr-\u0026gt;print(); } } preheader-\u0026gt;add_instruction(instr); } // insert preheader br to header BranchInst::create_br(loop-\u0026gt;get_header(), preheader); // insert preheader to parent loop if (loop-\u0026gt;get_parent() != nullptr) { loop-\u0026gt;get_parent()-\u0026gt;add_block(preheader); } } ","date":"2025-01-24T17:50:13+08:00","image":"http://localhost:1313/post/005.png","permalink":"http://localhost:1313/p/compiler/","title":"æ‰‹åŠ¨æ­å»ºç¼–è¯‘å™¨  åŸºäºé¾™èŠ¯æ±‡ç¼–ä¸LIGHTIRä¸­é—´ä»£ç "},{"content":" \u0026mdash;\u0026mdash;by zyh 2025.1.6\n1.è¯æ³•åˆ†æ\råŠŸèƒ½ï¼šå°†è¾“å…¥å­—ç¬¦ä¸²è¯†åˆ«ä¸ºæœ‰æ„ä¹‰çš„å­ä¸²ï¼Œå³è¯æ³•å•å…ƒ(token)\n1.1 è¯æ³•å•å…ƒçš„æè¿°-æ­£åˆ™å¼\ræ­£åˆ™è¡¨è¾¾å¼(Regular Expression)æ˜¯ä¸€ç§æ–‡æœ¬æ¨¡å¼ï¼ŒåŒ…æ‹¬æ™®é€šå­—ç¬¦ï¼ˆä¾‹å¦‚ï¼Œa åˆ° z ä¹‹é—´çš„å­—æ¯ï¼‰å’Œç‰¹æ®Šå­—ç¬¦ï¼ˆç§°ä¸º\u0026quot;å…ƒå­—ç¬¦\u0026quot;ï¼‰ï¼Œå¯ä»¥ç”¨æ¥æè¿°å’ŒåŒ¹é…å­—ç¬¦ä¸²çš„ç‰¹å®šæ¨¡å¼ã€‚\nä¸€ä¸ªç®€å•çš„ä¾‹å­ï¼šæ­£æ•´æ•°è¯†åˆ«\n1 2 digit-\u0026gt;0|1|2|3|4|5|6|7|8|9 digits-\u0026gt;digit digit* å…¶ä¸­ï¼Œ*è¡¨ç¤ºé—­åŒ…ï¼Œå³å‡ºç°é›¶æ¬¡æˆ–å¤šæ¬¡ã€‚\nä¸‹é¢æ˜¯å¸¸ç”¨çš„ä¸€äº›æ­£åˆ™è¡¨è¾¾å¼è¯­æ³•ï¼š\nå¸¸ç”¨è¯­æ³•ï¼š\n[abc] åŒ¹é…æ–¹æ‹¬å·ä¸­æ‰€æœ‰å•å­—ç¬¦ï¼Œä¸ä¸€å®šæŒ‰é¡ºåºï¼› [^abc] åŒ¹é…é™¤äº†æ–¹æ‹¬å·ä¸­å­—ç¬¦å¤–æ‰€æœ‰å­—ç¬¦ï¼› [a-z] åŒ¹é…åŒºé—´æ‰€æœ‰å­—ç¬¦ï¼Œæ³¨æ„å¤§å°å†™ï¼› [\\s\\S] åŒ¹é…æ‰€æœ‰ã€‚\\s æ˜¯åŒ¹é…æ‰€æœ‰ç©ºç™½ç¬¦ï¼ŒåŒ…æ‹¬æ¢è¡Œï¼Œ\\S éç©ºç™½ç¬¦ï¼Œä¸åŒ…æ‹¬æ¢è¡Œï¼› \\w åŒ¹é…å­—æ¯ã€æ•°å­—ã€ä¸‹åˆ’çº¿ã€‚ç­‰ä»·äº [A-Za-z0-9_]ï¼› \\d åŒ¹é…ä»»æ„ä¸€ä¸ªé˜¿æ‹‰ä¼¯æ•°å­—ï¼ˆ0 åˆ° 9ï¼‰ã€‚ç­‰ä»·äº [0-9]ã€‚ ç‰¹æ®Šå­—ç¬¦ï¼š\n* è¡¨ç¤ºåŒ¹é…å‰é¢çš„å­è¡¨è¾¾å¼é›¶æ¬¡æˆ–å¤šæ¬¡ï¼› + è¡¨ç¤ºåŒ¹é…å‰é¢çš„å­è¡¨è¾¾å¼ä¸€æ¬¡æˆ–å¤šæ¬¡ï¼› . è¡¨ç¤ºåŒ¹é…é™¤æ¢è¡Œä»¥å¤–çš„ä»»æ„å­—ç¬¦ï¼› ? è¡¨ç¤ºåŒ¹é…å‰é¢çš„å­è¡¨è¾¾å¼é›¶æ¬¡æˆ–ä¸€æ¬¡ï¼› | è¡¨ç¤ºä¸¤é¡¹ä¹‹é—´é€‰æ‹©ã€‚ å¦‚æœè¦åŒ¹é…ç‰¹æ®Šå­—ç¬¦ï¼Œéœ€è¦åœ¨å‰é¢åŠ ä¸Š\\è¿›è¡Œè½¬ä¹‰ï¼Œ\\æœ¬èº«ä¹Ÿæ˜¯ç‰¹æ®Šå­—ç¬¦ã€‚\negï¼šåŒ¹é…ç”±å¶æ•°ä¸ª0å’Œå¥‡æ•°ä¸ª1æ„æˆçš„01ä¸²ï¼š\n1 2 1(00|11)*((01|10)(00|11)*(01|10)(00|11)*)*|0(00|11)*(01|10) (00|11)*((01|10)(00|11)*(01|10)(00|11)*)* 1.2 è¯æ³•å•å…ƒçš„è¯†åˆ«-è½¬æ¢å›¾\rå¦‚ä¸‹å›¾çš„ä¾‹å­ï¼š\n1.3 æœ‰é™è‡ªåŠ¨æœº\rNFAï¼šä¸ç¡®å®šçš„æœ‰é™è‡ªåŠ¨æœº\nå¦‚ä¸‹å›¾çš„ä¾‹å­(a|b)*abï¼ˆ2æ˜¯æ¥å—çŠ¶æ€ï¼Œä¸¤ä¸ªåœˆç”»ä¸å‡ºæ¥ï¼‰ï¼š\n1 2 3 4 5 6 graph LR begin--\u0026gt;a((0)) a((0))--a--\u0026gt;a((0)) a((0))--b--\u0026gt;a((0)) a((0))--a--\u0026gt;b((1)) b((1))--b--\u0026gt;c((2)) NFAå¯¹äºä¸€ä¸ªtokenï¼Œæœ‰å¯èƒ½è¦å°è¯•å¾ˆå¤šä¸åŒçš„è·¯å¾„ï¼Œå¤§éƒ¨åˆ†éƒ½æ˜¯ç™½è´¹åŠŸå¤«ï¼Œæ•ˆç‡å¾ˆä½ã€‚\nDFAï¼šç¡®å®šçš„æœ‰é™è‡ªåŠ¨æœº\nå’Œä¸Šé¢ä¸€æ ·çš„æ­£åˆ™å¼ï¼Œæœ‰å¦‚ä¸‹å›¾ï¼ˆ2æ˜¯æ¥å—çŠ¶æ€ï¼‰ï¼š\n1 2 3 4 5 6 7 8 graph LR begin--\u0026gt;a((0)) a((0))--b--\u0026gt;a((0)) a((0))--a--\u0026gt;b((1)) b((1))--a--\u0026gt;b((1)) b((1))--b--\u0026gt;c((2)) c((2))--a--\u0026gt;b((1)) c((2))--b--\u0026gt;a((0)) è¯­æ³•åˆ¶å¯¼çš„æ„é€ ç®—æ³•ï¼šNFAçš„æ„é€ (fè¡¨ç¤ºæ¥å—çŠ¶æ€)\nå•å­—ç¬¦ï¼ˆåŒ…æ‹¬ç©ºÎµï¼‰ï¼š\n1 2 3 graph LR begin--\u0026gt;a((i)) a((i))--Îµ/a--\u0026gt;b((f)) é€‰æ‹©å¼s|tï¼š\n1 2 3 4 5 6 graph LR begin--\u0026gt;a((i)) a((i))--Îµ--\u0026gt;b(s) a((i))--Îµ--\u0026gt;c(t) b(s)--Îµ--\u0026gt;d((f)) c(t)--Îµ--\u0026gt;d((f)) st:\ns*:\nç”±ä¸Šè¿°ç®—æ³•å³å¯å¾—åˆ°NFAï¼Œå…·æœ‰ä¸‹åˆ—æ€§è´¨ï¼š\nN(r)çš„çŠ¶æ€æ•°æœ€å¤šæ˜¯rä¸­ç¬¦å·å’Œç®—ç¬¦æ€»æ•°çš„ä¸¤å€ N(r)åªæœ‰ä¸€ä¸ªæ¥å—çŠ¶æ€ï¼Œæ¥å—çŠ¶æ€æ²¡æœ‰å‘å¤–çš„è½¬æ¢ ç”±NFAå³å¯æ„é€ å‡ºDFA:ä»æ¯ä¸ªNFAæ„é€ æ—¶çš„iæ„æˆçš„é›†åˆå‡ºå‘ï¼Œé€šè¿‡ä¸åŒçš„è¾“å…¥ç¬¦å·æ„é€ å‡ºçŠ¶æ€è½¬ç§»è¡¨ï¼Œæ¯ä¸ªçŠ¶æ€åŒ…å«å¤šä¸ªNFAä¸­çš„çŠ¶æ€ã€‚\nDFAçš„åŒ–ç®€ï¼šå…ˆä»ç»ˆæ€é›†åˆå’Œéç»ˆæ€é›†åˆå‡ºå‘ï¼Œå¦‚æœä»éç»ˆæ€é›†åˆè¾“å…¥å­—ç¬¦å¾—åˆ°çš„è¾“å‡ºé›†åˆä¸å±äºä»»ä½•ä¸€ä¸ªåˆ†å‰²åçš„é›†åˆçš„å­é›†ï¼Œåˆ™å¯ä»¥ç»§ç»­åˆ†å‰²ï¼Œå¦åˆ™åˆ†å‰²åœæ­¢ï¼Œæœ€åå¯ä»¥å¾—åˆ°åŒ–ç®€åçš„DFAã€‚\n2.è¯­æ³•åˆ†æ\r2.1 ä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•\rè¯­æ³•åˆ†æçš„ç›®çš„æ˜¯æ•™ä¼šè®¡ç®—æœºåˆ¤æ–­è¾“å…¥åˆæ³•æ€§ã€‚\nä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•(CFG)å°±æ˜¯è¯´è¿™ä¸ªæ–‡æ³•ä¸­æ‰€æœ‰çš„äº§ç”Ÿå¼å·¦è¾¹åªæœ‰ä¸€ä¸ªéç»ˆç»“ç¬¦ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œåªè¦æ‰¾åˆ°ç¬¦åˆäº§ç”Ÿå¼å³è¾¹çš„ä¸²ï¼Œå°±å¯ä»¥æŠŠå®ƒå½’çº¦ä¸ºå¯¹åº”çš„éç»ˆç»“ç¬¦ã€‚\n$$\r(V_T,V_N,S,P)\r$$ VTæ˜¯ç»ˆç»“ç¬¦é›†åˆï¼Œç»ˆç»“ç¬¦æ˜¯æ–‡æ³•æ‰€å®šä¹‰çš„è¯­è¨€çš„åŸºæœ¬ç¬¦å·ï¼Œå³token VNæ˜¯éç»ˆç»“ç¬¦é›†åˆï¼Œéç»ˆç»“ç¬¦è¡¨ç¤ºè¯­æ³•æˆåˆ†çš„ç¬¦å·ï¼Œå­˜æ”¾ä¸­é—´ç»“æœï¼Œä¹Ÿç§°ä¸ºè¯­æ³•å˜é‡ã€‚ Sæ˜¯å¼€å§‹ç¬¦å·ï¼Œå±äºéç»ˆç»“ç¬¦ï¼Œæ˜¯è¯¥æ–‡æ³•ä¸­æœ€å¤§çš„è¯­æ³•æˆåˆ†ï¼Œåˆ†æå¼€å§‹çš„åœ°æ–¹ã€‚ Pæ˜¯äº§ç”Ÿå¼é›†åˆï¼Œäº§ç”Ÿå¼æè¿°äº†å°†ç»ˆç»“ç¬¦å’Œéç»ˆç»“ç¬¦ç»„åˆæˆä¸²çš„æ–¹æ³•ã€‚ ç»ˆç»“ç¬¦é›†åˆä¸éç»ˆç»“ç¬¦é›†åˆçš„äº¤é›†ä¸ºç©ºã€‚\næ¨å¯¼ï¼šæ˜¯ä»æ–‡æ³•æ¨å‡ºæ–‡æ³•æ‰€æè¿°çš„è¯­è¨€ä¸­æ‰€åŒ…å«çš„åˆæ³•ä¸²é›†åˆçš„åŠ¨ä½œã€‚\nä¹Ÿå°±æ˜¯æŠŠç¬¦å·ä¸²ä¸­çš„éç»ˆç»“ç¬¦ç”¨å…¶äº§ç”Ÿå¼å³éƒ¨çš„ä¸²æ¥ä»£æ›¿ï¼Œæœ‰æœ€å·¦æ¨å¯¼ä¸æœ€å³æ¨å¯¼ç­‰å¤šç§æ–¹å¼ã€‚\nCFGä¸æ­£åˆ™è¡¨è¾¾å¼çš„è”ç³»å’ŒåŒºåˆ«ï¼š\næ­£åˆ™è¡¨è¾¾å¼å¯ä»¥å®šä¹‰ä¸€äº›ç®€å•çš„è¯­è¨€ï¼Œèƒ½è¡¨ç¤ºç»™å®šç»“æ„çš„å›ºå®šæ¬¡æ•°çš„é‡å¤æˆ–è€…æ²¡æœ‰æŒ‡å®šæ¬¡æ•°çš„é‡å¤ï¼Œä½†ä¸èƒ½ç”¨äºæè¿°é…å¯¹æˆ–åµŒå¥—çš„ç»“æ„ï¼Œå› ä¸ºæœ‰é™è‡ªåŠ¨æœºæ— æ³•è®°å½•è®¿é—®åŒä¸€çŠ¶æ€çš„æ¬¡æ•°ï¼›\nå®ƒä»¬ä¸¤ä¸ªéƒ½èƒ½è¡¨ç¤ºè¯­è¨€ï¼Œèƒ½ç”¨æ­£åˆ™è¡¨è¾¾å¼è¡¨ç¤ºçš„è¯­è¨€éƒ½èƒ½ç”¨CFGè¡¨ç¤ºã€‚\næ–‡æ³•çš„äºŒä¹‰æ€§ï¼šæ–‡æ³•çš„æŸäº›å¥å­å­˜åœ¨ä¸æ­¢ä¸€ç§æœ€å·¦(æœ€å³)æ¨å¯¼ï¼Œ æˆ–è€…ä¸æ­¢ä¸€æ£µåˆ†ææ ‘ï¼Œåˆ™è¯¥æ–‡æ³•æ˜¯äºŒä¹‰çš„ã€‚\näº§ç”ŸåŸå› ï¼šæœ‰äº›æ“ä½œéƒ½æ˜¯å·¦ï¼ˆå³ï¼‰ç»“åˆçš„ï¼Œä½†ä¸åŒçš„ä¼˜å…ˆçº§åœ¨æ–‡æ³•ä¸­æ²¡æœ‰è¡¨è¾¾å‡ºæ¥ã€‚\næ¶ˆé™¤åŠæ³•ï¼šå®šä¹‰è¿ç®—ä¼˜å…ˆçº§å’Œç»“åˆå¾‹ã€‚\n2.2 è‡ªé¡¶å‘ä¸‹åˆ†ææ–¹æ³•\rè‡ªé¡¶å‘ä¸‹ï¼šé’ˆå¯¹è¾“å…¥ä¸²ï¼Œä»æ–‡æ³•çš„å¼€å§‹ç¬¦å·å‡ºå‘ï¼Œå°è¯•æ ¹æ®äº§ç”Ÿå¼è§„åˆ™æ¨å¯¼ï¼ˆderiveï¼‰å‡ºè¯¥è¾“å…¥ä¸²ã€‚\nè‡ªåº•å‘ä¸Šï¼šé’ˆå¯¹è¾“å…¥ä¸²ï¼Œå°è¯•æ ¹æ®äº§ç”Ÿå¼è§„åˆ™å½’çº¦ï¼ˆreduceï¼‰åˆ°æ–‡æ³•çš„å¼€å§‹ç¬¦å·ã€‚\n2.2.1 é€’å½’ä¸‹é™è¯­æ³•åˆ†æ\ræ•°æ®ç»“æ„ï¼šä¸€ä¸ªè¾“å…¥ç¼“å†²åŒºå’Œå‘å‰çœ‹æŒ‡é’ˆlookahead\nåˆ†æè¿‡ç¨‹ï¼šè‡ªå·¦å‘å³æ‰«æè¾“å…¥ä¸²ï¼Œè®¾è®¡ä¸€ä¸ªè¾…åŠ©è¿‡ç¨‹match()ï¼Œå°†lookaheadæŒ‡å‘çš„ä½ç½®ä¸äº§ç”Ÿå¼è¿­ä»£ç”Ÿæˆçš„ç»ˆç»“ç¬¦è¿›è¡ŒåŒ¹é…ï¼Œå¦‚åŒ¹é…ï¼Œå°†lookaheadæŒªåˆ°ä¸‹ä¸€ä¸ªä½ç½®ï¼Œä¸ºæ¯ä¸€ä¸ªéç»ˆç»“ç¬¦å†™ä¸€ä¸ªåˆ†æè¿‡ç¨‹ã€‚\n2.2.2 æ¶ˆé™¤å·¦é€’å½’ï¼Œæå–å·¦å…¬å› å­\rS-\u0026gt;Sa|bè¿™æ ·çš„æ–‡æ³•æ˜¯å·¦é€’å½’çš„ï¼Œè€Œè‡ªé¡¶å‘ä¸‹åˆ†ææ–¹æ³•æ— æ³•å¤„ç†å·¦é€’å½’ï¼Œå› ä¸ºåœ¨è¾“å…¥ç¼“å†²åŒºçš„lookaheadæŒ‡é’ˆçº¹ä¸æœªåŠ¨ã€‚\næ¶ˆé™¤å®ä¾‹ï¼š\n1 2 3 4 5 ç›´æ¥å·¦é€’å½’ï¼š A-\u0026gt;Aa|b æ¶ˆé™¤ç›´æ¥å·¦é€’å½’ï¼š A-\u0026gt;bA\u0026#39; A\u0026#39;-\u0026gt;aA\u0026#39;|Îµ 1 2 3 4 5 6 7 8 9 10 éç›´æ¥å·¦é€’å½’ï¼š S-\u0026gt;Aa|b A-\u0026gt;Sd|Îµ å…ˆå˜æ¢æˆç›´æ¥å·¦é€’å½’ï¼š S-\u0026gt;Aa|b A-\u0026gt;Aad|bd|Îµ å†æ¶ˆé™¤å·¦é€’å½’ï¼š S-\u0026gt;Aa|b A-\u0026gt;bdA\u0026#39;|A\u0026#39; A\u0026#39;-\u0026gt;adA\u0026#39;|Îµ æå–å·¦å…¬å› å­å…¶å®ä¹Ÿå°±æ˜¯æ¶ˆé™¤å›æº¯ï¼š\n1 2 3 4 A-\u0026gt;aB1|aB2|aB3|B4 æ”¹ä¸ºï¼š A-\u0026gt;aA\u0026#39;|B4 A\u0026#39;-\u0026gt;B1|B2|B3 2.3 ll(1)æ–‡æ³•\rä¸¤ä¸ªå’Œæ–‡æ³•æœ‰å…³çš„å‡½æ•°ï¼š\n$$\rFIRST(Î±)=\\{a|a=\u003e*a...,aâˆˆV_T\\}\r$$è¡¨ç¤ºå¯ä»aæ¨å¯¼å¾—åˆ°çš„ä¸²çš„é¦–ç¬¦å·çš„é›†åˆï¼Œå…·ä½“è®¡ç®—æ—¶ä»å·¦å‘å³çœ‹ï¼Œæ‰¾äº§ç”Ÿå¼ç¬¬ä¸€ä¸ªç»ˆç»“ç¬¦ï¼Œè‹¥ä¸ºéç»ˆç»“ç¬¦åˆ™åœ¨å…¶äº§ç”Ÿå¼ä¸­æ‰¾ã€‚\n$$\rFOLLOW(A)=\\{a|S=\u003e*...Aa...,aâˆˆV_T\\}\r$$è¡¨ç¤ºå¯èƒ½åœ¨æ¨å¯¼è¿‡ç¨‹ä¸­ç´§è·Ÿåœ¨Aå³è¾¹çš„ç»ˆç»“ç¬¦å·çš„é›†åˆï¼Œè®¡ç®—æ–¹æ³•ï¼š\næ–‡æ³•å¼€å§‹ç¬¦æ·»åŠ $ï¼Œæœ‰ä¸‹é¢ä¸¤ç§æƒ…å†µï¼š\nA-\u0026gt;aB å³Båä¸ºç©ºï¼Œç›´æ¥å°†FOLLOW(A)åŠ å…¥åˆ°FOLLOW(B)ä¸­ï¼› A-\u0026gt;aBb å³Båéç©ºï¼Œè‹¥bä¸ºç»ˆç»“ç¬¦ï¼Œç›´æ¥æ·»åŠ ï¼›è‹¥bä¸ºéç»ˆç»“ç¬¦ï¼Œåˆ™å°†FIRST(b)ä¸­çš„é™¤Îµæ·»åŠ åˆ°FOLLOW(B)ä¸­,è‹¥FIRST(b)ä¸­å«æœ‰Îµï¼Œåˆ™ä¹ŸæŠŠFOLLOW(A)åŠ åˆ°FOLLOW(B)ä¸­ æ³¨æ„FIRSTé›†åˆå’ŒFOLLOWé›†åˆéƒ½æ˜¯é’ˆå¯¹éç»ˆç»“ç¬¦çš„ï¼Œä¸”FIRSTé›†åˆä¸­åªä¼šå‡ºç°ç»ˆç»“ç¬¦å’ŒÎµ\nan example:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 E-\u0026gt;TE\u0026#39; E\u0026#39;-\u0026gt;+TE\u0026#39;|Îµ T-\u0026gt;FT\u0026#39; T\u0026#39;-\u0026gt;*FT\u0026#39;|Îµ F-\u0026gt;(E)|id FIRST(E)=FIRST(T)=FIRST(F)={(,id} FIRST(E\u0026#39;)={+,Îµ} FIRST(T\u0026#39;)={*,Îµ} FOLLOW(E)={),$} FOLLOW(E\u0026#39;)=FOLLOW(E) FOLLOW(T)=FIRST(E\u0026#39;)-{Îµ}+FOLLOW(E\u0026#39;)={+,),$} FOLLOW(T\u0026#39;)=FOLLOW(T) FOLLOW(F)=FIRST(T\u0026#39;)-{Îµ}+FOLLOW(T\u0026#39;)={*,+,),$} ll(1)æ–‡æ³•çš„æ€§è´¨ï¼šæ²¡æœ‰å…¬å…±å·¦å› å­ï¼Œä¸æ˜¯äºŒä¹‰çš„ï¼Œä¸å«å·¦é€’å½’\nç”±FIRSTé›†ä¸FOLLOWé›†å¯ä»¥å¾—å‡ºLL(1)é¢„æµ‹åˆ†æè¡¨ï¼š\nè¡Œä¸ºéç»ˆç»“ç¬¦ï¼Œåˆ—ä¸ºç»ˆç»“ç¬¦åŠ ä¸Š$ï¼Œæ¯ä¸ªå•å…ƒéƒ½æ˜¯äº§ç”Ÿå¼ï¼Œä»ä»¥ä¸Šé¢ä¾‹å­ä¸ºä¾‹ï¼š\nid + * ( ) $ E E-\u0026gt;TE' E-\u0026gt;TE' E' E\u0026rsquo;-\u0026gt;+TE' E\u0026rsquo;-\u0026gt;Îµ E\u0026rsquo;-\u0026gt;Îµ T T-\u0026gt;FT' T-\u0026gt;FT' T' T\u0026rsquo;-\u0026gt;Îµ T\u0026rsquo;-\u0026gt;*FT' T\u0026rsquo;-\u0026gt;Îµ T\u0026rsquo;-\u0026gt;Îµ F F-\u0026gt;id F-\u0026gt;(E) æ„é€ è§„åˆ™ï¼šå¯¹æ–‡æ³•çš„æ¯ä¸ªäº§ç”Ÿå¼A-\u0026gt;Î±ï¼Œæœ‰å¦‚ä¸‹æ“ä½œï¼š\nå¯¹FIRST(Î±)çš„æ¯ä¸ªç»ˆç»“ç¬¦aï¼ŒæŠŠA-\u0026gt;Î±åŠ å…¥M[A,a] å¦‚æœÎµåœ¨FIRST(Î±)ä¸­ï¼Œå¯¹FOLLOW(A)çš„æ¯ä¸ªç»ˆç»“ç¬¦bï¼ˆåŒ…æ‹¬$ï¼‰ï¼ŒæŠŠA-\u0026gt;Î±åŠ å…¥M[A,b] 2.4 è‡ªåº•å‘ä¸Šåˆ†ææ–¹æ³•\r2.4.1 å½’çº¦\ræ¯ä¸€æ­¥ï¼Œç‰¹å®šå­ä¸²è¢«æ›¿æ¢ä¸ºç›¸åŒ¹é…çš„æŸä¸ªäº§ç”Ÿå¼å·¦éƒ¨çš„éç»ˆç»“ç¬¦ï¼Œæœ€ç»ˆï¼ŒæŠŠè¾“å…¥ä¸²å½’çº¦æˆæ–‡æ³•çš„å¼€å§‹ç¬¦å·ã€‚\nå½’çº¦æ˜¯æœ€å³æ¨å¯¼çš„é€†è¿‡ç¨‹ã€‚\n2.4.2 å¥æŸ„\rå¥æŸ„(Handles)æ˜¯æŒ‡å¯è§„çº¦ä¸²ï¼Œå’ŒæŸä¸ªäº§ç”Ÿå¼å³éƒ¨åŒ¹é…ã€‚\nå¥æŸ„çš„å³è¾¹ä»…å«ç»ˆç»“ç¬¦ï¼Œå¦‚æœæ–‡æ³•äºŒä¹‰ï¼Œé‚£ä¹ˆå¥æŸ„å¯èƒ½ä¸å”¯ä¸€ã€‚\n2.4.3 ç§»è¿›-å½’çº¦åˆ†ææ–¹æ³•\ræ ˆä¿å­˜å·²æ‰«æè¿‡çš„æ–‡æ³•ç¬¦å·ï¼Œç¼“å†²åŒºå­˜æ”¾è¿˜æœªåˆ†æçš„å…¶ä½™ç¬¦å·ï¼›\nç§»è¿›(shift)ï¼šå°†ä¸‹ä¸€ä¸ªè¾“å…¥ç¬¦å·æ”¾åˆ°æ ˆé¡¶ï¼Œä»¥å½¢æˆå¥æŸ„ï¼›\nå½’çº¦(reduce)ï¼šå°†å¥æŸ„æ›¿æ¢ä¸ºå¯¹åº”çš„äº§ç”Ÿå¼çš„å·¦éƒ¨éç»ˆç»“ç¬¦ï¼›\næ¥å—(accept)ï¼šåˆ†ææˆåŠŸï¼›\næŠ¥é”™(error)ï¼šå‘ç°è¯­æ³•é”™è¯¯ã€‚\n$$\rE-\u003eE+E|E*E|(E)|id\r$$ stack input action $ id*id+id$ ç§»è¿› $id *id+id$ æŒ‰E-\u0026gt;idè§„çº¦ $E *id+id$ ç§»è¿› $E* id+id$ ç§»è¿› $E*id +id$ æŒ‰E-\u0026gt;idè§„çº¦ $E*E +id$ ç§»è¿› $E*E+ id$ ç§»è¿› $E*E+id $ æŒ‰E-\u0026gt;idè§„çº¦ $E*E+E $ æŒ‰E-\u0026gt;E+Eè§„çº¦ $E*E $ æŒ‰E-\u0026gt;E*Eè§„çº¦ $E $ æ¥å— ä¸¤ç±»å†²çªï¼š\nç§»è¿›-å½’çº¦å†²çªï¼šè§£æå™¨æ— æ³•ç¡®å®šå½“å‰çš„è¾“å…¥æ˜¯å¦åº”è¯¥ä½œä¸ºä¸€ä¸ªç»ˆç»“ç¬¦è¿›è¡Œç§»è¿›ï¼Œè¿˜æ˜¯åº”è¯¥ä½œä¸ºä¸€ä¸ªéç»ˆç»“ç¬¦è¿›è¡Œå½’çº¦ã€‚æ¯”å¦‚E-\u0026gt;A|Aaï¼Œå¦‚æœæ­¤æ—¶stackä¸ºAï¼Œinputä¸ºa\u0026hellip;$ï¼Œæ­¤æ—¶æ— æ³•åˆ¤æ–­è¿›è¡Œç§»è¿›è¿˜æ˜¯è§„çº¦ã€‚ å½’çº¦-å½’çº¦å†²çªï¼šåœ¨è§£æè¿‡ç¨‹ä¸­ï¼Œè§£æå™¨é¢å¯¹å¤šä¸ªä¸åŒçš„äº§ç”Ÿå¼è§„åˆ™å¯ä»¥åº”ç”¨ï¼Œä½†è¿™äº›äº§ç”Ÿå¼è§„åˆ™çš„ç›®æ ‡ç¬¦å·æ˜¯ç›¸åŒçš„ï¼Œæ— æ³•ç¡®å®šåº”è¯¥åº”ç”¨å“ªä¸ªäº§ç”Ÿå¼ã€‚æ¯”å¦‚E-\u0026gt;a(B)|a,C-\u0026gt;aï¼Œå¦‚æœæ­¤æ—¶stackä¸º\u0026hellip;a(aï¼Œinputä¸º,a)\u0026hellip;$ï¼Œæ­¤æ—¶æ— æ³•åˆ¤æ–­è§„çº¦åˆ°å“ªä¸€ä¸ªã€‚ 2.5 LRæ–‡æ³•\r2.5.1 SLRåˆ†æ\ræ´»å‰ç¼€ï¼ˆå¯è¡Œå‰ç¼€ï¼‰æ˜¯æŒ‡åœ¨è§£æè¿‡ç¨‹ä¸­ï¼Œè§£æå™¨å½“å‰å¤„ç†çš„è¾“å…¥ä¸²çš„ä¸€éƒ¨åˆ†ï¼Œå¹¶ä¸”è¯¥éƒ¨åˆ†åœ¨å½“å‰çŠ¶æ€ä¸‹çš„æ‰€æœ‰å¯èƒ½åç»­æ‰©å±•ä¸­éƒ½ä¸åŒ…å«ä»»ä½•äº§ç”Ÿå¼è§„åˆ™çš„å·¦éƒ¨ï¼ˆå³äº§ç”Ÿå¼çš„å·¦ç¬¦å·ï¼‰ã€‚\næ´»å‰ç¼€ç”¨äºè§£å†³ç§»è¿›-å½’çº¦å†²çªã€‚\nLRåˆ†ææ–¹æ³•çš„ç‰¹ç‚¹ï¼šæ ˆä¸­çš„æ–‡æ³•ç¬¦å·æ€»æ˜¯å½¢æˆä¸€ä¸ªæ´»å‰ç¼€ï¼›åˆ†æè¡¨çš„è½¬ç§»å‡½æ•°æœ¬è´¨ä¸Šæ˜¯è¯†åˆ«æ´»å‰ç¼€çš„DFA\nLR(0)é¡¹ç›®ï¼šåœ¨å³éƒ¨çš„æŸä¸ªåœ°æ–¹åŠ ç‚¹çš„äº§ç”Ÿå¼ï¼ŒåŠ ç‚¹çš„ç›®çš„æ˜¯ç”¨æ¥è¡¨ç¤ºåˆ†æè¿‡ç¨‹ä¸­çš„çŠ¶æ€ã€‚\nå¢å¹¿æ–‡æ³•ï¼ˆæ‹“å¹¿æ–‡æ³•ï¼‰ï¼šå¼€å§‹ç¬¦EåŠ ä¸ŠE\u0026rsquo;-\u0026gt;Eã€‚ã€\n$$\rE-\u003eE+T|T\\\\\rT-\u003eT*F|F\\\\\rF-\u003e(E)|id\r$$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 é¦–å…ˆæ‹“å¹¿æ–‡æ³•ï¼š E\u0026#39;-\u0026gt;E E-\u0026gt;E+T|T T-\u0026gt;T*F|F F-\u0026gt;(E)|id æ„é€ LR(0)é¡¹ç›®é›†è§„èŒƒæ—ï¼š I0: E\u0026#39;-\u0026gt;Â·E----------------è¿™ä¸ªæ‹“å¹¿å¾—æ¥çš„æ˜¯åˆå§‹é¡¹ç›®ï¼Œä¸‹é¢éƒ½æ˜¯æ±‚é—­åŒ…å¾—æ¥çš„ E-\u0026gt;Â·E+T E-\u0026gt;Â·T T-\u0026gt;Â·T*F T-\u0026gt;Â·F F-\u0026gt;Â·(E) F-\u0026gt;Â·id è¿™é‡Œçš„æ¯ä¸ªIæ„é€ è§„åˆ™ï¼šå¦‚æœç‚¹åæ˜¯äº§ç”Ÿå¼A-\u0026gt;aï¼Œä¸”A-\u0026gt;Â·aä¸åœ¨é—­åŒ…ä¸­ï¼ŒåŠ å…¥ã€‚\näººè¯ï¼šç‚¹åé¢å¦‚æœæ˜¯äº§ç”Ÿå¼å°±æŠŠäº§ç”Ÿå¼ä»å¤´åŠ ä¸ªç‚¹æ·»åŠ åˆ°é¡¹ç›®é›†ä¸­ï¼Œå•ä¸ªé¡¹ç›®é›†ä¸­é‡å¤çš„ä¸ç®—ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 æˆ‘ä»¬å¯ä»¥å¾—åˆ°å…¶ä½™çš„é¡¹ç›®é›†ï¼ˆé€šè¿‡ç§»è¿›ç‚¹åé¢çš„ç»ˆç»“ç¬¦æˆ–éç»ˆç»“ç¬¦ï¼‰ï¼š I0--E--\u0026gt;I1: E\u0026#39;-\u0026gt;EÂ· E-\u0026gt;EÂ·+T I0--T--\u0026gt;I2: E-\u0026gt;TÂ· T-\u0026gt;TÂ·*F I0--F--\u0026gt;I3: T-\u0026gt;FÂ· I0--(--\u0026gt;I4: F-\u0026gt;(Â·E) E-\u0026gt;Â·E+T E-\u0026gt;Â·T T-\u0026gt;Â·T*F T-\u0026gt;Â·F F-\u0026gt;Â·(E) F-\u0026gt;Â·id I0--id--I5ï¼š F-\u0026gt;idÂ· I1--+--\u0026gt;I6: E-\u0026gt;E+Â·T T-\u0026gt;Â·T*F T-\u0026gt;Â·F F-\u0026gt;Â·(E) F-\u0026gt;Â·id I2--*--\u0026gt;I7: T-\u0026gt;T*Â·F F-\u0026gt;Â·(E) F-\u0026gt;Â·id I4--E--\u0026gt;I8: F-\u0026gt;(EÂ·) E-\u0026gt;EÂ·+T I6--T--\u0026gt;I9: E-\u0026gt;E+TÂ· T-\u0026gt;TÂ·*F I7--F--\u0026gt;I10: T-\u0026gt;T*FÂ· I8--)--\u0026gt;I11: F-\u0026gt;(E)Â· è¿™11ä¸ªé¡¹ç›®é›†ç»„æˆäº†DFAçš„çŠ¶æ€ï¼Œå¯æ„é€ å‡ºå¦‚ä¸‹çš„DFAï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 graph LR a((I_0))--E--\u0026gt;b((I_1)) b((I_1))--+--\u0026gt;c((I_6)) c((I_6))--T--\u0026gt;d((I_9)) a((I_0))--T--\u0026gt;e((I_2)) a((I_0))--F--\u0026gt;F((I_3)) a((I_0))--(--\u0026gt;G((I_4)) a((I_0))--id--\u0026gt;H((I_5)) e((I_2))--*--\u0026gt;I((I_7)) I((I_7))--F--\u0026gt;J((I_10)) G((I_4))--E--\u0026gt;K((I_8)) K((I_8))--)--\u0026gt;L((I_11)) c((I_6))--F--\u0026gt;F((I_3)) c((I_6))--(--\u0026gt;G((I_4)) c((I_6))--id--\u0026gt;H((I_5)) I((I_7))--(--\u0026gt;G((I_4)) I((I_7))--id--\u0026gt;H((I_5)) K((I_8))--+--\u0026gt;c((I_6)) G((I_4))--(--\u0026gt;G((I_4)) G((I_4))--T--\u0026gt;e((I_2)) G((I_4))--F--\u0026gt;F((I_3)) G((I_4))--id--\u0026gt;H((I_5)) d((I_9))--*--\u0026gt;I((I_7)) mermaidç”»çš„ï¼Œæœ‰ç‚¹æŠ½è±¡å“ˆQAQ\nç”±ä¸Šé¢çš„DFAå¯æ„é€ å‡ºSLRåˆ†æè¡¨ï¼Œè§„åˆ™å¦‚ä¸‹ï¼š\nå¦‚æœA-\u0026gt;Î±Â·aÎ²åœ¨Iiä¸­ï¼Œå¹¶ä¸”goto(Ii,a)=Ijï¼Œå°†action[i,a]ç½®ä¸ºsj å¦‚æœA-\u0026gt;Î±Â·åœ¨Iiä¸­ï¼Œå¯¹FOLLOW(A)ä¸­æ‰€æœ‰aï¼Œç½®action[i,a]ä¸ºrjï¼Œjæ˜¯äº§ç”Ÿå¼A-\u0026gt;Î±çš„åˆå§‹ç¼–å· å¦‚æœS\u0026rsquo;-\u0026gt;SÂ·åœ¨Iiä¸­ï¼Œç½®action[i,$]ä¸ºacc åœ¨è¿™ä¸ªè§„åˆ™ä¸­sè¡¨ç¤ºç§»è¿›ï¼Œrè¡¨ç¤ºè§„çº¦ï¼Œå¯ä»¥çœ‹å‡ºï¼Œå¦‚æœä¸€ä¸ªIiä¸­åŒæ—¶å­˜åœ¨Â·åœ¨æœ«å°¾ä¸åœ¨ä¸­é—´çš„æƒ…å†µæ—¶ï¼Œä¼šå‡ºç°action[i,a]åŒæ—¶ç½®ä¸ºrjä¸sjçš„æƒ…å†µï¼Œä¹Ÿå°±æ˜¯ç§»è¿›-å½’çº¦å†²çªï¼Œæ­¤æ—¶æ¯”è¾ƒä¸¤ä¸ªå·¦å¼çš„FOLLOWé›†ï¼Œå¦‚æœä¸‹ä¸€ä¸ªè¾“å…¥ç¬¦å·å±äºå½’çº¦çš„é‚£ä¸ªå·¦å¼çš„FOLLOWé›†ï¼Œé‚£ä¹ˆä½¿ç”¨å½’çº¦ï¼Œåä¹‹ä½¿ç”¨ç§»è¿›ã€‚æ¯”å¦‚è¯¥é¢˜çš„I2å’ŒI9å°±å­˜åœ¨ç§»è¿›å½’çº¦å†²çªï¼Œä½†è®¡ç®—FOLLOW(E)={),+,$},I2å’ŒI9çš„ä¸‹ä¸€ä¸ªç¬¦å·ä¸º*ï¼Œä¸åœ¨FOLLOW(E)ä¸­ï¼Œæ‰€ä»¥å‡é‡‡ç”¨ç§»è¿›ã€‚\nè¯¥ä¾‹çš„SLRåˆ†æè¡¨å¦‚ä¸‹æ‰€ç¤ºï¼š\n(1)E-\u0026gt;E+T\n(2)E-\u0026gt;T\n(3)T-\u0026gt;T*F\n(4)T-\u0026gt;F\n(5)F-\u0026gt;(E)\n(6)F-\u0026gt;id\nid + * ( ) $ E T F 0 s5 s4 1 2 3 1 s6 acc 2 r2 s7 r2 r2 3 r4 r4 r4 r4 4 s5 s4 8 2 3 5 r6 r6 r6 r6 6 s5 s4 9 3 7 s5 s4 10 8 s6 s11 9 r1 s7 r1 r1 10 r3 r3 r3 r3 11 r5 r5 r5 r5 2.5.2 LRåˆ†æ\rSLRæ–‡æ³•äº§ç”Ÿç§»è¿›å½’çº¦å†²çªï¼Œä½†è¯¥æ–‡æ³•ä¸æ˜¯äºŒä¹‰çš„ã€‚\nåœ¨è¯†åˆ«æ´»å‰ç¼€DFAçš„çŠ¶æ€ä¸­ï¼Œå¢åŠ ä¿¡æ¯ï¼Œæ’é™¤ä¸€äº›ä¸æ­£ç¡®çš„å½’çº¦æ“ä½œã€‚\nSLRåªæ˜¯ç®€å•åœ°è€ƒå¯Ÿä¸‹ä¸€ä¸ªè¾“å…¥ç¬¦å·bæ˜¯å¦å±äºä¸å½’çº¦é¡¹ç›®Aâ†’Î±ç›¸å…³è”çš„FOLLOW(A)ï¼Œä½†bâˆˆFOLLOW(A)åªæ˜¯å½’çº¦Î±çš„ä¸€ä¸ªå¿…è¦æ¡ä»¶ï¼Œè€Œéå……åˆ†æ¡ä»¶ã€‚å½’çº¦æ¡ä»¶è¢«æ”¾å®½æ¾äº†ã€‚\né¡¹ç›®é›†ï¼šLR(0)=\u0026gt;LR(1)\nLR(1)é¡¹ç›®ç”±ä¸¤ä¸ªåˆ†é‡ç»„æˆï¼Œç¬¬ä¸€åˆ†é‡ä¸ºSLRä¸­çš„é¡¹ï¼Œç¬¬äºŒåˆ†é‡ä¸ºæœç´¢ç¬¦ï¼ˆå‘å‰çœ‹ç¬¦å·ï¼‰ï¼Œ1ä»£è¡¨äº†æœç´¢ç¬¦açš„é•¿åº¦ã€‚\nå¯¹äº[A-\u0026gt;Î±Â·Î²,a]å½“Î²ä¸ä¸ºç©ºæ—¶ï¼Œaä¸èµ·ä½œç”¨ï¼Œå½“Î²ä¸ºç©ºæ—¶ï¼Œå¦‚æœä¸‹ä¸€ä¸ªè¾“å…¥ç¬¦å·æ˜¯aï¼Œå°†æŒ‰ç…§A-\u0026gt;Î±è¿›è¡Œå½’çº¦ï¼Œaçš„é›†åˆæ˜¯FOLLOW(A)çš„å­é›†ã€‚\nLR(1)é—­åŒ…è®¡ç®—æ–¹æ³•ä¸LR(0)æœ‰æ‰€ä¸åŒï¼Œè‹¥æœ‰é¡¹ç›®[A-\u0026gt;Î±Â·BÎ²,a]åœ¨é—­åŒ…ä¸­ï¼Œè€ŒB-\u0026gt;Î³æ˜¯æ–‡æ³•ä¸­çš„äº§ç”Ÿå¼ï¼Œbæ˜¯FIRST(Î²a)ä¸­çš„å…ƒç´ ï¼Œåˆ™[B-\u0026gt;Î³ï¼Œb]ä¹Ÿå±äºé—­åŒ…ã€‚\n$$\r0)S'-\u003eS\\\\\r1)S-\u003eL=R\\\\\r2)S-\u003eR\\\\\r3)L-\u003e*R\\\\\r4)L-\u003eid\\\\\r5)R-\u003eL\r$$ åˆ™å¯ä»¥å¾—åˆ°å¦‚ä¸‹æ‰€ç¤ºçš„LR(1)é¡¹ç›®é›†è§„èŒƒæ—ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 I0: S\u0026#39;-\u0026gt;Â·S,$-----S\u0026#39;çš„æœç´¢ç¬¦ä¸€å®šæ˜¯$,å› ä¸ºS\u0026#39;è¡¨ç¤ºè§„çº¦åˆ°äº†æœ€å,FIRST($)=$ S-\u0026gt;Â·L=R,$---------FIRST(=R$)=\u0026#34;=\u0026#34;[å¯¹äºL] S-\u0026gt;Â·R,$-----------FIRST($)=$[å¯¹äºR] L-\u0026gt;Â·*R,= L-\u0026gt;Â·id,= R-\u0026gt;Â·L,$-----------FIRST($)=$[å¯¹äºL] L-\u0026gt;Â·*R,$ L-\u0026gt;Â·id,$ I0--S--\u0026gt;I1: S\u0026#39;-\u0026gt;SÂ·,$ I0--L--\u0026gt;I2: S-\u0026gt;LÂ·=R,$ R-\u0026gt;LÂ·,$ I0--R--\u0026gt;I3: S-\u0026gt;RÂ·,$ I0--*--\u0026gt;I4: L-\u0026gt;*Â·R,=-----------FIRST(=)=\u0026#34;=\u0026#34;[å¯¹äºR] L-\u0026gt;*Â·R,$-----------FIRST($)=$[å¯¹äºR] R-\u0026gt;Â·L,=------------FIRST(=)=\u0026#34;=\u0026#34;[å¯¹äºL] R-\u0026gt;Â·L,$------------FIRST($)=$[å¯¹äºL] L-\u0026gt;Â·*R,= L-\u0026gt;Â·*R,$ L-\u0026gt;Â·id,= L-\u0026gt;Â·id,$ I4--id--\u0026gt;I5: L-\u0026gt;idÂ·,= L-\u0026gt;idÂ·,$ I2--=--\u0026gt;I6: S-\u0026gt;L=Â·R,$----------FIRST($)=$[å¯¹äºR] R-\u0026gt;Â·L,$------------FIRST($)=$[å¯¹äºL] L-\u0026gt;Â·*R,$ L-\u0026gt;Â·id,$ I4--R--\u0026gt;I7: L-\u0026gt;*RÂ·,= L-\u0026gt;*RÂ·,$ I4--L--\u0026gt;I8: R-\u0026gt;LÂ·,= R-\u0026gt;LÂ·,$ I6--R--\u0026gt;I9: S-\u0026gt;L=RÂ·,$ I6--L--\u0026gt;I10: R-\u0026gt;LÂ·,$ I6--*--\u0026gt;I11: L-\u0026gt;*Â·R,$------------FIRST($)=$[å¯¹äºR] R-\u0026gt;Â·L,$-------------FIRST($)=$[å¯¹äºL] L-\u0026gt;Â·*R,$ L-\u0026gt;Â·id,$ I6--id--\u0026gt;I12: L-\u0026gt;idÂ·,$ I11--R--\u0026gt;I13: L-\u0026gt;*RÂ·,$ å¦‚æœä¸€ä¸ªé¡¹ç›®ä¸­ä¸¤ä¸ªæˆ–å¤šä¸ªå¼å­åªæ˜¯æœç´¢ç¬¦ä¸åŒï¼Œå¯ä»¥å†™åœ¨ä¸€èµ·ï¼›å¦‚æœä¸¤ä¸ªé¡¹ç›®é™¤æœç´¢ç¬¦å¤–ç›¸åŒï¼Œåˆ™è¿™ä¸¤ä¸ªé¡¹ç›®é›†æ˜¯åŒå¿ƒçš„ã€‚\nDFAå¦‚ä¸‹ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 graph LR A((I_0))--S--\u0026gt;B((I_1)) A((I_0))--L--\u0026gt;C((I_2)) A((I_0))--R--\u0026gt;D((I_3)) A((I_0))--*--\u0026gt;E((I_4)) A((I_0))--id--\u0026gt;F((I_5)) C((I_2))--=--\u0026gt;G((I_6)) G((I_6))--R--\u0026gt;H((I_9)) G((I_6))--L--\u0026gt;I((I_10)) G((I_6))--*--\u0026gt;J((I_11)) G((I_6))--id--\u0026gt;K((I_12)) E((I_4))--R--\u0026gt;L((I_7)) E((I_4))--L--\u0026gt;M((I_8)) E((I_4))--id--\u0026gt;F((I_5)) E((I_4))--*--\u0026gt;E((I_4)) J((I_11))--R--\u0026gt;O((I_13)) J((I_11))--id--\u0026gt;K((I_12)) J((I_11))--L--\u0026gt;I((I_10)) J((I_11))--*--\u0026gt;J((I_11)) åˆ™æˆ‘ä»¬å¯ä»¥å¾—åˆ°å¦‚ä¸‹æ‰€ç¤ºçš„LR(1)åˆ†æè¡¨ï¼š\n* id = $ S L R 0 s4 s5 1 2 3 1 acc 2 s6 r5 3 r2 4 s4 s5 8 7 5 r4 r4 6 s11 s12 10 9 7 r3 r3 8 r5 r5 9 r1 10 r5 11 s11 s12 10 13 12 r4 13 r3 æ¯ä¸€ä¸ªSLR(1)æ–‡æ³•éƒ½æ˜¯LR(1)çš„ã€‚\n3.ä¸­é—´ä»£ç \r3.1 ä¸­é—´ä»£ç åˆ†æ\rç¼–è¯‘å™¨å‰ç«¯ä¸åç«¯åˆ†ç¦»ï¼Œè¿™æ ·ä¸ºæ–°æœºå™¨æ„å»ºç¼–è¯‘å™¨åªç”¨è®¾è®¡ä»ä¸­é—´ä»£ç åˆ°ç›®æ ‡æœºå™¨ä»£ç çš„ç¼–è¯‘å™¨å³å¯ï¼Œå¹¶ä¸”ä¸­é—´ä»£ç ä¼˜åŒ–ä¸æºè¯­è¨€å’Œç›®æ ‡æœºå™¨å‡æ— å…³ã€‚\nå¸¸è§çš„ä¸­é—´ä»£ç ç±»å‹ï¼š\nåç¼€è¡¨ç¤º è¯­æ³•æ ‘æˆ–DAGå›¾ ä¸‰åœ°å€ç ï¼ˆTAC) é™æ€å•èµ‹å€¼å½¢å¼ï¼ˆSSAï¼‰ åç¼€è¡¨ç¤ºä¸éœ€è¦æ‹¬å·ï¼Œä¾¿äºè®¡ç®—æœºå¤„ç†è¡¨è¾¾å¼ã€‚\nè¯­æ³•æ ‘æ˜¯ä¸€ç§å›¾å½¢åŒ–çš„ä¸­é—´è¡¨ç¤ºï¼ŒDAGæ˜¯æœ‰å‘æ— ç¯å›¾ï¼š\nä¸‰åœ°å€ä»£ç ï¼šx= y op zã€æœ€å¤šä¸€ä¸ªç®—ç¬¦ï¼Œæœ€å¤šä¸‰ä¸ªè®¡ç®—åˆ†é‡ï¼Œæ¯ä¸€ä¸ªåˆ†é‡ä»£è¡¨ä¸€ä¸ªåœ°å€ã€‘\nä¸‰åœ°å€ä»£ç æ˜¯è¯­æ³•æ ‘æˆ–DAGçš„ä¸€ç§çº¿æ€§è¡¨ç¤ºã€‚\nå¸¸ç”¨çš„ä¸‰åœ°å€è¯­å¥ï¼š\nè¿ç®—ã€èµ‹å€¼ï¼šx=y op z,\tx = op y,\tx = y æ— æ¡ä»¶è½¬ç§»ï¼šgoto L æ¡ä»¶è½¬ç§»ï¼šif x goto L,if False x goto L,if x relop y goto L è¿‡ç¨‹è°ƒç”¨ï¼šparam x1,param x2,call p ,n(å‰é¢è®¾ç½®å‚æ•°,pä¸ºå­è¿‡ç¨‹ï¼Œnä¸ºå‚æ•°) è¿‡ç¨‹è¿”å›ï¼šreturn y ç´¢å¼•èµ‹å€¼ï¼šx=y[i],x[i]=y åœ°å€å’ŒæŒ‡é’ˆï¼šx=\u0026amp;y,x=*y,*x=y é™æ€å•èµ‹å€¼å½¢å¼ï¼šå’Œä¸‰åœ°å€ä»£ç å·®ä¸å¤šï¼Œä½†æ‰€æœ‰èµ‹å€¼æŒ‡ä»¤éƒ½æ˜¯å¯¹ä¸åŒåå­—çš„å˜é‡çš„èµ‹å€¼ï¼ŒåŒä¸€ä¸ªå˜é‡åœ¨ä¸åŒæ§åˆ¶æµè·¯å¾„ä¸Šéƒ½è¢«å®šå€¼ã€‚\nåŸºæœ¬å—ï¼šé¦–æŒ‡ä»¤ï¼šæŒ‡ä»¤åºåˆ—çš„ç¬¬ä¸€æ¡ä¸‰åœ°å€æŒ‡ä»¤ï¼›ä»»æ„è½¬ç§»æŒ‡ä»¤çš„ç›®æ ‡æŒ‡ä»¤ï¼›ç´§è·Ÿä¸€ä¸ªè½¬ç§»æŒ‡ä»¤çš„æŒ‡ä»¤ã€‚ç”±é¦–æŒ‡ä»¤(leader)å¯ä»¥åˆ’åˆ†å‡ºåŸºæœ¬å—(basicblock)ã€‚\næµå›¾çš„èŠ‚ç‚¹æ˜¯ä¸€äº›åŸºæœ¬å—ï¼Œä»åŸºæœ¬å—Båˆ°åŸºæœ¬å—Cä¹‹é—´æœ‰ä¸€æ¡è¾¹ï¼Œå½“ä¸”ä»…å½“Cçš„ç¬¬ä¸€ä¸ªæŒ‡ä»¤å¯èƒ½ç´§è·Ÿåœ¨Bçš„æœ€åä¸€æ¡æŒ‡ä»¤ä¹‹åæ‰§è¡Œï¼Œç§°Bæ˜¯Cçš„å‰é©±(predecessor)ï¼ŒCæ˜¯Bçš„åç»§(successor)ã€‚\næµå›¾ä¸­çš„ä¸€ä¸ªç»“ç‚¹é›†åˆLæ˜¯ä¸€ä¸ªå¾ªç¯ï¼Œéœ€æ»¡è¶³ï¼šè¯¥é›†åˆæœ‰å”¯ä¸€çš„å…¥å£ç»“ç‚¹ï¼›é›†åˆç»“ç‚¹éƒ½æœ‰ä¸€ä¸ªåˆ°è¾¾å…¥å£ç»“ç‚¹çš„éç©ºè·¯å¾„ï¼Œä¸”è¯¥è·¯å¾„å…¨éƒ¨åœ¨Lä¸­ã€‚\n3.2 è¯­æ³•åˆ¶å¯¼ç¿»è¯‘\rç¼–è¯‘ç¨‹åºçš„ç›®æ ‡ï¼šå°†æºç¨‹åºç¿»è¯‘æˆä¸ºè¯­ä¹‰ç­‰ä»·çš„ç›®æ ‡ç¨‹åºï¼Œæºç¨‹åºä¸ç›®æ ‡ç¨‹åºå…·æœ‰ä¸åŒçš„è¯­æ³•ç»“æ„ï¼Œè¡¨è¾¾çš„ç»“æœå´æ˜¯ç›¸åŒçš„ã€‚\nè¯­æ³•åˆ¶å¯¼ç¿»è¯‘ï¼šä½¿ç”¨ä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•(CFG)æ¥å¼•å¯¼å¯¹è¯­è¨€çš„ç¿»è¯‘ï¼Œæ˜¯ä¸€ç§é¢å‘æ–‡æ³•çš„ç¿»è¯‘æŠ€æœ¯ã€‚é€šè¿‡ç»™è¯­æ³•æ ‘ä¸Šå„ä¸ªç¬¦å·èµ‹äºˆä¸€å®šçš„å«ä¹‰ï¼Œå¹¶ä¸”å°†å„ä¸ªç¬¦å·è¿›è¡Œæœ‰ç»“æ„çš„è¿æ¥ï¼Œå¯ä»¥å½¢æˆè¯­è¨€çš„å…·ä½“è¯­å¥çš„å«ä¹‰ã€‚è¿™ç»™äºˆæˆ‘ä»¬ä»¥å¯ç¤ºï¼šå¯ä»¥é€šè¿‡æ‰©å……æ–‡æ³•ï¼Œ åœ¨æ–‡æ³•ç¬¦å·ä¸Šé™„ç€æŸäº›è¯­ä¹‰ä¿¡æ¯ï¼Œå¹¶åœ¨è¿™äº›è¯­ä¹‰ä¿¡æ¯é—´å»ºç«‹ç›¸äº’è®¡ç®—å…³ç³»ï¼Œä»è€Œåœ¨è¯­æ³•åˆ†æçš„åŒæ—¶è¿›è¡Œè¯­ä¹‰åˆ†æã€‚ ç”±äºè¿™ç§åˆ†ææ˜¯åœ¨è¯­æ³•åˆ†æçš„æ§åˆ¶ä¸‹è¿›è¡Œçš„ï¼Œæ•…ç§°ä¸ºè¯­æ³•åˆ¶å¯¼ç¿»è¯‘ã€‚\nè¯­æ³•åˆ¶å¯¼å®šä¹‰ï¼ˆSSDï¼‰ï¼š\nåŸºç¡€çš„ä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•ï¼Œæ¯ä¸ªæ–‡æ³•ç¬¦å·æœ‰ä¸€ç»„å±æ€§ï¼Œæ¯ä¸ªæ–‡æ³•äº§ç”Ÿå¼A-\u0026gt;Î±æœ‰ä¸€ç»„å½¢å¼ä¸ºb=f(c1,c2,\u0026hellip;,ck)çš„è¯­ä¹‰è§„åˆ™ï¼Œå…¶ä¸­fæ˜¯å‡½æ•°ï¼Œbå’Œc1,c2,\u0026hellip;,ckæ˜¯è¯¥äº§ç”Ÿå¼æ–‡æ³•ç¬¦å·çš„å±æ€§ã€‚\nä¸¤ç§å±æ€§ï¼š\nç»¼åˆå±æ€§ï¼šç”¨äºè‡ªä¸‹è€Œä¸Šä¼ é€’ä¿¡æ¯ï¼›åœ¨è¯­æ³•æ ‘ä¸­ï¼Œä¸€ä¸ªç»“ç‚¹çš„ç»¼åˆå±æ€§ç”±å…¶å­ ç»“ç‚¹çš„å±æ€§å€¼ç¡®å®šï¼Œå› æ­¤ï¼Œé€šå¸¸ä½¿ç”¨è‡ªåº•å‘ä¸Šçš„æ–¹æ³•åœ¨æ¯ä¸€ä¸ªç»“ç‚¹å¤„ä½¿ç”¨è¯­ä¹‰è§„åˆ™è®¡ç®—ç»¼åˆå±æ€§çš„å€¼ã€‚ä»…ä»…ä½¿ç”¨ç»¼åˆå±æ€§çš„å±æ€§æ–‡æ³•ç§°S-å±æ€§æ–‡æ³•ã€‚ ç»§æ‰¿å±æ€§ï¼šç”¨äºè‡ªä¸Šè€Œä¸‹ä¼ é€’ä¿¡æ¯ï¼›åœ¨è¯­æ³•æ ‘ä¸­ï¼Œä¸€ä¸ªç»“ç‚¹çš„ç»§æ‰¿å±æ€§ç”±æ­¤ç»“ ç‚¹çš„çˆ¶ç»“ç‚¹å’Œ/æˆ–å…„å¼Ÿç»“ç‚¹çš„æŸäº›å±æ€§ç¡®å®šã€‚ 3.2.1 Så±æ€§å®šä¹‰\rä»…ä»…ä½¿ç”¨ç»¼åˆå±æ€§çš„è¯­æ³•åˆ¶å¯¼å®šä¹‰ç§°ä¸ºSå±æ€§çš„SDD,æˆ–S-å±æ€§å®šä¹‰ï¼ŒS-SDD\nå¦‚æœä¸€ä¸ªSDDæ˜¯Så±æ€§çš„ï¼Œå¯ä»¥æŒ‰ç…§è¯­æ³•åˆ†ææ ‘èŠ‚ç‚¹çš„ä»»ä½•è‡ªåº•å‘ä¸Šé¡ºåºæ¥è®¡ç®—å®ƒçš„å„ä¸ªå±æ€§å€¼;S-å±æ€§å®šä¹‰å¯åœ¨è‡ªåº•å‘ä¸Šçš„è¯­æ³•åˆ†æè¿‡ç¨‹ä¸­å®ç°ï¼Œå¦‚LRåˆ†æå™¨ã€‚\n$$\rS-\u003eDSD|2\\\\\rD-\u003e0|1\r$$ solution:\n1 2 3 4 5 S\u0026#39;-\u0026gt;S\tprint(S.val) S-\u0026gt;D_1S_1D_2\tS.val = (D_1.val == D_2.val) and S_1.val S-\u0026gt;2\tS.val = true D-\u0026gt;0\tD.val = 0 D-\u0026gt;1\tD.val = 1 3.2.2 Lå±æ€§å®šä¹‰\råœ¨ä¸€ä¸ªäº§ç”Ÿå¼æ‰€å…³è”çš„å„å±æ€§ä¹‹é—´ï¼Œä¾èµ–å›¾çš„è¾¹å¯ä»¥ä»å·¦åˆ°å³ï¼Œä½†ä¸èƒ½ä»å³åˆ°å·¦ï¼Œå¯ä»¥åœ¨LRåˆ†æå™¨æˆ–LLåˆ†æå™¨ä¸­å®ç°ï¼Œæ›´åŠ ä¸€èˆ¬åŒ–ã€‚\nä¾èµ–å›¾(dependency graph)æ˜¯ä¸€ä¸ªæè¿°äº†åˆ†ææ ‘ä¸­ç»“ç‚¹å±æ€§é—´ä¾èµ–å…³ç³»çš„æœ‰å‘å›¾ï¼Œå…¶ä¸­å±æ€§å€¼ä¸ºç‚¹ï¼Œå±æ€§çš„ä¾èµ–å…³ç³»ä¸ºè¾¹ï¼ˆå¦‚æœX.açš„å€¼ä¾èµ–äºY.bçš„å€¼ï¼Œåˆ™ä¾èµ–å›¾ä¸­æœ‰ä»Y.bçš„ç»“ç‚¹æŒ‡å‘X.açš„ç»“ç‚¹çš„æœ‰å‘è¾¹ã€‚\nå¯¹äºä»»æ„ä¸€ä¸ªäº§ç”Ÿå¼A-\u0026gt;X1X2\u0026hellip;Xnï¼Œå…¶å³éƒ¨ç¬¦å·Xiçš„ç»§æ‰¿å±æ€§ä»…ä¾èµ–äºä¸‹åˆ—å±æ€§ï¼š\nAçš„ç»§æ‰¿å±æ€§ äº§ç”Ÿå¼Xiå·¦è¾¹ç¬¦å·X1X2\u0026hellip;Xi-1çš„å±æ€§ Xiæœ¬èº«çš„å±æ€§ï¼Œä½†Xiå…¨éƒ¨å±æ€§ä¸èƒ½åœ¨ä¾èµ–å›¾ä¸­å½¢æˆç¯è·¯ ä¸èƒ½ä¾èµ–Açš„ç»¼åˆå±æ€§çš„åŸå› ï¼šç”±äºAçš„ç»¼åˆå±æ€§å¯èƒ½ä¾èµ–Xiçš„å±æ€§ï¼ŒåŒ…æ‹¬Xiçš„ç»¼åˆå±æ€§å’Œç»§æ‰¿å±æ€§ï¼Œå› æ­¤å¯èƒ½å½¢æˆç¯è·¯ã€‚\nä¸€ä¸ªä¾‹å­ï¼š\näº§ç”Ÿå¼ è¯­ä¹‰è§„åˆ™ D-\u0026gt;TL L.in = T.type T-\u0026gt;int T.type = integer T-\u0026gt;real T.type = real L-\u0026gt;L1,id L1.in = L.in;addType(id.entry,L.in) L-\u0026gt;id addType(id.entry,L.in) åœ¨ä¸Šé¢çš„è¡¨ä¸­ï¼ŒL.inæ˜¯Lçš„ç»§æ‰¿å±æ€§ï¼Œtypeæ˜¯Tçš„ç»¼åˆå±æ€§ï¼ŒaddTypeæ˜¯æŠŠç±»å‹åŠ åˆ°ç¬¦å·è¡¨ä¸­çš„æ ‡è¯†ç¬¦æ¡ç›®é‡Œï¼ˆå‰¯ä½œç”¨ï¼‰\nä¸€ä¸ªæ²¡æœ‰å‰¯ä½œç”¨çš„SDDç§°ä¸ºå±æ€§æ–‡æ³•ï¼Œå±æ€§æ–‡æ³•å¢åŠ äº†è¯­ä¹‰è§„åˆ™æè¿°çš„å¤æ‚åº¦ã€‚\nå—æ§çš„å‰¯ä½œç”¨ï¼šä¸ä¼šå¯¹å±æ€§æ±‚å€¼äº§ç”Ÿçº¦æŸï¼Œå³å¯ä»¥æŒ‰ç…§ä»»ä½•æ‹“æ‰‘é¡ºåºæ±‚å€¼ï¼Œä¸ä¼šå½±å“æœ€ç»ˆç»“æœã€‚\n3.2.3 æŠ½è±¡è¯­æ³•æ ‘çš„æ„é€ \ræŠ½è±¡è¯­æ³•æ ‘(AST)ï¼Œç®€ç§°è¯­æ³•æ ‘ï¼Œæ˜¯åˆ†ææ ‘çš„æµ“ç¼©è¡¨ç¤ºï¼šç®—ç¬¦å’Œå…³é”®å­—ä½œä¸ºå†…éƒ¨èŠ‚ç‚¹ï¼›è¯­æ³•åˆ¶å¯¼ç¿»è¯‘å¯åŸºäºåˆ†ææ ‘ï¼Œä¹Ÿå¯åŸºäºè¯­æ³•æ ‘ã€‚\næ•°æ®ç»“æ„ï¼š\nå¯¹åŸºæœ¬è¿ç®—å¯¹è±¡ç»“ç‚¹ï¼š ä¸€ä¸ªåŸŸå­˜æ”¾è¿ç®—å¯¹è±¡ç±»åˆ« å¦ä¸€ä¸ªåŸŸå­˜æ”¾å…¶å€¼ï¼ˆä¹Ÿå¯ç”¨å…¶ä»–åŸŸä¿å­˜æˆ–å…¶å®ƒå±æ€§æˆ–æŒ‡å‘è¯¥å±æ€§å€¼çš„æŒ‡é’ˆï¼‰ å¯¹ç®—ç¬¦ç»“ç‚¹ï¼š ä¸€ä¸ªåŸŸå­˜æ”¾ç®—ç¬¦å¹¶ä½œä¸ºè¯¥ç»“ç‚¹çš„æ ‡è®° å…¶ä½™ä¸¤ä¸ªåŸŸå­˜æ”¾æŒ‡å‘è¿ç®—å¯¹è±¡çš„æŒ‡é’ˆ å‡½æ•°ï¼š\nmknode(op,left,right)ï¼šå»ºç«‹è¿ç®—ç¬¦å·ç»“ç‚¹ã€‚ mkleaf(id,entry)ï¼šå»ºç«‹æ ‡è¯†ç¬¦ç»“ç‚¹ã€‚ mkleaf(num,val)ï¼šå»ºç«‹æ•°ç»“ç‚¹ã€‚ 3.2.3.1 Så±æ€§AST\rä»¥ç®—æ•°è¡¨è¾¾å¼ä¸ºä¾‹ï¼Œå…¶ä¸­nptrç»¼åˆå±æ€§è¡¨ç¤ºæ–‡æ³•ç¬¦å·å¯¹åº”çš„æŠ½è±¡è¯­æ³•æ ‘ç»“ç‚¹ã€‚\näº§ç”Ÿå¼ è¯­ä¹‰è§„åˆ™ E-\u0026gt;E1+T E.nptr = mkNode(\u0026rsquo;+\u0026rsquo;,E1.nptr,T.nptr) E-\u0026gt;T E.nptr = T.npt T-\u0026gt;T1*F E.nptr = mkNode(\u0026rsquo;*\u0026rsquo;,T1.nptr,F.nptr) T-\u0026gt;F T.nptr = F.nptr F-\u0026gt;(E) F.nptr = E.nptr F-\u0026gt;id F.nptr = mkLeaf(id,id.entry) F-\u0026gt;num F.nptr = mkLeaf(num,num.val) 3.2.3.2 Lå±æ€§AST\ré¦–å…ˆæ¶ˆé™¤å·¦é€’å½’ï¼Œå°†åŸäº§ç”Ÿå¼æ”¹ä¸ºï¼š\n1 2 3 4 5 6 7 8 9 E-\u0026gt;ER R-\u0026gt;+TR1 R-\u0026gt;Îµ T-\u0026gt;FW W-\u0026gt;*FW1 W-\u0026gt;Îµ F-\u0026gt;(E) F-\u0026gt;id F-\u0026gt;num éƒ¨åˆ†å¦‚ä¸‹ï¼š\näº§ç”Ÿå¼ è¯­ä¹‰è§„åˆ™ T-\u0026gt;FW W.i = F.nptr;T.nptr = W.s W-\u0026gt;*FW1 W1.i=mkNode(\u0026rsquo;*\u0026rsquo;,W.i,F.nptr);W.s=W1.s W-\u0026gt;Îµ W.s = W.i F-\u0026gt;id F.nptr = mkLeaf(id,id.entry) F-\u0026gt;num F.nptr = mkLeaf(num,num.val) S-SDDä¸L-SDDçš„ASTéƒ½æ˜¯ä¸€æ ·çš„ï¼Œä½†åˆ†ææ ‘å´æ˜¯ä¸åŒçš„ï¼ŒS-SDDçš„åˆ†ææ ‘ä¸ASTæ¯”è¾ƒæ¥è¿‘ï¼ŒL-SDDçš„åˆ†ææ ‘ä¸ASTç»“æ„ä¸åŒã€‚\n3.2.4 è¯­æ³•åˆ¶å¯¼ç¿»è¯‘æ–¹æ¡ˆ\rè¯­æ³•åˆ¶å¯¼ç¿»è¯‘æ–¹æ¡ˆ(SDT)æ˜¯åœ¨äº§ç”Ÿå¼å³éƒ¨ä¸­åµŒå…¥äº†ç¨‹åºç‰‡æ®µ(ç§°ä¸ºè¯­ä¹‰åŠ¨ä½œ)çš„CFG\nSDTå¯ä»¥çœ‹ä½œæ˜¯SDDçš„å…·ä½“å®æ–½æ–¹æ¡ˆã€‚\nå°†æ¯ä¸ªè¯­ä¹‰åŠ¨ä½œéƒ½æ”¾åœ¨äº§ç”Ÿå¼çš„æœ€åå¹¶ç”¨å¤§æ‹¬å·æ‹¬èµ·æ¥å°±å°†S-SDDè½¬æ¢ä¸ºäº†SDT\n3.2.4.1 Så±æ€§å®šä¹‰çš„SDTä¸¤ç§å®ç°æ–¹å¼\r3.2.4.1.1 å…ˆå»ºæ ‘ï¼Œåè®¡ç®—\rå»ºç«‹è¯­æ³•åˆ†ææ ‘ï¼Œå°†è¯­ä¹‰åŠ¨ä½œçœ‹ä½œæ˜¯è™šæ‹Ÿç»“ç‚¹ï¼Œä»å·¦åˆ°å³ï¼Œæ·±åº¦ä¼˜å…ˆéå†åˆ†ææ ‘ï¼Œåœ¨è®¿é—®è™šæ‹Ÿç»“ç‚¹æ—¶æ‰§è¡Œç›¸åº”åŠ¨ä½œã€‚å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š\n3.2.4.1.2 è¾¹åˆ†æï¼Œè¾¹è®¡ç®—\rç»¼åˆå±æ€§é€šè¿‡è‡ªåº•å‘ä¸Šçš„LRæ¥è®¡ç®—ï¼Œå½“å½’çº¦å‘ç”Ÿæ—¶æ‰§è¡Œç›¸åº”è¯­ä¹‰åŠ¨ä½œã€‚\nå¯ä»¥é€šè¿‡æ‰©å±•çš„LRè¯­æ³•åˆ†ææ ˆæ¥å®ç°ï¼Œæ¯ä¸€ä¸ªæ ˆå…ƒç´ åŒ…å«çŠ¶æ€ï¼Œæ–‡æ³•ç¬¦å·å’Œç»¼åˆå±æ€§è¿™ä¸‰ä¸ªåŸŸã€‚\nåœ¨ä¸Šå›¾ä¸­ï¼ŒL-\u0026gt;Ençš„ä»£ç æ®µï¼šæ ˆä¸­å…ˆå­˜å…¥Eï¼Œåå­˜å…¥nï¼Œæ ˆé¡¶æŒ‡é’ˆtopæŒ‡å‘nï¼Œæ•…top-1æŒ‡å‘Eï¼Œæ‰“å°å…¶åœ¨æ ˆçš„å¯¹åº”å€¼çš„åŸŸå³å¯ï¼›E-\u0026gt;E1+Tçš„ä»£ç æ®µï¼šæ ˆä¸­å…ˆåå­˜å…¥E1,+,Tï¼Œæ ˆé¡¶æŒ‡é’ˆtopæŒ‡å‘Tï¼Œæ•…top-2æŒ‡å‘E1ï¼Œç›´æ¥å¼¹å‡ºä¸‰ä¸ªå…ƒç´ ï¼Œä¸‹ä¸€ä¸ªè¦å­˜çš„Eå¯ä»¥æ”¾åœ¨top-2çš„ä½ç½®ä¸Šï¼›å…¶ä½™çš„ç±»ä¼¼ï¼Œä¸ä½œè¿‡å¤šè§£é‡Šã€‚\n3.2.4.2 Lå±æ€§å®šä¹‰çš„SDTä¸¤ç§å®ç°æ–¹å¼\rSå±æ€§å®šä¹‰å±äºLå±æ€§å®šä¹‰ã€‚\næ¶ˆé™¤å·¦é€’å½’çš„ç®—æœ¯è¡¨è¾¾å¼è¯­æ³•åˆ¶å¯¼å®šä¹‰æ˜¯L-SDDï¼Œåç¼€SDTåœ¨è¿™é‡Œå¹¶ä¸é€‚ç”¨ã€‚\nå°†L-SDDè½¬æ¢ä¸ºSDTçš„è§„åˆ™ï¼š\nå°†è®¡ç®—ä¸€ä¸ªäº§ç”Ÿå¼å·¦éƒ¨ç¬¦å·çš„ç»¼åˆå±æ€§çš„åŠ¨ä½œæ”¾ç½®åœ¨è¿™ä¸ªäº§ç”Ÿå¼å³éƒ¨çš„æœ€å³ç«¯ å°†è®¡ç®—æŸä¸ªéç»ˆç»“ç¬¦å·Açš„ç»§æ‰¿å±æ€§çš„åŠ¨ä½œæ’å…¥åˆ°äº§ç”Ÿå¼å³éƒ¨ä¸­ç´§é åœ¨Açš„æœ¬æ¬¡å‡ºç°ä¹‹å‰çš„ä½ç½®ä¸Š å¤šä¸ªç»§æ‰¿å±æ€§è¦è€ƒè™‘æ¬¡åºï¼Œé˜²æ­¢å½¢æˆç¯ ä»¥3.2.2ä¸­ç»™å‡ºçš„L-SDDçš„ä¾‹å­æ¥æ„é€ L-SDTï¼š\n1 2 3 4 5 D-\u0026gt;T {L.in = T.type} L T-\u0026gt;int {T.type = integer} T-\u0026gt;real {T.type = real} L-\u0026gt;{L1.in = L.in} L1,id {addType(id.entry,L.in)} L-\u0026gt;id {addType(id.entry,L.in)} ä»¥å‰ä¸¤ä¸ªä¸ºä¾‹ï¼ŒD-\u0026gt;TLï¼Œç”±äºè¯­ä¹‰è§„åˆ™L.in = T.typeæ˜¯è®¡ç®—éç»ˆç»“ç¬¦å·Lçš„ç»§æ‰¿å±æ€§ï¼Œæ‰€ä»¥æ”¾åœ¨Lä¹‹å‰ç´§é ç€Lï¼›T-\u0026gt;intï¼Œç”±äºè¯­ä¹‰è§„åˆ™T.type = integeræ˜¯è®¡ç®—å·¦éƒ¨ç¬¦å·Tçš„ç»¼åˆå±æ€§typeçš„ï¼Œæ‰€ä»¥æ”¾åœ¨æœ€å³ç«¯ã€‚\n3.2.4.2.1 ä¸é€’å½’ä¸‹é™åˆ†æç»“åˆ\ré€’å½’ä¸‹é™ç¿»è¯‘å™¨çš„è®¾è®¡ï¼š\nä¸ºæ¯ä¸ªéç»ˆç»“ç¬¦Aæ„é€ ä¸€ä¸ªå‡½æ•° Açš„æ¯ä¸ªç»§æ‰¿å±æ€§å¯¹åº”è¯¥å‡½æ•°çš„ä¸€ä¸ªå½¢å‚ å‡½æ•°çš„è¿”å›å€¼æ˜¯Açš„ç»¼åˆå±æ€§å€¼ åœ¨å‡½æ•°ä½“ä¸­ï¼š é¦–å…ˆé€‰æ‹©é€‚å½“çš„Açš„äº§ç”Ÿå¼ ç”¨å±€éƒ¨å˜é‡ä¿å­˜äº§ç”Ÿå¼ä¸­æ–‡æ³•ç¬¦å·çš„å±æ€§ å¯¹äº§ç”Ÿå¼ä½“ä¸­çš„ç»ˆç»“ç¬¦å·ï¼Œè¯»å…¥ç¬¦å·å¹¶è·å–å…¶ç»¼åˆå±æ€§ï¼ˆç”±è¯æ³•åˆ†æå¾—åˆ°ï¼‰ å¯¹äº§ç”Ÿå¼ä½“ä¸­çš„éç»ˆç»“ç¬¦ï¼Œè°ƒç”¨ç›¸åº”å‡½æ•°ï¼Œè®°å½•è¿”å›å€¼ äº§ç”Ÿå¼R-\u0026gt;+TR|Îµçš„é€’å½’ä¸‹é™åˆ†æè¿‡ç¨‹ï¼š\n1 2 3 4 5 6 7 void R(){ if (lookahead == \u0026#39;+\u0026#39;) { match(\u0026#39;+\u0026#39;); T(); R(); } else {} } 3.2.4.2.2 ä¸LRåˆ†æç»“åˆ\rå°†äº§ç”Ÿå¼ä¸­åµŒå…¥çš„åŠ¨ä½œåˆ é™¤ï¼ŒæŒªåˆ°äº§ç”Ÿå¼æœ€å³ç«¯ï¼Œå…·ä½“æ¥è¯´ï¼Œå¯¹äºäº§ç”Ÿå¼A-\u0026gt;Î±{a}Î²ï¼Œaæ˜¯è¯­ä¹‰åŠ¨ä½œï¼Œå¼•å…¥æ–°çš„éç»ˆç»“ç¬¦Mï¼Œä»£æ›¿{a}ï¼Œå½¢æˆA-\u0026gt;Î±MÎ²ï¼ŒåŒæ—¶å¼•å…¥æ–°çš„äº§ç”Ÿå¼M-\u0026gt;Îµï¼Œä¿®æ”¹aå¾—åˆ°a\u0026rsquo;ï¼Œå°†aéœ€è¦çš„Aæˆ–è€…Î±ä¸­çš„å±æ€§ä½œä¸ºMçš„ç»§æ‰¿å±æ€§è¿›è¡Œå¤åˆ¶ï¼ŒæŒ‰ç…§aä¸­çš„æ–¹æ³•è®¡ç®—å„å±æ€§ï¼Œå°†è¿™äº›å±æ€§ä½œä¸ºMçš„ç»¼åˆå±æ€§ä¿å­˜èµ·æ¥ï¼Œæœ€åå°†{a\u0026rsquo;}ä¸M-\u0026gt;Îµå…³è”èµ·æ¥ã€‚\neg:åŸï¼šA-\u0026gt;{B.i=f(A.i)}BCï¼Œä¿®æ”¹åä¸ºï¼šA-\u0026gt;MBC,M-\u0026gt;Îµ{M.i=A.i;M.s=f(M.i)}\n3.3 ä¸­é—´ä»£ç ç”Ÿæˆ\r3.3.1 å¸ƒå°”è¡¨è¾¾å¼çš„æ§åˆ¶æµç¿»è¯‘\rå¸ƒå°”è¡¨è¾¾å¼æœ‰ä¸¤ä¸ªåŸºæœ¬ç›®çš„ï¼šè®¡ç®—é€»è¾‘å€¼ï¼Œåœ¨æ§åˆ¶æµè¯­å¥ä¸­ç”¨ä½œæ¡ä»¶è¡¨è¾¾å¼ã€‚\nå¸ƒå°”è¿ç®—ç¬¦ï¼šor,and,not\nå…³ç³»è¿ç®—ç¬¦relop:\u0026lt;,\u0026lt;=,=,â‰ ,\u0026gt;,\u0026gt;=\nå¸ƒå°”å¸¸é‡ï¼štrue,false\nç”¨æ§åˆ¶æµæ¥å®ç°è®¡ç®—ï¼šå¸ƒå°”è¿ç®—ç¬¦and,or,notä¸å‡ºç°åœ¨ç¿»è¯‘åçš„ä»£ç ä¸­ï¼Œç”¨ç¨‹åºä¸­çš„ä½ç½®æ¥è¡¨ç¤ºå€¼ã€‚\neg:ç¿»è¯‘ï¼šif (x\u0026lt;3 or x\u0026gt;5 and x!=y) x=10;\n1 2 3 4 5 6 7 8 if x\u0026lt;3 goto L2 goto L3 L3:\tif x\u0026gt;5 goto L4 goto L1 L4:\tif x!=y goto L2 goto L1 L2:\tx = 10 L1: æ³¨æ„å¸ƒå°”è¿ç®—ç¬¦çš„ä¼˜å…ˆçº§ï¼Œnotå…·æœ‰æœ€é«˜ä¼˜å…ˆçº§ï¼Œandæ¬¡ä¹‹ï¼Œoræœ€ä½\nå¸ƒå°”è¡¨è¾¾å¼æ§åˆ¶æµç¿»è¯‘SDDï¼š\nB-\u0026gt;B1 or B2\n1 2 3 4 5 6 è¯­ä¹‰è§„åˆ™ï¼š B1.true = B.true; B1.false = newLabel(); B2.true = B.true; B2.false = B.false; B.code = B1.code || gen(B1.false,\u0026#39;:\u0026#39;) || B2.code B-\u0026gt;B1 and B2\n1 2 3 4 5 6 è¯­ä¹‰è§„åˆ™ï¼š B1.true = newLabel(); B1.false = B.false; B2.true = B.true; B2.false = B.false; B.code = B1.code || gen(B1.true,\u0026#39;:\u0026#39;) || B2.code B -\u0026gt;E1 relop E2\n1 2 è¯­ä¹‰è§„åˆ™ï¼š B.code = E1.code || E2.code || gen(\u0026#39;if\u0026#39;,E1.place,relop.op,E2.place,\u0026#39;goto\u0026#39;,B.true) || gen(\u0026#39;goto\u0026#39;,B.false) B-\u0026gt;(B1)\n1 2 3 4 è¯­ä¹‰è§„åˆ™ï¼š B1.true = B.true; B1.false = B.false; B.code = B1.code B-\u0026gt;not B1\n1 2 3 4 è¯­ä¹‰è§„åˆ™ï¼š B1.true = B.false; B1.false = B.true; B.code = B1.code B-\u0026gt;true/false\n1 2 è¯­ä¹‰è§„åˆ™ï¼š B.code = gen(\u0026#39;goto\u0026#39;,B.true/false) B.trueå’ŒB.falseéƒ½æ˜¯ç»§æ‰¿å±æ€§ï¼Œéœ€è¦ä¸¤è¶Ÿåˆ†ææ¥è®¡ç®—ï¼Œç¬¬ä¸€è¶Ÿç”Ÿæˆè¯­æ³•æ ‘ï¼Œç¬¬äºŒè¶Ÿdfsè®¡ç®—å±æ€§å€¼ã€‚\n3.3.2 åŸºäºç¬¦å·å›å¡«çš„å¸ƒå°”è¡¨è¾¾å¼ç¿»è¯‘\rå¸ƒå°”è¡¨è¾¾å¼çŸ­è·¯è®¡ç®—ç¿»è¯‘ä¸­ï¼Œäº§ç”Ÿäº†è½¬ç§»ç›®æ ‡ä¸æ˜ç¡®çš„æ¡ä»¶æˆ–æ— æ¡ä»¶ä»£ç ã€‚\nè§£å†³æ–¹æ¡ˆï¼šå½“ç”Ÿæˆè·³è½¬æŒ‡ä»¤æ—¶ï¼Œæš‚æ—¶ä¸æŒ‡å®šç›®æ ‡åœ°å€ï¼Œå½“æœ‰å…³ç›®æ ‡åœ°å€ç¡®å®šåï¼Œå†å¡«å›åˆ°ç¿»è¯‘ä»£ç ä¸­ã€‚\nå…·ä½“å®ç°ï¼šå°†æœ‰ç›¸åŒè½¬ç§»ç›®æ ‡çš„è½¬ç§»ä»£ç çš„ç¼–å·ä¸²èµ·æ¥å½¢æˆé“¾ï¼Œå¯ä»¥æ–¹ä¾¿å›å¡«ç›®æ ‡åœ°å€ã€‚è¯¥listå˜æˆäº†ç»¼åˆå±æ€§ï¼Œå¯ä»¥ä¸LRç»“åˆã€‚\næ­¤æ—¶æˆ‘ä»¬æœ‰ä¸¤ä¸ªç»¼åˆå±æ€§ï¼š\nB.truelistï¼šä»£ç ä¸­æ‰€æœ‰è½¬å‘çœŸå‡ºå£çš„ä»£ç æŒ‡ä»¤é“¾ï¼› B.falselistï¼šæ‰€æœ‰è½¬å‘å‡å‡ºå£çš„ä»£ç æŒ‡ä»¤é“¾ã€‚ åœ¨ç”ŸæˆBçš„ä»£ç æ—¶ï¼Œè·³è½¬æŒ‡ä»¤gotoæ˜¯ä¸å®Œæ•´çš„ï¼Œç›®æ ‡æ ‡å·å°šæœªå¡«å†™ï¼Œç”¨truelistå’Œfalselistæ¥ç®¡ç†ã€‚\nç›¸å…³å‡½æ•°ï¼š\nmakelist(i)ï¼Œåˆ›å»ºå«æ ‡å·ä¸ºiçš„æŒ‡ä»¤çš„é“¾è¡¨ backpatch(instruction-list,target-label)ï¼Œå°†ç›®æ ‡åœ°å€å¡«å›listä¸­æ¯æ¡æŒ‡ä»¤ merge(instruction-list1,instruction-list2)ï¼Œåˆå¹¶ä¸¤ä¸ªé“¾ï¼Œå½“ä¸¤ä¸ªé“¾ä¸­æ¯æ¡æŒ‡ä»¤éƒ½ä¼šè·³è½¬åˆ°åŒä¸€æ¡æŒ‡ä»¤æ—¶æ‰§è¡Œæ­¤æ“ä½œ åŸºäºå›å¡«çš„å¸ƒå°”è¡¨è¾¾å¼ç¿»è¯‘SDD(ä¸‹é¢ç”¨çš„æ˜¯LRåˆ†æ)ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 B-\u0026gt;not B1 { B.truelist = B1.falselist; B.falselist = B1.truelist; } B-\u0026gt;(B1) { B.truelist = B1.truelist; B.falselist = B1.falselist; } B-\u0026gt;true/false { B.truelist/falselist = makelist(nextinstr); //è¿™é‡Œå› ä¸ºè¦å›å¡«çš„æ˜¯ä¸‹é¢gençš„gotoè¯­å¥ï¼Œæ‰€ä»¥æ˜¯nextinstr gen(\u0026#39;goto\u0026#39;,-); //-è¡¨ç¤ºéœ€è¦å›å¡« } B-\u0026gt;E1 relop E2 { B.truelist = makelist(nextinstr); B.falselist = makelist(nextinstr+1); gen(\u0026#39;if\u0026#39;,E1.place,relop.op,E2.place,\u0026#39;goto\u0026#39;,\u0026#39;-\u0026#39;); gen(\u0026#39;goto\u0026#39;,-); } B-\u0026gt;B1 or M B2 { backpatch(B1.falselist,M.instr); B.truelist = merge(B1.truelist,B2.truelist); B.falselist = B2.falselist; //è¿™é‡Œçš„Mæ˜¯ä¸ºäº†ä¿å­˜B2å¼€å§‹çš„ç¬¬ä¸€æ¡æŒ‡ä»¤ï¼šM-\u0026gt;Îµ {M.instr = nextinstr} } B-\u0026gt;B1 and M B2 { backpatch(B1.truelist,M.instr); B.falselist = merge(B1.falselist,B2.falselist); B.truelist = B2.truelist; } 3.3.3 åŸºäºç¬¦å·å›å¡«çš„å…¶å®ƒè¯­å¥ç¿»è¯‘\rå¯¹ä¸€èˆ¬è¯­å¥è€Œè¨€ï¼Œæœ‰ä¸€ä¸ªç»¼åˆå±æ€§ï¼šS.nextlistï¼Œè¡¨ç¤ºä»£ç ä¸­æ‰€æœ‰è·³è½¬åˆ°ç´§è·ŸSçš„ä»£ç ä¹‹åçš„æŒ‡ä»¤ã€‚\nç”¨Sè¡¨ç¤ºä¸€æ¡è¯­å¥ï¼Œç”¨Lè¡¨ç¤ºè¯­å¥åˆ—è¡¨ï¼Œåˆ™æœ‰å¦‚ä¸‹çš„æ–‡æ³•å’ŒLRåˆ†æç¿»è¯‘æ–¹æ¡ˆï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 S-\u0026gt;if B then M S1 { //è¿™é‡Œçš„Bæ˜¯ä¸Šé¢çš„å¸ƒå°”è¡¨è¾¾å¼ backpatch(B.truelist,M.instr); S.nextlist = merge(B.falselist,S1.nextlist); } M-\u0026gt;Îµ {M.instr = nextinstr} S-\u0026gt;if B then M1 S1 N else M2 S2 { backpatch(B.truelist,M1.instr); backpatch(B.falselist,M2.instr); temp = merge(S1.nextlist,N.nextlist); S.nextlist = merge(temp,S2.nextlist); } N-\u0026gt;Îµ { N.nextlist = makelist(nextinstr); gen(\u0026#39;goto\u0026#39;,-); } S-\u0026gt;while M1 B do M2 S1 { backpatch(B.truelist,M2.instr); backpatch(S1.nextlist,M1.instr); S.nextlist = B.falselist; gen(\u0026#39;goto\u0026#39;,M1.instr) } S-\u0026gt;A {S.nextlist = {};} //èµ‹å€¼è¯­å¥ S-\u0026gt;{L} {S.nextlist = L.nextlist} L-\u0026gt;S {L.nextlist = S.nextlist} L-\u0026gt;L1;M S { backpatch(L1.nextlist,M.instr); L.nextlist = S.nextlist; } 3.4 ç±»å‹è¡¨è¾¾å¼\rç±»å‹è¡¨è¾¾å¼(type expression):åŸºæœ¬ç±»å‹æ˜¯ç±»å‹è¡¨è¾¾å¼ï¼Œå¯ä¸ºç±»å‹è¡¨è¾¾å¼å‘½åï¼Œç±»åä¹Ÿæ˜¯ç±»å‹è¡¨è¾¾å¼ï¼Œå°†ç±»å‹æ„é€ ç®—å­ä½œç”¨äºç±»å‹è¡¨è¾¾å¼å¯ä»¥æ„é€ æ–°çš„ç±»å‹è¡¨è¾¾å¼ã€‚\næ¯”å¦‚æ•°ç»„ç±»å‹æ„é€ ç®—å­arrayå’Œç±»å‹è¡¨è¾¾å¼integerï¼Œint[3]çš„ç±»å‹è¡¨è¾¾å¼ä¸ºarray(3,integer)ï¼Œåœ¨æ­¤åŸºç¡€ä¸Šå†ä½œç”¨ä¸€éä¸ºarray(2,array(3,integer))ï¼Œè¡¨ç¤ºint[2][3]ä»ä¸ºç±»å‹è¡¨è¾¾å¼ã€‚\nå¸¸è§æ„é€ ç®—å­ï¼š\næ•°ç»„ç±»å‹æ„é€ ç®—å­array æŒ‡é’ˆç±»å‹æ„é€ ç®—å­pointer ç¬›å¡å°”ä¹˜ç§¯ç±»å‹ç®—å­Ã— å‡½æ•°ç±»å‹æ„é€ ç®—å­-\u0026gt; è®°å½•ç±»å‹æ„é€ ç®—å­record an example:\n1 2 3 4 5 6 7 8 9 10 11 12 13 typedef struct{ int address; char lexeme[15]; }row; row table[101]; row *p; åˆ™rowçš„ç±»å‹è¡¨è¾¾å¼ï¼š record((addressÃ—integer)Ã—(lexemeÃ—(array(15,char)))) tableçš„ç±»å‹è¡¨è¾¾å¼ï¼š array(101,row) pçš„ç±»å‹è¡¨è¾¾å¼ï¼š pointer(row) ç”±ä¸Šè¿°å®šä¹‰æˆ‘ä»¬å¯ä»¥æ„é€ ç±»å‹è¡¨è¾¾å¼çš„SDDä¸SDTï¼š\né¦–å…ˆä¸ºæ¯ä¸ªæ–‡æ³•ç¬¦å·è®¾ç½®ç»¼åˆå±æ€§tä¸ç»§æ‰¿å±æ€§bï¼š\ntæ˜¯æŒ‡è¯¥ç¬¦å·å¯¹åº”çš„ç±»å‹è¡¨è¾¾å¼ï¼Œbè¡¨ç¤ºå°†ç±»å‹ä¿¡æ¯ä»å·¦åˆ°å³ä¼ é€’ã€‚\næ¯”å¦‚ä¸‹é¢çš„æ–‡æ³•çš„SDDï¼š\näº§ç”Ÿå¼ è¯­ä¹‰è§„åˆ™ T-\u0026gt;BC T.t = C.t; C.b = B.t B-\u0026gt;int B.t = integer B-\u0026gt;float B.t = float C-\u0026gt;[num]C1 C.t = array(num.val,C1.t); C1.b = C.b C-\u0026gt;Îµ C.t = C.b ç”±ä¸Šé¢çš„SDDå¯ç›´æ¥æ”¹é€ ä¸ºSDTï¼š\n1 2 3 4 5 T-\u0026gt;B {C.b = B.t} C {T.t = C.t;} B-\u0026gt;int {B.t = integer} B-\u0026gt;float {B.t = float} C-\u0026gt;[num] {C1.b = C.b} C1 {C.t = array(num.val,C1.t);} C-\u0026gt;Îµ {C.t = C.b} å¦‚æœè¦ä½¿ç”¨LRï¼ŒåŒæ ·éœ€è¦æ”¹é€ æ–‡æ³•ï¼Œå‚è€ƒ3.2.4.2.2çš„æ”¹é€ æ–¹æ³•ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š\n1 2 3 4 5 6 7 T-\u0026gt;B M C {T.t = C.t;} M-\u0026gt;Îµ {M.t = B.t} B-\u0026gt;int {B.t = integer} B-\u0026gt;float {B.t = float} C-\u0026gt;[num] N C1 {C.t = array(num.val,C1.t);} N-\u0026gt;Îµ {N.t = C.b} C-\u0026gt;Îµ {C.t = C.b} 3.5 ç¬¦å·è¡¨ä¸å£°æ˜è¯­å¥ç¿»è¯‘\rç¬¦å·è¡¨(symbol table)ç”¨äºç¼–è¯‘è¿‡ç¨‹çš„åˆ†æä¸åˆæˆï¼Œå¦‚ä½¿ç”¨å‰å£°æ˜æ£€æŸ¥ï¼Œç¡®å®šä½œç”¨åŸŸï¼Œå†…å­˜ç©ºé—´åˆ†é…ï¼Œç±»å‹è¡¨è¾¾å¼æ„é€ ç­‰ç­‰ï¼Œå…¶ä½¿ç”¨å’Œä¿®æ”¹ä¼´éšç€ç¼–è¯‘çš„å…¨è¿‡ç¨‹ã€‚\nå£°æ˜è¯­å¥ç¿»è¯‘çš„è¦ç‚¹ï¼š\nåˆ†é…å­˜å‚¨å•å…ƒ åå­—ã€ç±»å‹ã€å­—å®½ã€åç§» ä½œç”¨åŸŸçš„ç®¡ç† è¿‡ç¨‹è°ƒç”¨ è®°å½•ç±»å‹çš„ç®¡ç† ä¸äº§ç”Ÿä¸­é—´ä»£ç æŒ‡ä»¤ï¼Œä½†è¦æ›´æ–°ç¬¦å·è¡¨ ç¬¦å·è¡¨çš„ç»„ç»‡ä¸ç®¡ç†ï¼š\nå„è¿‡ç¨‹æœ‰å„è‡ªçš„ç¬¦å·è¡¨ï¼šå“ˆå¸Œè¡¨ ç¬¦å·è¡¨ä¹‹é—´æœ‰åŒå‘é“¾ çˆ¶-\u0026gt;å­ï¼šè¿‡ç¨‹ä¸­åŒ…å«å“ªäº›å­è¿‡ç¨‹å®šä¹‰ å­-\u0026gt;çˆ¶ï¼šåˆ†æå®Œå­è¿‡ç¨‹åç»§ç»­åˆ†æçˆ¶è¿‡ç¨‹ ç»´æŠ¤ç¬¦å·è¡¨æ ˆå’Œåœ°å€åç§»é‡æ ˆï¼ˆä¿å­˜å°šæœªå®Œæˆçš„è¿‡ç¨‹çš„ç¬¦å·è¡¨æŒ‡é’ˆå’Œç›¸å¯¹åœ°å€ï¼‰ 3.6 æ•°ç»„å¯»å€ç¿»è¯‘\r$$\riÃ—w+(base-lowÃ—w)\r$$ å…¶ä¸­ï¼Œbaseæ˜¯æ•´ä¸ªæ•°ç»„çš„åŸºåœ°å€ï¼Œä¹Ÿæ˜¯åˆ†é…ç»™è¯¥æ•°ç»„çš„å†…å­˜å—çš„ç›¸å¯¹åœ°å€ï¼›lowæ˜¯ä¸‹æ ‡çš„ä¸‹ç•Œï¼›wæ˜¯æ¯ä¸ªæ•°ç»„å…ƒç´ çš„å®½åº¦ã€‚è¿™æ ·å†™å› ä¸ºlowÃ—wæ˜¯å¸¸é‡ï¼Œåœ¨ç¼–è¯‘æ—¶è®¡ç®—ï¼Œå‡å°‘äº†è¿è¡Œæ—¶è®¡ç®—ã€‚\n$$\rbase+((i-low_1)Ã—n_2+(j-low_2))Ã—w\r$$$$\r((i_1Ã—n_2)+i_2)Ã—w+(base-((low_1Ã—n_2)+low_2)Ã—w)\r$$$$\r((...((i_1Ã—n_2+i_2)Ã—n_3+i_3)...)Ã—n_k+i_k)Ã—w+base-((...((low_1Ã—n_2+low_2)Ã—n_3+low_3)...)Ã—n_k+low_k)Ã—w\r$$4.è¿è¡Œæ—¶ç®¡ç†\r4.1 å­˜å‚¨ç»„ç»‡\rç¼–è¯‘å™¨å¿…é¡»ä¸ºæºç¨‹åºä¸­å‡ºç°çš„ä¸€äº›æ•°æ®å¯¹è±¡åˆ†é…è¿è¡Œæ—¶çš„å­˜å‚¨ç©ºé—´ï¼ŒåŒ…æ‹¬é™æ€å­˜å‚¨åˆ†é…ä¸åŠ¨æ€å­˜å‚¨åˆ†é…ï¼Œå¯¹äºé‚£äº›åœ¨ç¼–è¯‘æ—¶åˆ»å°±å¯ä»¥ç¡®å®šå¤§å°çš„æ•°æ®å¯¹è±¡ï¼Œå¯ä»¥åœ¨ç¼–è¯‘æ—¶åˆ»å°±ä¸ºå®ƒä»¬åˆ†é…å­˜å‚¨ç©ºé—´ï¼Œè¿™æ ·çš„ç­–ç•¥æˆä¸ºé™æ€å­˜å‚¨åˆ†é…ï¼Œå¦‚æœä¸èƒ½åœ¨ç¼–è¯‘æ—¶åˆ»å®Œå…¨ç¡®å®šæ•°æ®å¯¹è±¡çš„å¤§å°ï¼Œå°±è¦é‡‡ç”¨åŠ¨æ€å­˜å‚¨åˆ†é…çš„ç­–ç•¥ã€‚å³ï¼Œåœ¨ç¼–è¯‘æ—¶åˆ»ä»…äº§ç”Ÿå„ç§å¿…è¦çš„ä¿¡æ¯ï¼Œè€Œåœ¨è¿è¡Œæ—¶åˆ»ï¼Œå†åŠ¨æ€åœ°åˆ†é…å­˜å‚¨ç©ºé—´ã€‚åŒ…æ‹¬æ ˆå¼å­˜å‚¨åˆ†é…ä¸å †å¼å­˜å‚¨åˆ†é…ï¼Œé™æ€å’ŒåŠ¨æ€è¿™ä¸¤ä¸ªæ¦‚å¿µåˆ†åˆ«å¯¹åº”ç¼–è¯‘æ—¶åˆ»å’Œè¿è¡Œæ—¶åˆ»ã€‚\nåå­—çš„ä½œç”¨åŸŸï¼šä¸€ä¸ªå£°æ˜èµ·ä½œç”¨çš„ç¨‹åºéƒ¨åˆ†ç§°ä¸ºè¯¥å£°æ˜çš„ä½œç”¨åŸŸï¼Œå³ä½¿ä¸€ä¸ªåå­—åœ¨ç¨‹åºä¸­åªå£°æ˜ä¸€æ¬¡ï¼Œè¯¥åå­—åœ¨ç¨‹åºè¿è¡Œæ—¶ä¹Ÿå¯èƒ½è¡¨ç¤ºä¸åŒçš„æ•°æ®å¯¹è±¡ã€‚\nç¯å¢ƒå’ŒçŠ¶æ€ï¼š\nç¯å¢ƒæŠŠåå­—æ˜ å°„åˆ°å·¦å€¼ï¼Œè€ŒçŠ¶æ€æŠŠå·¦å€¼æ˜ å°„åˆ°å³å€¼ï¼ˆå³åå­—åˆ°å€¼æœ‰ä¸¤æ­¥æ˜ å°„ï¼‰ èµ‹å€¼æ”¹å˜çŠ¶æ€ï¼Œä½†ä¸æ”¹å˜ç¯å¢ƒ è¿‡ç¨‹è°ƒç”¨æ”¹å˜ç¯å¢ƒ å¦‚æœç¯å¢ƒå°†åå­—xæ˜ å°„åˆ°å­˜å‚¨å•å…ƒsï¼Œåˆ™è¯´xè¢«ç»‘å®šåˆ°s å±€éƒ¨æ•°æ®çš„åˆ†å¸ƒï¼š\nå­—èŠ‚æ˜¯å¯ç¼–å€å†…å­˜çš„æœ€å°å•ä½ å˜é‡æ‰€éœ€çš„å­˜å‚¨ç©ºé—´å¯ä»¥æ ¹æ®å…¶ç±»å‹è€Œé™æ€ç¡®å®š ä¸€ä¸ªè¿‡ç¨‹æ‰€å£°æ˜çš„å±€éƒ¨å˜é‡ï¼ŒæŒ‰è¿™äº›å˜é‡å£°æ˜æ—¶å‡ºç°çš„æ¬¡åºï¼Œåœ¨å±€éƒ¨æ•°æ®åŸŸä¸­ä¾æ¬¡åˆ†é…ç©ºé—´ å±€éƒ¨æ•°æ®çš„åœ°å€å¯ä»¥ç”¨ç›¸å¯¹äºæ´»åŠ¨è®°å½•ä¸­æŸä¸ªä½ç½®çš„åœ°å€æ¥è¡¨ç¤º æ•°æ®å¯¹è±¡çš„å­˜å‚¨å¸ƒå±€è¿˜æœ‰ä¸€ä¸ªå¯¹é½é—®é¢˜ 4.2 ç©ºé—´çš„æ ˆå¼åˆ†é…\rå¯¹äºæ”¯æŒè¿‡ç¨‹ã€å‡½æ•°å’Œæ–¹æ³•çš„è¯­è¨€ï¼Œå…¶ç¼–è¯‘å™¨é€šå¸¸ä¼šç”¨æ ˆçš„å½¢å¼æ¥ç®¡ç†å…¶è¿è¡Œæ—¶åˆ»å­˜å‚¨å½“ä¸€ä¸ªè¿‡ç¨‹è¢«è°ƒç”¨æ—¶ï¼Œè¯¥è¿‡ç¨‹çš„æ´»åŠ¨è®°å½•è¢«å‹å…¥æ ˆä¸­ï¼›å½“è¿‡ç¨‹ç»“æŸæ—¶ï¼Œè®°å½•è¢«å¼¹å‡ºè¿™ç§å®‰æ’ä¸ä»…å…è®¸æ´»è·ƒæ—¶æ®µä¸äº¤å çš„å¤šä¸ªè¿‡ç¨‹è°ƒç”¨å…±äº«ç©ºé—´ï¼›è€Œä¸”å¯ä»¥ä½¿å¾—è¿‡ç¨‹çš„éå±€éƒ¨å˜é‡çš„ç›¸å¯¹åœ°å€æ€»æ˜¯å›ºå®šçš„ï¼Œå’Œè°ƒç”¨åºåˆ—æ— å…³ã€‚\næ´»åŠ¨æ ‘ï¼šç”¨æ¥æè¿°ç¨‹åºè¿è¡ŒæœŸé—´æ§åˆ¶è¿›å…¥å’Œç¦»å¼€å„ä¸ªæ´»åŠ¨çš„æƒ…å†µçš„æ ‘ï¼Œæ ‘ä¸­çš„æ¯ä¸ªç»“ç‚¹å¯¹åº”äºä¸€ä¸ªæ´»åŠ¨ã€‚æ ¹ç»“ç‚¹æ˜¯å¯åŠ¨ç¨‹åºæ‰§è¡Œçš„mainè¿‡ç¨‹çš„æ´»åŠ¨ã€‚\nè¿è¡Œæ ˆï¼šæŠŠæ§åˆ¶æ ˆä¸­çš„ä¿¡æ¯æ‹“å¹¿åˆ°åŒ…æ‹¬è¿‡ç¨‹æ´»åŠ¨æ‰€éœ€çš„æ‰€æœ‰å±€éƒ¨ä¿¡æ¯ã€‚\nä»£ç åºåˆ— è¿‡ç¨‹è°ƒç”¨å’Œè¿‡ç¨‹è¿”å›éƒ½éœ€è¦æ‰§è¡Œä¸€äº›ä»£ç æ¥ç®¡ç†æ´»åŠ¨è®°å½•æ ˆï¼Œä¿å­˜æˆ–æ¢å¤æœºå™¨çŠ¶æ€ç­‰ è¿‡ç¨‹è°ƒç”¨åºåˆ— è¿‡ç¨‹è°ƒç”¨æ—¶æ‰§è¡Œçš„åˆ†é…æ´»åŠ¨è®°å½•ï¼ŒæŠŠä¿¡æ¯å¡«å…¥å®ƒçš„åŸŸä¸­ï¼Œä½¿è¢«è°ƒç”¨è¿‡ç¨‹å¯ä»¥å¼€å§‹æ‰§è¡Œçš„ä»£ç  è¿‡ç¨‹è¿”å›åºåˆ— è¢«è°ƒç”¨è¿‡ç¨‹è¿”å›æ—¶æ‰§è¡Œçš„æ¢å¤æœºå™¨çŠ¶æ€ï¼Œé‡Šæ”¾è¢«è°ƒç”¨è¿‡ç¨‹æ´»åŠ¨è®°å½•ï¼Œä½¿è°ƒç”¨è¿‡ç¨‹èƒ½å¤Ÿç»§ç»­æ‰§è¡Œçš„ä»£ç  è°ƒç”¨åºåˆ—å’Œè¿”å›åºåˆ—å¸¸å¸¸éƒ½åˆ†æˆä¸¤éƒ¨åˆ†ï¼Œåˆ†å¤„äºè°ƒç”¨è¿‡ç¨‹å’Œè¢«è°ƒç”¨è¿‡ç¨‹çš„æ´»åŠ¨è®°å½•ä¸­ã€‚ Cè¯­è¨€æ´»åŠ¨è®°å½•ç»“æ„ï¼š\nä¸´æ—¶æ•°æ® å±€éƒ¨æ•°æ® æœºå™¨çŠ¶æ€ æ§åˆ¶é“¾ è¿”å›å€¼ å‚æ•° Pascalè¯­è¨€æ´»åŠ¨è®°å½•ç»“æ„ï¼š\nä¸´æ—¶æ•°æ® å±€éƒ¨æ•°æ® æœºå™¨çŠ¶æ€ è®¿é—®é“¾ æ§åˆ¶é“¾ è¿”å›å€¼ å‚æ•° 4.3 éå±€éƒ¨åå­—çš„è®¿é—®\ræ— è¿‡ç¨‹åµŒå¥—çš„æ•°æ®è®¿é—®\nè¿‡ç¨‹ä½“ä¸­çš„éå±€éƒ¨å¼•ç”¨å¯ä»¥ç›´æ¥ä½¿ç”¨é™æ€ç¡®å®šçš„åœ°å€ (éå±€éƒ¨æ•°æ®æ­¤æ—¶æ˜¯å…¨å±€æ•°æ®) å±€éƒ¨å˜é‡åœ¨æ ˆé¡¶çš„æ´»åŠ¨è®°å½•ä¸­ï¼Œå¯ä»¥é€šè¿‡ base_sp æŒ‡é’ˆè®¿é—® æ— é¡»æ·±å…¥æ ˆä¸­å–æ•°æ®ï¼Œæ— é¡»è®¿é—®é“¾ æœ‰è¿‡ç¨‹åµŒå¥—çš„é™æ€ä½œç”¨åŸŸ\nä¸€ä¸ªè¿‡ç¨‹çš„å£°æ˜åŒ…å«å¦ä¸€ä¸ªè¿‡ç¨‹çš„å£°æ˜ï¼ŒåµŒå¥—çš„å­è¿‡ç¨‹å¯ä»¥ä½¿ç”¨çˆ¶è¿‡ç¨‹çš„å±€éƒ¨å˜é‡ å­è¿‡ç¨‹ä»£ç è¢«æ¿€æ´»æ‰§è¡Œï¼Œè¦æ‰¾åˆ°çˆ¶è¿‡ç¨‹çš„æ´»åŠ¨è®°å½•ï¼Œéœ€è¦å»ºç«‹è®¿é—®é“¾ åµŒå¥—æ·±åº¦\nè¿‡ç¨‹åµŒå¥—æ·±åº¦ï¼šä¸»ç¨‹åºä¸º 1ï¼Œè¿›å…¥ä¸€ä¸ªè¢«åŒ…å›´çš„è¿‡ç¨‹åŠ  1 å˜é‡çš„åµŒå¥—æ·±åº¦ï¼šå£°æ˜æ‰€åœ¨è¿‡ç¨‹çš„åµŒå¥—æ·±åº¦ä¸ºè¯¥åå­—çš„åµŒå¥—æ·±åº¦ è¿‡ç¨‹åµŒå¥—çš„é™æ€ä½œç”¨åŸŸåœ¨æ´»åŠ¨è®°å½•ä¸­å¢åŠ è®¿é—®æŒ‡é’ˆå½¢æˆè®¿é—®é“¾\nç”¨æ¥å¯»æ‰¾éå±€éƒ¨åå­—çš„å­˜å‚¨å•å…ƒ å‡è®¾pç›´æ¥åµŒå¥—åœ¨qä¸­ï¼Œåˆ™pæ´»åŠ¨è®°å½•çš„è®¿é—®é“¾æŒ‡é’ˆæŒ‡å‘æœ€é è¿‘çš„qçš„æ´»åŠ¨è®°å½• ä¸¤ä¸ªå…³é”®é—®é¢˜éœ€è¦è§£å†³\né€šè¿‡è®¿é—®é“¾è®¿é—®éå±€éƒ¨å¼•ç”¨ è®¿é—®é“¾çš„å»ºç«‹ è¿‡ç¨‹pçš„åµŒå¥—æ·±åº¦n_pï¼Œå¼•ç”¨åµŒå¥—æ·±åº¦ä¸ºn_açš„å˜é‡ a\nè¿½è¸ªè®¿é—®é“¾n_p-n_aæ¬¡ åˆ°è¾¾aæ‰€åœ¨çš„æ´»åŠ¨è®°å½• è®¿é—®é“¾çš„è¿½è¸ªå¯ä»¥é—´æ¥æ“ä½œå®Œæˆ è¿‡ç¨‹pçš„åµŒå¥—æ·±åº¦n_pï¼Œè°ƒç”¨åµŒå¥—æ·±åº¦ä¸ºn_xçš„è¿‡ç¨‹ x\nn_p\u0026lt;n_xï¼Œx åœ¨ p ä¸­ï¼Œè¢«è°ƒç”¨è¿‡ç¨‹çš„è®¿é—®é“¾å¿…é¡»hiæƒ³è°ƒç”¨è¿‡ç¨‹çš„æ´»åŠ¨è®°å½•çš„è®¿é—®é“¾ n_p\u0026gt;= n_xï¼Œæ‰¾åˆ°å…¬å…±ç¥–å…ˆï¼Œä¹Ÿå°±æ˜¯è¿‡ç¨‹xçš„æœ€è¿‘çš„n_x-1æ·±åº¦çš„è¿‡ç¨‹ï¼Œæ²¿ç€è®¿é—®å‘¢è¿è¿½è¸ªn_p-n_x+1æ¬¡ å‚æ•°ä¼ é€’\nå½¢å‚ï¼Œå­˜å‚¨å•å…ƒ (å·¦å€¼)ï¼Œå¼•ç”¨è°ƒç”¨ å®å‚ï¼Œå­˜å‚¨å†…å®¹ (å³å€¼)ï¼Œä¼ å€¼è°ƒç”¨ å †ç®¡ç†\nå †ç”¨äºå­˜æ”¾ç”Ÿå‘½å‘¨æœŸä¸ç¡®å®šã€æˆ–ç”Ÿå­˜åˆ°æ˜ç¡®åˆ é™¤ä¸ºæ­¢çš„æ•°æ®å¯¹è±¡ new ç”Ÿæˆçš„å¯¹è±¡å¯ä»¥ç”Ÿå­˜åˆ°è¢« delete ä¸ºæ­¢ malloc ç”³è¯·çš„ç©ºé—´ç”Ÿå­˜åˆ°è¢« free ä¸ºæ­¢ åˆ†é…/å›æ”¶å †ç©ºé—´çš„å­ç³»ç»Ÿ\nåˆ†é…ï¼šä¸ºå†…å­˜è¯·æ±‚åˆ†é…ä¸€æ®µè¿ç»­ã€é€‚å½“å¤§å°çš„å †ç©ºé—´ é¦–å…ˆä»ç©ºé—²çš„å †ç©ºé—´é€‰æ‹© è‹¥å†…å­˜ç´§å¼ ï¼Œå¯ä»¥å›æ”¶ä¸€éƒ¨åˆ†å†…å­˜ (C/C++ éœ€è¦æ‰‹åŠ¨å›æ”¶ï¼ŒJava å¯ä»¥è‡ªåŠ¨å›æ”¶ç©ºé—´) è¯„ä»·æŒ‡æ ‡ï¼šç©ºé—´æ•ˆç‡ã€ç¨‹åºæ•ˆç‡ã€ç®¡ç†æ•ˆç‡ 5.ä»£ç ç”Ÿæˆ\råŒä¸€ä¸­é—´è¡¨ç¤ºä»£ç å¯ä»¥ç”±å¤šç»„æŒ‡ä»¤åºåˆ—æ¥å®ç°ï¼Œä½†ä¸åŒå®ç°ä¹‹é—´çš„æ•ˆç‡å·®åˆ«æ˜¯å¾ˆå¤§çš„ï¼Œå› æ­¤ï¼Œç”Ÿæˆé«˜è´¨é‡ä»£ç éœ€è¦çŸ¥é“æŒ‡ä»¤ä»£ä»·ã€‚\né™¤äº†è€ƒè™‘æŒ‡ä»¤çš„ä»£ä»·å’Œåºåˆ—é•¿åº¦å¤–ï¼Œæˆ‘ä»¬è¿˜éœ€è¦è€ƒè™‘è¿ç®—å¯¹è±¡å’Œç»“æœå¦‚ä½•å­˜å‚¨çš„é—®é¢˜ã€‚\nä¸‰åœ°å€æœºå™¨æ¨¡å‹ï¼š\nç›®æ ‡æœºå™¨æŒ‡ä»¤é›†(ä¹Ÿå¯ä»¥ç§°ä¸ºç›®æ ‡è¯­è¨€)åŒ…å«LDã€STã€è¿ç®—ã€è·³è½¬ç­‰æŒ‡ä»¤ å†…å­˜æŒ‰ç…§å­—èŠ‚å¯»å€ å‡è®¾æœ‰nä¸ªé€šç”¨å¯„å­˜å™¨R0, R1, â€¦, Rn-1 å‡è®¾æ‰€æœ‰è¿ç®—åˆ†é‡éƒ½æ˜¯æ•´æ•° æŒ‡ä»¤ä¹‹å‰å¯èƒ½æœ‰ä¸€ä¸ªæ ‡å· ç›®æ ‡æœºå™¨æŒ‡ä»¤é›†ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 åŠ è½½æŒ‡ä»¤ï¼šLD dst,addr ä¿å­˜æŒ‡ä»¤ï¼šST x,R è¿ç®—æŒ‡ä»¤ï¼šOP dst,src1,src2 è·³è½¬æŒ‡ä»¤ï¼šBR L Bcond r,L å¯»å€ï¼š å˜é‡åa a(r)ï¼šæ•°ç»„è®¿é—®ï¼Œaæ˜¯å˜é‡ï¼Œræ˜¯å¯„å­˜å™¨ c(r)ï¼šæ²¿æŒ‡é’ˆå–å€¼ï¼Œcæ˜¯æ•´æ•°ï¼Œræ˜¯å¯„å­˜å™¨ *rï¼šåœ¨å¯„å­˜å™¨rçš„å†…å®¹è¡¨ç¤ºçš„ä½ç½®ä¸Šå­˜æ”¾çš„å†…å­˜ä½ç½® *c(r)ï¼šåœ¨å¯„å­˜å™¨rä¸­å†…å®¹åŠ ä¸Šcåè¡¨ç¤ºçš„ä½ç½®ä¸Šå­˜æ”¾çš„å†…å­˜ä½ç½® #cï¼šå¸¸æ•° åœ¨ä¸Šè¿°ç®€å•çš„ç›®æ ‡æœºå™¨ä¸Šï¼ŒæŒ‡ä»¤ä»£ä»·ç®€åŒ–ä¸º1+æŒ‡ä»¤çš„æºå’Œç›®çš„çš„å¯»å€æ¨¡å¼çš„é™„åŠ ä»£ä»·ï¼›å…¶ä¸­ï¼Œå¯„å­˜å™¨å¯»å€æ¨¡å¼é™„åŠ ä»£ä»·ä¸º0ï¼Œæ¶‰åŠå†…å­˜ä½ç½®æˆ–è€…å¸¸æ•°çš„å¯»å€æ–¹å¼ä»£ä»·ä¸º1.\nå¯„å­˜å™¨æè¿°ç¬¦ï¼šè®°å½•æ¯ä¸ªå¯„å­˜å™¨å½“å‰å­˜æ”¾çš„æ˜¯å“ªäº›å˜é‡çš„å€¼\nåœ°å€æè¿°ç¬¦ï¼šè®°å½•è¿è¡Œæ—¶æ¯ä¸ªåå­—çš„å½“å‰å€¼å­˜æ”¾åœ¨å“ªä¸ªæˆ–è€…å“ªäº›ä½ç½®ï¼Œè¯¥ä½ç½®å¯èƒ½æ˜¯å¯„å­˜å™¨ã€æ ˆå•å…ƒã€å†…å­˜åœ°å€æˆ–è€…æ˜¯å®ƒä»¬çš„æŸä¸ªé›†åˆï¼Œè¿™äº›ä¿¡æ¯å¯ä»¥å­˜æ”¾åœ¨è¯¥å˜é‡åå¯¹åº”çš„ç¬¦å·è¡¨æ¡ç›®ä¸­ã€‚\nå¯¹æ¯ä¸ªå½¢å¦‚x=y op zçš„ä¸‰åœ°å€æŒ‡ä»¤Iï¼šè°ƒç”¨å¯„å­˜å™¨é€‰æ‹©å‡½æ•°getReg(I)æ¥ä¸ºxã€yã€zé€‰æ‹©å¯„å­˜å™¨Rx, Ry, Rzï¼›å¦‚æœRyä¸­å­˜æ”¾çš„ä¸æ˜¯yï¼Œåˆ™ç”ŸæˆæŒ‡ä»¤â€œLD Ry, yâ€™â€ , yâ€™æ˜¯å­˜æ”¾yçš„å†…å­˜ä½ç½®ä¹‹ä¸€ï¼Œå¯¹äºRzå’Œzçš„å¤„ç†ä¸ä¸Šä¸€æ­¥éª¤ç±»ä¼¼ï¼Œæœ€åï¼Œç”Ÿæˆç›®æ ‡æŒ‡ä»¤â€œOP Rx, Ry, Rz â€ã€‚ å¯¹äºä¸€ä¸ªåœ¨åŸºæœ¬å—å‡ºå£å¤„å¯èƒ½æ´»è·ƒçš„å˜é‡xï¼Œå¦‚æœå®ƒçš„åœ°å€æè¿°ç¬¦è¡¨æ˜å®ƒçš„å€¼æ²¡æœ‰å­˜æ”¾åœ¨xçš„å†…å­˜ä½ç½®ä¸Šï¼Œåˆ™ç”ŸæˆæŒ‡ä»¤â€œST x, Râ€ï¼šRæ˜¯åœ¨åŸºæœ¬å—ç»“å°¾å¤„å­˜æ”¾xå€¼çš„å¯„å­˜å™¨ã€‚ å½“ç”ŸæˆåŠ è½½ã€ä¿å­˜å’Œå…¶ä»–æŒ‡ä»¤æ—¶ï¼Œå¿…é¡»åŒæ—¶æ›´æ–°å¯„å­˜å™¨å’Œåœ°å€æè¿°ç¬¦ï¼š å¯¹äºLD R, xæŒ‡ä»¤ï¼šä¿®æ”¹Rçš„å¯„å­˜å™¨æè¿°ç¬¦ï¼Œä½¿ä¹‹åªåŒ…å«xï¼Œä¿®æ”¹xçš„åœ°å€æè¿°ç¬¦ï¼ŒæŠŠRä½œä¸ºæ–°å¢ä½ç½®åŠ å…¥åˆ°xçš„ä½ç½®é›†åˆä¸­ï¼Œä»ä»»ä½•ä¸åŒäºxçš„åœ°å€æè¿°ç¬¦ä¸­åˆ é™¤Rã€‚ å¯¹äºOP Rx, Ry, RzæŒ‡ä»¤ï¼šä¿®æ”¹Rxçš„å¯„å­˜å™¨æè¿°ç¬¦ï¼Œä½¿ä¹‹åªåŒ…å«xï¼Œä»ä»»ä½•ä¸åŒäºRxçš„å¯„å­˜å™¨æè¿°ç¬¦ä¸­åˆ é™¤xï¼Œä¿®æ”¹xçš„åœ°å€æè¿°ç¬¦ï¼Œä½¿ä¹‹åªåŒ…å«ä½ç½®Rxï¼Œä»ä»»ä½•ä¸åŒäºxçš„åœ°å€æè¿°ç¬¦ä¸­åˆ é™¤Rxã€‚ å¯¹äºST x, RæŒ‡ä»¤ï¼šä¿®æ”¹xçš„åœ°å€æè¿°ç¬¦ï¼Œä½¿ä¹‹åŒ…å«è‡ªå·±çš„å†…å­˜ä½ç½®ã€‚ å¯¹äºx = yæŒ‡ä»¤ï¼Œå‡è®¾æ€»æ˜¯ä¸ºxå’Œyåˆ†é…åŒä¸€ä¸ªå¯„å­˜å™¨ï¼Œå¦‚æœéœ€è¦ç”Ÿæˆâ€œLD Ry, yâ€™â€ ï¼Œåˆ™ï¼šä¿®æ”¹Ryçš„å¯„å­˜å™¨æè¿°ç¬¦ï¼Œä½¿ä¹‹åªåŒ…å«yï¼Œä¿®æ”¹yçš„åœ°å€æè¿°ç¬¦ï¼ŒæŠŠRyä½œä¸ºæ–°å¢ä½ç½®åŠ å…¥yçš„ä½ç½®é›†åˆä¸­ï¼Œä»ä»»ä½•ä¸åŒäºyçš„åœ°å€æè¿°ç¬¦ä¸­åˆ é™¤Ryï¼Œä¿®æ”¹Ryçš„å¯„å­˜å™¨æè¿°ç¬¦ï¼Œä½¿ä¹‹ä¹ŸåŒ…å«xï¼Œä¿®æ”¹xçš„åœ°å€æè¿°ç¬¦ï¼Œä½¿ä¹‹åªåŒ…å«Ryã€‚ ä¸Šé¢çš„è§„åˆ™éå¸¸é•¿å’Œå¤æ‚ï¼Œä¸‹é¢ç»™å‡ºä¸€ä¸ªä¾‹å­å¸®åŠ©ç†è§£ï¼š\n1 2 3 4 5 6 7 8 åŸºæœ¬å—ä¸‰åœ°å€ä»£ç ï¼š t=a-b u=a-c v=t+u a=d d=v+u exit å…¶ä¸­ï¼Œt,u,vä¸ºä¸´æ—¶å˜é‡ï¼Œa,b,c,dåœ¨å‡ºå£å¤„æ´»è·ƒ åˆå§‹å¯„å­˜å™¨æè¿°ç¬¦ä¸ºç©ºï¼Œåœ°å€æè¿°ç¬¦åªæœ‰abcdçš„å†…å­˜åœ°å€ï¼Œå¤„ç†ç¬¬ä¸€å¥ï¼št=a-b\nç”±ç¬¬ä¸€æ¡è§„åˆ™ï¼Œä¸ºaé€‰æ‹©å¯„å­˜å™¨R1ï¼Œä¸ºbé€‰æ‹©å¯„å­˜å™¨R2ï¼Œté€‰æ‹©å¯„å­˜å™¨R2ï¼Œå¯ç”Ÿæˆå¦‚ä¸‹çš„æŒ‡ä»¤ï¼š\n1 2 3 LD R1,a LD R2,b SUB R2,R1,R2 ç„¶åè€ƒè™‘å‰ä¸¤å¥ï¼Œä¿®æ”¹R1å’ŒR2çš„å¯„å­˜å™¨æè¿°ç¬¦ï¼Œä½¿å…¶åŒ…å«aå’Œbï¼Œä¿®æ”¹aå’Œbçš„åœ°å€æè¿°ç¬¦ï¼ŒæŠŠR1å’ŒR2åŠ åˆ°å¯¹åº”ä½ç½®é›†åˆä¸­ï¼š\nR1 R2 a b a b c d a,R1 b,R2 c d å¯¹äºç¬¬ä¸‰å¥ï¼Œä¿®æ”¹R2çš„å¯„å­˜å™¨æè¿°ç¬¦ï¼Œä½¿å…¶åªå«tï¼Œå¦‚æœåˆ«çš„å¯„å­˜å™¨å«æœ‰tå°±åˆ é™¤ï¼Œè¿™ä¸ªä¾‹å­ä¸­æ²¡æœ‰ï¼Œä¸éœ€è¦ç®¡ï¼Œä¿®æ”¹tçš„åœ°å€æè¿°ç¬¦ï¼Œä½¿å…¶åªåŒ…å«R2ï¼Œå¦‚æœåˆ«çš„åœ°å€æœ‰R2å°±åˆ æ‰ï¼Œè¿™é‡ŒæŠŠbä¸­çš„R2åˆ æ‰ï¼š\nR1 R2 a t a b c d t a,R1 b c d R2 ç¬¬äºŒå¥å’Œç¬¬ä¸‰å¥ç±»ä¼¼ï¼Œè¿™é‡Œä¸åšåˆ†æï¼Œç»™å‡ºç¬¬å››å¥ä¹‹å‰çš„å¯„å­˜å™¨æè¿°ç¬¦å’Œåœ°å€æè¿°ç¬¦ï¼š\nR1 R2 R3 u t v a b c d t u v a b c d R2 R1 R3 æ­¤æ—¶è€ƒè™‘ç¬¬å››å¥a=dï¼Œéœ€è¦ä¸ºaå’Œdåˆ†é…åŒä¸€ä¸ªå¯„å­˜å™¨ï¼Œç”±äºå®ƒä»¬éƒ½æ²¡å¯„å­˜å™¨ï¼Œæ•…ç”ŸæˆLD R2,dè¿™æ ·çš„è¯­å¥ï¼Œéœ€è¦è¿›è¡Œå¦‚ä¸‹æ“ä½œï¼šä¿®æ”¹R2çš„å¯„å­˜å™¨æè¿°ç¬¦ï¼Œä½¿å…¶åªåŒ…å«dï¼Œä¿®æ”¹dçš„åœ°å€æè¿°ç¬¦ï¼ŒæŠŠR2æ·»åŠ è¿›å»ï¼ŒæŠŠå…¶ä»–ä½ç½®çš„R2åˆ å»ï¼Œä¿®æ”¹açš„åœ°å€æè¿°ç¬¦ï¼Œä½¿å…¶åªå«R2ï¼Œä¿®æ”¹R2çš„å¯„å­˜å™¨æè¿°ç¬¦ï¼Œæ·»åŠ aï¼š\nR1 R2 R3 u a,d v a b c d t u v R2 b c d,R2 R1 R3 è¿™ä¸ªä¾‹å­åœ¨æœ€åé€€å‡ºæ—¶ï¼Œaå’Œdçš„åœ°å€æè¿°ç¬¦ä¸å«å†…å­˜ä½ç½®ï¼Œéœ€è¦ç”ŸæˆSTæŒ‡ä»¤ï¼ŒæŠŠaå’Œdæ·»åŠ åˆ°å¯¹åº”ä½ç½®çš„åœ°å€æè¿°ç¬¦ä¸Šã€‚\n6.æœºå™¨æ— å…³ä»£ç ä¼˜åŒ–\rä»£ç ä¼˜åŒ–ï¼šåœ¨ä¸æ”¹å˜ç¨‹åºè¿è¡Œæ•ˆæœçš„å‰æä¸‹ï¼Œå¯¹ç¨‹åºä»£ç è¿›è¡Œç­‰ä»·å˜æ¢ï¼Œä½¿ä¹‹èƒ½ç”Ÿæˆæ›´åŠ é«˜æ•ˆç›®æ ‡ä»£ç ã€‚\nä¼˜åŒ–ç›®æ ‡ï¼šè¿è¡Œæ—¶é—´æ›´çŸ­ï¼Œå ç”¨ç©ºé—´æ›´å°ã€‚\n6.1 å¸¸è§çš„ä¼˜åŒ–æ–¹å¼\rå…¬å…±å­è¡¨è¾¾å¼ï¼šè‹¥x op yå·²è¢«è®¡ç®—è¿‡ï¼Œä¸”xå’Œyçš„å€¼æ²¡æœ‰æ”¹å˜ï¼Œé‚£ä¹ˆä¸‹ä¸€æ¬¡å‡ºç°å°±æ˜¯å…¬å…±å­è¡¨è¾¾å¼ã€‚ä¸‹ä¸€æ¬¡è®¡ç®—å¯ä»¥åˆ é™¤ï¼Œå…¶å€¼ç”¨ä¸Šä¸€æ¬¡è®¡ç®—ç»“æœä»£æ›¿ã€‚åˆ é™¤åˆ†æï¼šå¯ç”¨è¡¨è¾¾å¼æ•°æ®æµåˆ†æã€‚ æ­»ä»£ç åˆ é™¤ï¼šæ­»ä»£ç æ˜¯æŒ‡è®¡ç®—çš„ç»“æœæ°¸è¿œä¸è¢«å¼•ç”¨çš„è¯­å¥ï¼Œä¸€äº›ä¼˜åŒ–å˜æ¢å¯èƒ½ä¼šå¼•èµ·æ­»ä»£ç ï¼Œå¦‚å¤åˆ¶ä¼ æ’­ï¼Œå¸¸é‡åˆå¹¶ã€‚ å¤åˆ¶ä¼ æ’­ï¼šåœ¨å¤åˆ¶è¯­å¥x=yä¹‹åå°½å¯èƒ½ç”¨yä»£æ›¿xï¼Œå¸¸ç”¨çš„å…¬å…±å­è¡¨è¾¾å¼åˆ é™¤å’Œå…¶ä»–ä¸€äº›ä¼˜åŒ–ä¼šå¼•å…¥ä¸€äº›å¤åˆ¶è¯­å¥ï¼Œå¤åˆ¶ä¼ æ’­æœ¬èº«æ²¡æœ‰ä¼˜åŒ–çš„æ„ä¹‰ï¼Œä½†å¯ä»¥ç»™æ­»ä»£ç åˆ é™¤åˆ›é€ æœºä¼šã€‚ å¸¸é‡åˆå¹¶ï¼šå¦‚æœç¼–è¯‘æ—¶åˆ»æ¨å¯¼å‡ºä¸€ä¸ªè¡¨è¾¾å¼çš„å€¼æ˜¯å¸¸é‡ï¼Œå°±å¯ä»¥ç”¨è¯¥å¸¸é‡æ¥ä»£æ›¿è¿™ä¸ªè¡¨è¾¾å¼ã€‚å¸¸é‡åˆå¹¶ä¹Ÿæ˜¯æœ¬èº«æ²¡æœ‰ä¼˜åŒ–çš„æ„ä¹‰ï¼Œå¯ä»¥ç»™æ­»ä»£ç åˆ é™¤åˆ›é€ æœºä¼šã€‚ å¾ªç¯ä¼˜åŒ–ï¼šå¼ºåº¦å‰Šå¼±ï¼šå°†ç¨‹åºä¸­æ‰§è¡Œæ—¶é—´è¾ƒé•¿çš„è¿ç®—æ›¿æ¢ä¸ºæ‰§è¡Œæ—¶é—´è¾ƒçŸ­çš„è¿ç®—ï¼Œæ¯”å¦‚ç”¨å¢é‡è¿ç®—æ›¿ä»£ï¼›å½’çº³å˜é‡åˆ é™¤ï¼šã€å½’çº³å˜é‡ï¼šå¦‚æœå­˜åœ¨ä¸€ä¸ªå¸¸é‡cï¼Œä½¿xæ¯ä¸€æ¬¡èµ‹å€¼æ€»æ˜¯å¢åŠ cï¼Œåˆ™ç§°xä¸ºå½’çº³å˜é‡ã€‘ä¸€ä¸ªå¾ªç¯ä¸­ï¼Œå¦‚ä¸€ç»„å½’çº³å˜é‡çš„å€¼çš„å˜åŒ–ä¿æŒæ­¥è°ƒä¸€è‡´ï¼Œåˆ™å¯åªä¿ç•™ä¸€ä¸ªï¼›ä»£ç ç§»åŠ¨ï¼šå¾ªç¯ä¸å˜è®¡ç®—æ˜¯æŒ‡ä¸ç®¡å¾ªç¯æ‰§è¡Œå¤šå°‘æ¬¡éƒ½å¾—åˆ°ç›¸åŒç»“æœçš„è¡¨è¾¾å¼ï¼Œä»£ç ç ç§»åŠ¨æ˜¯å¾ªç¯ä¼˜åŒ–çš„ä¸€ç§ï¼Œåœ¨è¿›å…¥å¾ªç¯å‰å°±å¯¹å¾ªç¯ä¸å˜è®¡ç®—è¿›è¡Œæ±‚å€¼ã€‚å¯¹äºå¤šé‡åµŒå¥—å¾ªç¯ï¼Œ loop-invariant computationæ˜¯ç›¸å¯¹äºæŸä¸€ä¸ªå¾ªç¯çš„ï¼Œå¯èƒ½å¯¹äºæ›´åŠ å¤–å±‚çš„å¾ªç¯ï¼Œå®ƒå°±ä¸æˆç«‹äº†ã€‚å› æ­¤ï¼Œå¤„ç†å¾ªç¯æ—¶ï¼ŒæŒ‰ç…§ç”±é‡Œåˆ°å¤–çš„æ–¹å¼ï¼Œå³dfsã€‚ 6.2 åˆ°è¾¾å®šå€¼åˆ†æ\ræ•°æ®æµåˆ†æï¼šä¸€ç»„ç”¨æ¥è·å–ç¨‹åºæ‰§è¡Œè·¯å¾„ä¸Šçš„æ•°æ®æµä¿¡æ¯çš„æŠ€æœ¯ã€‚\nåº”ç”¨æœ‰åˆ°è¾¾å®šå€¼åˆ†æï¼Œæ´»è·ƒå˜é‡åˆ†æï¼Œå¯ç”¨è¡¨è¾¾å¼åˆ†æï¼Œåœ¨æ¯ä¸€ç§åº”ç”¨ä¸­ï¼Œéƒ½ä¼šæŠŠæ¯ä¸ªç¨‹åºç‚¹å’Œä¸€ä¸ªæ•°æ®æµå€¼å…³è”èµ·æ¥ã€‚\næµå›¾ä¸Šçš„ç‚¹ï¼šåŸºæœ¬å—ä¸­ï¼Œä¸¤ä¸ªç›¸é‚»çš„è¯­å¥ä¹‹é—´ä¸ºç¨‹åºçš„ä¸€ä¸ªç‚¹ï¼ŒåŸºæœ¬å—æœ‰å¼€å§‹ç‚¹å’Œç»“æŸç‚¹ã€‚\næ•°æ®æµå€¼ä»£è¡¨åœ¨ä»»ä¸€ç¨‹åºç‚¹èƒ½è§‚æµ‹åˆ°çš„æ‰€æœ‰å¯èƒ½ç¨‹åºçŠ¶æ€é›†åˆçš„ä¸€ä¸ªæŠ½è±¡ï¼Œå¯¹äºä¸€ä¸ªè¯­å¥sï¼Œsä¹‹å‰çš„ç¨‹åºç‚¹å¯¹åº”çš„æ•°æ®æµå€¼ç”¨IN[s]è¡¨ç¤ºï¼Œä¹‹åçš„ç”¨OUT[s]è¡¨ç¤ºã€‚\nä¼ é€’å‡½æ•°fï¼Œè¡¨ç¤ºè¯­å¥å‰åä¸¤ç‚¹çš„æ•°æ®æµå€¼å—è¯¥è¯­å¥çš„è¯­ä¹‰çº¦æŸï¼Œè‹¥æ²¿æ‰§è¡Œè·¯å¾„æ­£å‘ä¼ æ’­ï¼Œåˆ™OUT[s]=fs(IN[s])ï¼Œé€†å‘åˆ™ç›¸åï¼Œè‹¥åŸºæœ¬å—ç”±s1,s2,s3\u0026hellip;ç»„æˆï¼Œæœ‰ï¼šIN[si+1]=OUT[si]ã€‚\nåŸºæœ¬å—ä¸Šçš„æ•°æ®æµï¼šIN[B]è¡¨ç¤ºç´§é åŸºæœ¬å—Bä¹‹å‰çš„æ•°æ®æµå€¼ï¼Œå³IN[B]=IN[s1];OUT[B]è¡¨ç¤ºç´§é åŸºæœ¬å—Bä¹‹åçš„æ•°æ®æµå€¼ï¼Œå³OUT[B]=OUT[sn]ã€‚\nåˆ°è¾¾å®šå€¼åˆ†æï¼šåˆ°è¾¾ä¸€ä¸ªç¨‹åºç‚¹çš„æ‰€æœ‰å®šå€¼(gen)ï¼Œå®šå€¼çš„æ³¨é”€(kill)\nå®šå€¼ä¸å¼•ç”¨ï¼š\n1 2 d:\tx:=y+z //è¯­å¥dæ˜¯å˜é‡xçš„ä¸€ä¸ªå®šå€¼ç‚¹ u:\tw:=x+v //è¯­å¥uæ˜¯å˜é‡xçš„ä¸€ä¸ªå¼•ç”¨ç‚¹ ç§°å˜é‡xåœ¨dç‚¹çš„å®šå€¼åˆ°è¾¾uç‚¹\nç”¨é€”ï¼š\nå¾ªç¯ä¸å˜é‡æ£€æµ‹ï¼šå¦‚æœå¾ªç¯ä¸­æœ‰x=y+zï¼Œè€Œyå’Œzçš„æ‰€æœ‰å¯èƒ½å®šå€¼éƒ½åœ¨å¾ªç¯å¤–ï¼Œåˆ™y+zå°±æ˜¯å¾ªç¯ä¸å˜è®¡ç®—ã€‚ å¸¸é‡åˆå¹¶ï¼šå¦‚æœå¯¹å˜é‡xçš„æŸæ¬¡ä½¿ç”¨åªæœ‰ä¸€ä¸ªå®šå€¼åˆ°è¾¾ï¼Œä¸”è¯¥å®šå€¼æŠŠä¸€ä¸ªå¸¸é‡èµ‹ç»™xï¼Œåˆ™å¯ä»¥ç”¨è¯¥å¸¸é‡æ›¿æ¢xã€‚ é”™è¯¯æ£€æµ‹ï¼šåˆ¤å®šå˜é‡xåœ¨pç‚¹ä¸Šæ˜¯å¦æœªç»å®šå€¼å°±è¢«å¼•ç”¨ã€‚ genå’Œkillåˆ†åˆ«è¡¨ç¤ºä¸€ä¸ªåŸºæœ¬å—ç”Ÿæˆå’Œæ³¨é”€çš„å®šå€¼ã€‚\ngenBè¡¨ç¤ºBä¸­èƒ½åˆ°è¾¾Bçš„ç»“æŸç‚¹çš„å®šå€¼è¯­å¥ï¼ŒkillBè¡¨ç¤ºæ•´ä¸ªç¨‹åºä¸­ç»ä¸ä¼šåˆ°è¾¾Bç»“æŸç‚¹çš„å®šå€¼ï¼ŒIN[B]è¡¨ç¤ºèƒ½åˆ°è¾¾Bçš„å¼€å§‹ç‚¹çš„å®šå€¼é›†åˆï¼ŒOUT[B]è¡¨ç¤ºèƒ½åˆ°è¾¾Bçš„ç»“æŸç‚¹çš„å®šå€¼é›†åˆã€‚\n$$\rIN[B]=\\cup OUT[P]\\{Pæ˜¯Bçš„å‰é©±\\}\\\\\rOUT[B]=gen_B \\cup (IN[B]-kill_B)\\\\\rOUT[ENTRY]=\\emptyset\r$$ å¦‚ä¸‹é¢çš„ä¾‹å­ï¼š\nå¯å¾—åˆ°å¦‚ä¸‹çš„genå’Œkillé›†åˆï¼š\n1 2 3 4 5 6 7 8 9 10 11 gen[B1]={d1,d2,d3} kill[B1]={d4,d5,d6,d7} //å› ä¸ºæŠŠd4,d5,d6,d7å·¦è¾¹çš„å®šå€¼å…¨éƒ¨æ”¹äº†ï¼Œä¸ä¼šåˆ°è¾¾æœ«å°¾ gen[B2]={d4,d5} kill[B2]={d1,d2,d7} gen[B3]={d6} kill[B3]={d3} gen[B4]={d7} kill[B4]={d1,d4} ä¸‹é¢è¿­ä»£è®¡ç®—INå’ŒOUTï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 IN[B1]={} //å‰é©±ENTRYçš„OUTä¸ºç©º OUT[B1]={d1,d2,d3} IN[B2]=OUT[B1]âˆªOUT[B4]={d1,d2,d3} //è¿™é‡Œåˆå§‹åŒ–OUTéƒ½ä¸ºç©ºï¼Œåç»­ä¼šè¿­ä»£æ›´æ–° OUT[B2]={d3,d4,d5} IN[B3]={d3,d4,d5} OUT[B3]={d4,d5,d6} IN[B4]={d3,d4,d5,d6} OUT[B4]={d3,d5,d6,d7} IN[B2]={d1,d2,d3,d5,d6,d7} OUT[B2]={d3,d4,d5,d6} IN[B3]={d3,d4,d5,d6} OUT[B3]={d4,d5,d6} IN[B4]={d3,d4,d5,d6} OUT[B4]={d3,d5,d6,d7} æ­¤åä¸å†å‘ç”Ÿå˜åŒ–ï¼Œè¿­ä»£ç»“æŸï¼Œå…±è¿­ä»£3è½®ï¼ˆåŠ ä¸Šæœ€åä¸€æ¬¡æ²¡æœ‰OUTå‡ºç°å˜åŒ–çš„ä¸€è½®ï¼‰ 6.3 å¯ç”¨è¡¨è¾¾å¼åˆ†æ\rè‹¥åˆ°ç‚¹pçš„æ¯æ¡æ‰§è¡Œè·¯å¾„éƒ½è®¡ç®—x op yï¼Œå¹¶ä¸”è®¡ç®—åæ²¡æœ‰å¯¹xæˆ–yèµ‹å€¼ï¼Œé‚£ä¹ˆç§°x op yåœ¨ç‚¹på¯ç”¨ã€‚\ne_genB:å—Bäº§ç”Ÿçš„å¯ç”¨è¡¨è¾¾å¼é›†åˆ\ne_killB:å—Bæ³¨é”€çš„å¯ç”¨è¡¨è¾¾å¼é›†åˆ\nIN[B]ï¼šå—Bå…¥å£çš„å¯ç”¨è¡¨è¾¾å¼é›†åˆ\nOUT[B]ï¼šå—Bå‡ºå£çš„å¯ç”¨è¡¨è¾¾å¼é›†åˆ\n$$\rIN[B]=\\cap OUT[P]\\{Pæ˜¯Bçš„å‰é©±\\}\\\\\rOUT[B]=e\\_gen_B \\cup (IN[B]-e\\_kill_B)\\\\\rOUT[ENTRY]=\\emptyset\r$$ æ³¨æ„è¿™é‡Œç”¨çš„æ˜¯äº¤é›†ï¼Œæ±‚çš„æ˜¯æœ€å¤§è§£ã€‚\neg:\nå¯å¾—åˆ°å¦‚ä¸‹çš„e_genå’Œe_killé›†åˆï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 å¿½ç•¥äº†entryå’Œexitï¼Œå› ä¸ºéƒ½æ˜¯ç©ºé›† e_gen[B1]={3,1} //å¸¸é‡ä¸€å®šæ˜¯å¯ç”¨è¡¨è¾¾å¼ e_kill[B1]={D+D,D*D,A+G} //è¿™é‡Œæ”¹å˜äº†Då’ŒGçš„å€¼ï¼Œæ‰€ä»¥å³è¾¹è¡¨è¾¾å¼å«Då’ŒGçš„è¦è¢«kill e_gen[B2]={D+D,D*D,B+C} //å¦‚æœè¡¨è¾¾å¼å·¦å€¼åœ¨åŸºæœ¬å—ä¸­è¢«ä¿®æ”¹ï¼Œåˆ™ä¸æ˜¯å¯ä»¥è¡¨è¾¾å¼ e_kill[B2]={A+G,A*A} //è¿™é‡Œæ²¡æœ‰killæ‰B+C,å³ä½¿Bå’ŒCçš„å€¼è¢«ä¿®æ”¹äº†ï¼Œå› ä¸ºæœ€åä¸€ä¸ªè¯­å¥é‡æ–°è®¡ç®—äº†B+Cï¼Œè¿™æ ·B+Cåˆæˆä¸ºäº†å¯ç”¨è¡¨è¾¾å¼ e_gen[B3]={A+G} //è¿™é‡Œçš„B+cä¸æ˜¯å¯ç”¨è¡¨è¾¾å¼å› ä¸ºBæ˜¯å·¦å€¼ e_kill[B3]={B+C} //æ”¹å˜äº†Bï¼Œkillæ‰B+C e_gen[B4]={A*A} e_kill[B4]={B+C} e_gen[B5]={B+C} e_kill[B5]={D*D,A+G,D+D} åˆå§‹åŒ–OUT[ENTRY]ä¸ºç©ºé›†ï¼Œå…¶ä½™çš„åŸºæœ¬å—OUTé›†åˆå‡ä¸ºUï¼ˆæ‰€æœ‰e_gené›†åˆçš„å¹¶é›†ï¼‰ï¼Œä¸‹é¢è¿›è¡Œè¿­ä»£ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 IN[B1]=OUT[ENTRY]={} OUT[B1]={3,1} IN[B2]=OUT[B1]âˆ©OUT[B5]={3,1} OUT[B2]={3,1,D+D,D*D,B+C} IN[B3]={3,1,D+D,D*D,B+C} OUT[B3]={A+G,3,1,D+D,D*D} IN[B4]={3,1,D+D,D*D,B+C} OUT[B4]={A*A,3,1,D+D,D*D} IN[B5]={3,1,D+D,D*D} OUT[B5]={3,1,B+C} IN[EXIT]={3,1,B+C} OUT[EXIT]={3,1,B+C} ç¬¬ä¸€æ¬¡è¿­ä»£ç»“æŸï¼Œç¬¬äºŒæ¬¡è¿­ä»£ç»“æœä¸å˜è¿™é‡Œä¸åšå±•ç¤ºï¼Œç„¶åå°±é€€å‡ºäº†ï¼Œè¿­ä»£ç»“æŸã€‚ 6.4 æ´»è·ƒå˜é‡åˆ†æ\rå¯¹äºå˜é‡xå’Œç¨‹åºç‚¹pï¼Œå¦‚æœxçš„å€¼åœ¨pç‚¹å¼€å§‹çš„æŸæ¡æ‰§è¡Œè·¯å¾„ä¸Šè¢«å¼•ç”¨ï¼Œåˆ™è¯´xåœ¨pç‚¹æ´»è·ƒï¼Œå¦åˆ™ç§°xåœ¨pç‚¹å·²ç»æ­»äº¡ã€‚\nå¦‚æœæ‰€æœ‰å¯„å­˜å™¨éƒ½è¢«å ç”¨ï¼Œä¸”è¿˜éœ€è¦ç”³è¯·ä¸€ä¸ªå¯„å­˜å™¨ï¼Œåˆ™åº”è¯¥è€ƒè™‘ä½¿ç”¨å·²ç»å­˜æ”¾æ­»äº¡å€¼çš„å¯„å­˜å™¨ï¼Œå¦‚æœä¸€ä¸ªå€¼åœ¨åŸºæœ¬å—ç»“å°¾å¤„æ˜¯æ­»çš„ï¼Œå°±ä¸å¿…åœ¨ç»“å°¾å¤„ä¿å­˜è¿™ä¸ªå€¼äº†ã€‚\nIN[B]ï¼šå—Bå¼€å§‹ç‚¹çš„æ´»è·ƒå˜é‡é›†åˆ\nOUT[B]ï¼šå—Bç»“æŸç‚¹çš„æ´»è·ƒå˜é‡é›†åˆ\nuseBï¼šå—Bä¸­æœ‰å¼•ç”¨ï¼Œä¸”åœ¨å¼•ç”¨å‰åœ¨Bä¸­æ²¡æœ‰è¢«å®šå€¼çš„å˜é‡é›†\ndefBï¼šå—Bä¸­æœ‰å®šå€¼ï¼Œä¸”è¯¥å®šå€¼å‰åœ¨Bä¸­æ²¡æœ‰è¢«å¼•ç”¨çš„å˜é‡é›†\n$$\rIN[EXIT]=\\emptyset\\\\\rOUT[B]=\\cup IN[S]\\{Sæ˜¯Bçš„åç»§\\}\\\\\rIN[B]=use_B \\cup (OUT[B]-def_B)\r$$ eg:\nå¯å¾—åˆ°å¦‚ä¸‹çš„useå’Œdefé›†åˆï¼š\n1 2 3 4 5 6 7 8 9 10 11 use[B1]={m,n,u1} def[B1]={i,j,a} use[B2]={i,j}//è¿™é‡Œè™½ç„¶iå’Œjéƒ½è¢«å®šå€¼äº†ï¼Œä½†å¼•ç”¨åœ¨å®šå€¼ä¹‹å‰ï¼Œæ‰€ä»¥ä»ç„¶æ˜¯useé›† def[B2]={}//å®šå€¼çš„iå’Œjéƒ½è¢«å¼•ç”¨äº† use[B3]={u2} def[B3]={a} use[B4]={u3} def[B4]={i} åˆå§‹åŒ–æ¯ä¸ªIN[B]éƒ½ä¸ºç©ºé›†å‚ä¸è¿ç®—ï¼Œè¿›è¡Œè¿­ä»£ï¼Œç”±äºç”¨çš„æ˜¯åç»§ï¼Œæ‰€ä»¥æˆ‘ä»¬ä»æœ€æ·±å¤„å¼€å§‹éå†ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 OUT[B4]=IN[EXIT]âˆªIN[B2]={} IN[B4]={u3} OUT[B3]={u3} IN[B3]={u2,u3} OUT[B2]=IN[B3]âˆªIN[B4]={u2,u3} IN[B2]={i,j,u2,u3} OUT[B1]={i,j,u2,u3} IN[B1]={m,n,u1,u2,u3} ç¬¬ä¸€è½®è¿­ä»£ç»“æŸï¼Œè¿›è¡Œç¬¬äºŒè½®ï¼š OUT[B4]=IN[EXIT]âˆªIN[B2]={i,j,u2,u3} IN[B4]={j,u2,u3} OUT[B3]={j,u2,u3} IN[B3]={j,u2,u3} OUT[B2]=IN[B3]âˆªIN[B4]={j,u2,u3} IN[B2]={i,j,u2,u3} OUT[B1]={i,j,u2,u3} IN[B1]={m,n,u1,u2,u3} ç¬¬äºŒè½®è¿­ä»£ç»“æŸï¼Œç¬¬ä¸‰è½®å’Œç¬¬äºŒè½®ç»“æœä¸€æ ·ï¼Œè¿­ä»£ç»“æŸã€‚ 6.5 åŸºæœ¬å—å†…ä¼˜åŒ–\råŸºæœ¬å—å¯ä»¥ç”¨DAGè¡¨ç¤ºï¼Œæ„é€ æ–¹å¼ï¼š\næ¯ä¸ªå˜é‡æœ‰ä¸€ä¸ªå¯¹åº”çš„DAGç»“ç‚¹è¡¨ç¤ºå…¶åˆå€¼ æ¯æ¡è¯­å¥séƒ½å¯¹åº”ä¸€ä¸ªå†…éƒ¨ç»“ç‚¹N ç»“ç‚¹Nçš„æ ‡å·æ˜¯sä¸­çš„è¿ç®—ç¬¦ æœ‰ä¸€ç»„å˜é‡è¢«å…³è”åˆ°Nï¼Œè¡¨ç¤ºsæ˜¯åœ¨æ­¤åŸºæœ¬å—ä¸­æœ€æ™šå¯¹è¿™äº›å˜é‡å®šå€¼çš„è¯­å¥ Nçš„å­ç»“ç‚¹æ˜¯åŸºæœ¬å—ä¸­åœ¨sä¹‹å‰ï¼Œæœ€åä¸€ä¸ªå¯¹sæ‰€ä½¿ç”¨çš„æŸä¸ªè¿ç®—åˆ†é‡è¿›è¡Œå®šå€¼çš„è¯­å¥å¯¹åº”çš„ç»“ç‚¹ã€‚å¦‚æœæŸä¸ªè¿ç®—åˆ†é‡åœ¨åŸºæœ¬å—ä¸­åœ¨sä¹‹å‰æ²¡æœ‰è¢«å®šå€¼ï¼Œåˆ™è¿™ä¸ªåˆ†é‡å¯¹åº”çš„å­ç»“ç‚¹å°±æ˜¯å…¶åˆå§‹å€¼å¯¹åº”çš„ç»“ç‚¹ï¼Œç”¨ä¸‹æ ‡0åŒºåˆ† åœ¨ä¸ºx=y+zæ„é€ èŠ‚ç‚¹Nçš„æ—¶å€™ï¼Œå¦‚æœxå·²è¢«å…³è”åˆ°æŸèŠ‚ç‚¹Mä¸Šï¼Œé‚£ä¹ˆéœ€è¦ä»Mçš„å…³è”å˜é‡ä¸­åˆ é™¤x å¦‚æœä¸¤ä¸ªè¯­å¥è¡¨è¾¾å¼ç›¸åŒï¼Œå¯ä»¥ç›´æ¥åœ¨å·²å­˜åœ¨çš„ç»“ç‚¹çš„å…³è”å˜é‡ä¸­æ·»åŠ ï¼Œè€Œä¸ç”¨åŠ å…¥æ–°çš„èŠ‚ç‚¹ æŸäº›ç»“ç‚¹æ˜¯è¾“å‡ºç»“ç‚¹ï¼Œåœ¨å‡ºå£å¤„æ´»è·ƒ ä¸€ä¸ªä¾‹å­ï¼š\n1 2 3 4 5 åŸºæœ¬å—ï¼š a = b + c b = a - d c = b + c d = a - d å½“å®ŒæˆåŸºæœ¬å—ä¼˜åŒ–åï¼Œå°±å¯ä»¥æ ¹æ®ä¼˜åŒ–å¾—åˆ°çš„DAGç”Ÿæˆæ–°çš„ç­‰ä»·çš„ä¸‰åœ°å€ä»£ç ï¼Œå¦‚æœç»“ç‚¹æœ‰å¤šä¸ªå…³è”çš„æ´»è·ƒå˜é‡ï¼Œå°±å¿…é¡»å¼•å…¥å¤åˆ¶è¯­å¥ï¼Œä¸ºæ¯ä¸ªå˜é‡èµ‹äºˆæ­£ç¡®çš„å€¼ã€‚\næ´»è·ƒå˜é‡æ˜¯æŒ‡å…¶å€¼å¯èƒ½ä¼šåœ¨ä»¥åè¢«ä½¿ç”¨çš„å˜é‡ï¼Œåœ¨DAGä¸Šåˆ é™¤æ­»ä»£ç ï¼šåˆ é™¤æ‰€æœ‰æ²¡æœ‰å…³è”æ´»è·ƒå˜é‡çš„æ ¹ç»“ç‚¹ã€‚ï¼ˆé‡å¤æ‰§è¡Œï¼‰\nä»£æ•°æ’ç­‰å¼ä½¿ç”¨ï¼šå¦‚x+0,x/1ä¹‹ç±»çš„è®¡ç®—å¯ä»¥æ¶ˆé™¤ï¼Œå±€éƒ¨å¼ºåº¦æ¶ˆå‡ï¼šx^2=x*x,2*x=x+x,x/2=x*0.5ã€‚å¸¸é‡åˆå¹¶ï¼šè®¡ç®—å¸¸é‡è¡¨è¾¾å¼çš„å€¼ã€å¸¸é‡æ¥æºï¼šç¨‹åºå‘˜ç¼–å†™ï¼Œå®å®šä¹‰å±•å¼€ï¼Œå…¶ä»–ä¼˜åŒ–æŠ€æœ¯å¸¦æ¥ã€‘äº¤æ¢å¾‹ï¼Œç»“åˆå¾‹ã€‚\næ•°ç»„å¼•ç”¨ï¼šåœ¨æ„å»ºDAGæ—¶ä¸ºäº†é¿å…å°†a[i]è¯¯åˆ¤ä¸ºå…¬å…±å­è¡¨è¾¾å¼ï¼Œéœ€è¦ä¸ºx=a[i]åˆ›å»ºä¸€ä¸ªè¿ç®—ç¬¦ä¸º=[]çš„ç»“ç‚¹ï¼Œè¯¥ç»“ç‚¹çš„å­ç»“ç‚¹ä¸ºaå’Œiï¼Œè¯¥ç»“ç‚¹çš„å…³è”å˜é‡æ˜¯xï¼Œä¸ºa[j]=yåˆ›å»ºä¸€ä¸ªè¿ç®—ç¬¦ä¸º[]=çš„ç»“ç‚¹ï¼Œå­ç»“ç‚¹ä¸ºaï¼Œjå’Œyï¼Œæ²¡æœ‰å…³è”å˜é‡ï¼Œè¯¥ç»“ç‚¹å°†æ€æ­»æ‰€æœ‰å·²ç»å»ºç«‹çš„ï¼Œå…¶å€¼ä¾èµ–äºaçš„ç»“ç‚¹ï¼Œè¢«æ€æ­»çš„ç»“ç‚¹ä¸èƒ½å†å…³è”å®šå€¼å˜é‡ï¼Œä¹Ÿå°±ä¸èƒ½æˆä¸ºå…¬å…±å­è¡¨è¾¾å¼ã€‚\nç”±ä¸Šé¢çš„ä¼˜åŒ–æ–¹æ³•ï¼Œæˆ‘ä»¬å¾—åˆ°ä¼˜åŒ–åçš„DAGï¼Œç„¶åé‡ç»„ç”Ÿæˆç­‰ä»·çš„ä¸‰åœ°å€ä»£ç ï¼Œå¯¹æ¯ä¸ªå…·æœ‰è‹¥å¹²å…³è”å®šå€¼å˜é‡çš„ç»“ç‚¹ï¼Œæ„é€ ä¸€ä¸ªä¸‰åœ°å€æŒ‡ä»¤æ¥è®¡ç®—å…¶ä¸­æŸä¸ªå˜é‡çš„å€¼ã€‚\nä¾‹å¦‚ä¸€ä¸ªåŸºæœ¬å—ï¼š\n1 2 3 4 5 6 7 8 9 10 11 b=3 d=a+c e=a*c f=e+d g=b*f h=a+c i=a*c j=h+i k=b*5 l=k+j m=l æœ‰å¦‚ä¸‹çš„DAGï¼š\nå‡è®¾åŸºæœ¬å—ç»“æŸæ—¶ä»…æœ‰læ˜¯æ´»è·ƒçš„ï¼Œåˆ™m,g,j,i,hå‡å¯ä»¥åˆ é™¤ï¼Œkå¯ä»¥è¿›è¡Œå¸¸é‡åˆå¹¶ï¼Œå¾—åˆ°å¦‚ä¸‹çš„ä¸‰åœ°å€ä»£ç ï¼š\n1 2 3 4 d=a+c e=a*c f=d+e l=15+f 6.6 æµå›¾ä¸­çš„å¾ªç¯\rç¨‹åºæ‰§è¡Œçš„å¤§éƒ¨åˆ†æ—¶é—´æ¶ˆè€—åœ¨å¾ªç¯ä¸Šï¼Œå¾ªç¯ä¼šå½±å“ç¨‹åºåˆ†æçš„è¿è¡Œæ—¶é—´ï¼Œæ”¹è¿›å¾ªç¯æ€§èƒ½çš„ä¼˜åŒ–ä¼šå¯¹ç¨‹åºæ‰§è¡Œäº§ç”Ÿæ˜¾è‘—å½±å“ã€‚\nå¾ªç¯å±•å¼€ï¼šé€šè¿‡å°†å¾ªç¯ä½“å†…çš„ä»£ç å¤åˆ¶å¤šæ¬¡ï¼Œå¢åŠ loopæ¯ä¸€æ¬¡è¿­ä»£çš„æ­¥é•¿ï¼Œå‡å°‘å¾ªç¯åˆ†æ”¯æŒ‡ä»¤æ‰§è¡Œçš„æ¬¡æ•°ï¼Œå¢å¤§å¤„ç†å™¨æŒ‡ä»¤è°ƒåº¦çš„ç©ºé—´ï¼Œå¢åŠ å¯„å­˜å™¨é‡ç”¨ã€‚\nå¾ªç¯ä¸­çš„ä¸€äº›æ¦‚å¿µï¼š\næ”¯é…ç»“ç‚¹ï¼š\nè‹¥ä»åˆå§‹ç»“ç‚¹èµ·ï¼Œæ¯æ¡åˆ°è¾¾nçš„è·¯å¾„éƒ½è¦ç»è¿‡dï¼Œå†™æˆd dom nï¼›æ¯ä¸ªç»“ç‚¹æ˜¯å®ƒæœ¬èº«çš„æ”¯é…ç»“ç‚¹ï¼Œå¾ªç¯çš„å…¥å£æ˜¯å¾ªç¯ä¸­æ‰€æœ‰ç»“ç‚¹çš„æ”¯é…ç»“ç‚¹ã€‚\nç›´æ¥æ”¯é…ç»“ç‚¹ï¼šä»å…¥å£ç»“ç‚¹åˆ°è¾¾nçš„æ‰€æœ‰è·¯å¾„ä¸Šï¼Œç»“ç‚¹nçš„æœ€åä¸€ä¸ªæ”¯é…ç»“ç‚¹ã€‚\næ±‚è§£æ”¯é…ç»“ç‚¹ä¹Ÿå¯ä»¥ç”¨æ•°æ®æµåˆ†æï¼Œçº¦æŸæ–¹ç¨‹ï¼šOUT[B]=IN[B]âˆª{B}ï¼ŒIN[B]=âˆ©OUT[P]{Pæ˜¯Bçš„å‰é©±}ï¼Œåˆå§‹åŒ–OUT[B]=Nï¼ŒOUT[ENTRY]={Entry}\næ·±åº¦ä¼˜å…ˆæ’åºï¼š\næ·±åº¦ä¼˜å…ˆæ’åºä¸ååºéå†ç›¸åã€‚å‰è¿›è¾¹ï¼šæ·±åº¦ä¼˜å…ˆç”Ÿæˆæ ‘çš„è¾¹ï¼›åæ’¤è¾¹ï¼šæŒ‡å‘ç¥–å…ˆç»“ç‚¹ï¼›äº¤å‰è¾¹ï¼šåœ¨æ ‘ä¸­äº’ä¸ä¸ºç¥–å…ˆ\nå›è¾¹ï¼š\nå¦‚æœa dom bï¼Œé‚£ä¹ˆè¾¹b-\u0026gt;aå«åšå›è¾¹ï¼Œå¦‚æœæµå›¾å¯å½’çº¦ï¼Œåˆ™åæ’¤è¾¹å°±æ˜¯å›è¾¹ï¼ˆå¯å½’çº¦ï¼šæµå›¾ä¸­æ‰€æœ‰å›è¾¹åˆ é™¤æ‰ä¹‹åï¼Œå‰©ä½™çš„å›¾æ— ç¯ï¼‰\nè‡ªç„¶å¾ªç¯ï¼šæ˜¯ä¸€ç§é€‚åˆäºä¼˜åŒ–çš„å¾ªç¯ï¼Œå…·æœ‰å¦‚ä¸‹æ€§è´¨ï¼šæœ‰å”¯ä¸€çš„å…¥å£ç»“ç‚¹ï¼Œå«åšé¦–ç»“ç‚¹ï¼Œé¦–ç»“ç‚¹æ”¯é…è¯¥å¾ªç¯ä¸­æ‰€æœ‰ç»“ç‚¹ï¼›è‡³å°‘å­˜åœ¨ä¸€æ¡å›è¾¹è¿›å…¥è¯¥å¾ªç¯é¦–ç»“ç‚¹ã€‚\nç»™å®šä¸€æ¡å›è¾¹n-\u0026gt;dï¼Œå®ƒæ‰€å¯¹åº”è‡ªç„¶å¾ªç¯åŒ…å«dåŠ ä¸Šä¸ç»è¿‡dèƒ½åˆ°è¾¾nçš„æ‰€æœ‰ç»“ç‚¹ï¼Œä¸”ç»“ç‚¹dæ˜¯è¯¥å¾ªç¯çš„é¦–ç»“ç‚¹ã€‚\nå…¶å®å°±æ˜¯æ‰¾ä»æŸä¸ªç»“ç‚¹på¼€å§‹çš„ä¸èµ°è¿‡nè¿™æ¡è·¯çš„è·¯å¾„åˆ°è¾¾nï¼ŒæŠŠè·¯å¾„èµ·ç‚¹åŠ åˆ°è‡ªç„¶å¾ªç¯ä¸­ã€‚\neg:\nå›è¾¹ è‡ªç„¶å¾ªç¯ 4-\u0026gt;3 {3,4,5,6,7,8,10} 7-\u0026gt;4 {4,5,6,7,8,10} 8-\u0026gt;3 {3,4,5,6,7,8,10} 9-\u0026gt;1 {1-10} 10-\u0026gt;7 {7,8,9} ä»¥ç¬¬ä¸€ä¸ªä¸ºä¾‹ï¼šé¦–å…ˆd(3)è¦åœ¨è‡ªç„¶å¾ªç¯é‡Œï¼Œç„¶åè€ƒè™‘å…¶ä»–ç»“ç‚¹ï¼Œæ¯”å¦‚4å¯ä»¥ä¸ç»è¿‡3åˆ°è¾¾4ï¼Œ5å¯ä»¥èµ°5-\u0026gt;7-\u0026gt;4è¿™æ¡è·¯åˆ°è¾¾4ï¼Œæ‰€ä»¥4å’Œ5éƒ½åŠ åˆ°è‡ªç„¶å¾ªç¯é‡Œï¼Œå…¶ä½™ç±»ä¼¼ï¼Œè€Œåƒ1ï¼Œåªæœ‰1-\u0026gt;2-\u0026gt;3-\u0026gt;4æˆ–1-\u0026gt;3-\u0026gt;4åˆ°è¾¾4å¿…é¡»ç»è¿‡3ï¼Œæ‰€ä»¥ä¸åœ¨è‡ªç„¶å¾ªç¯ä¸­ã€‚\nå†…å¾ªç¯ï¼šè‹¥ä¸€ä¸ªå¾ªç¯çš„ç»“ç‚¹é›†åˆæ˜¯å¦ä¸€ä¸ªå¾ªç¯çš„ç»“ç‚¹é›†åˆçš„å­é›†ã€‚\n6.7 å¯„å­˜å™¨åˆ†é…\rå¯„å­˜å™¨æ˜¯å®è´µçš„è®¡ç®—æœºèµ„æºï¼Œéœ€è¦åˆç†åˆ©ç”¨å’Œåˆ†é…ã€‚\nå¯„å­˜å™¨åˆ†é…ä¸»è¦æœ‰çº¿æ€§æ‰«æå’Œå›¾ç€è‰²ä¸¤ç±»ç®—æ³•ï¼Œå‰è€…æ¯”åè€…æ€§èƒ½æ›´å¥½ï¼Œåº”ç”¨æ›´åŠ å¹¿æ³›ï¼Œä½†éœ€è¦å€ŸåŠ©äºå˜é‡å­˜æ´»åŒºé—´çš„åˆ†æã€‚\n","date":"2024-12-29T17:13:45+08:00","image":"http://localhost:1313/post/001.png","permalink":"http://localhost:1313/p/compiler-review/","title":"ç¼–è¯‘åŸç†çŸ¥è¯†å¤ä¹ "}]